import * as WireFormat from '@glimmer/wire-format';
import { Option } from "@glimmer/util";
import { AST } from '@glimmer/syntax';
import { BlockSymbolTable, ProgramSymbolTable } from './template-visitor';
import { TemplateMeta, SerializedTemplateBlock, SerializedTemplate, Core, Statement, Statements, Expression, Expressions } from '@glimmer/wire-format';
export declare type str = string;
export declare type Params = Core.Params;
export declare type Hash = Core.Hash;
export declare type Path = Core.Path;
export declare type StackValue = Expression | Params | Hash | str;
export declare abstract class Block {
    statements: Statement[];
    abstract toJSON(): Object;
    push(statement: Statement): void;
}
export declare class InlineBlock extends Block {
    table: BlockSymbolTable;
    constructor(table: BlockSymbolTable);
    toJSON(): WireFormat.SerializedInlineBlock;
}
export declare class TemplateBlock extends Block {
    private symbolTable;
    type: string;
    yields: any;
    named: any;
    blocks: WireFormat.SerializedInlineBlock[];
    hasEval: boolean;
    constructor(symbolTable: ProgramSymbolTable);
    push(statement: Statement): void;
    toJSON(): SerializedTemplateBlock;
}
export declare class ComponentBlock extends Block {
    private table;
    attributes: Statements.Attribute[];
    arguments: Statements.Argument[];
    private inParams;
    positionals: number[];
    constructor(table: BlockSymbolTable);
    push(statement: Statement): void;
    toJSON(): [WireFormat.Statements.Attribute[], WireFormat.Core.Hash, Option<WireFormat.SerializedInlineBlock>];
}
export declare class Template<T extends TemplateMeta> {
    meta: T;
    block: TemplateBlock;
    constructor(symbols: ProgramSymbolTable, meta: T);
    toJSON(): SerializedTemplate<T>;
}
export default class JavaScriptCompiler<T extends TemplateMeta> {
    static process<T extends TemplateMeta>(opcodes: any[], symbols: ProgramSymbolTable, meta: T): Template<T>;
    private template;
    private blocks;
    private opcodes;
    private values;
    constructor(opcodes: any[], symbols: ProgramSymbolTable, meta: T);
    readonly currentBlock: Block;
    process(): Template<T>;
    startBlock([program]: [AST.Program]): void;
    endBlock(): void;
    startProgram(): void;
    endProgram(): void;
    text(content: string): void;
    append(trusted: boolean): void;
    comment(value: string): void;
    modifier(name: string): void;
    block(name: string, template: number, inverse: number): void;
    openElement(element: AST.ElementNode): void;
    flushElement(): void;
    closeElement(element: AST.ElementNode): void;
    staticAttr(name: str, namespace: str): void;
    dynamicAttr(name: str, namespace: str): void;
    trustingAttr(name: str, namespace: str): void;
    staticArg(name: str): void;
    dynamicArg(name: str): void;
    yield(to: number): void;
    debugger(evalInfo: Core.EvalInfo): void;
    hasBlock(name: number): void;
    hasBlockParams(name: number): void;
    partial(evalInfo: Core.EvalInfo): void;
    literal(value: Expressions.Value | undefined): void;
    unknown(name: string): void;
    get(head: number, path: string[]): void;
    maybeLocal(path: string[]): void;
    concat(): void;
    helper(name: string): void;
    startComponent(element: AST.ElementNode): void;
    endComponent(): [WireFormat.Statements.Attribute[], WireFormat.Core.Hash, Option<WireFormat.SerializedInlineBlock>];
    prepareArray(size: number): void;
    prepareObject(size: number): void;
    push(args: Statement): void;
    pushValue<S extends Expression | Params | Hash>(val: S): void;
    popValue<T extends StackValue>(): T;
}
