import { SymbolTable, Action } from "./template-visitor";
import { Template } from "./javascript-compiler";
import { TemplateMeta } from "@glimmer/wire-format";
import { AST } from '@glimmer/syntax';
export interface CompileOptions<T extends TemplateMeta> {
    meta: T;
}
export default class TemplateCompiler<T extends TemplateMeta> {
    static compile<T extends TemplateMeta>(options: CompileOptions<T>, ast: AST.Program): Template<T>;
    private options;
    private templateId;
    private templateIds;
    private symbolStack;
    private opcodes;
    private includeMeta;
    constructor(options: CompileOptions<T>);
    readonly symbols: SymbolTable;
    process(actions: Action[]): Action[];
    startProgram(program: [AST.Program]): void;
    endProgram(): void;
    startBlock(program: [AST.Program]): void;
    endBlock(): void;
    text([action]: [AST.TextNode]): void;
    comment([action]: [AST.CommentStatement]): void;
    openElement([action]: [AST.ElementNode]): void;
    closeElement([action]: [AST.ElementNode]): void;
    attribute([action]: [AST.AttrNode]): void;
    modifier([action]: [AST.ElementModifierStatement]): void;
    mustache([action]: [AST.MustacheStatement]): void;
    block([action]: [AST.BlockStatement]): void;
    arg([path]: [AST.PathExpression]): void;
    mustacheExpression(expr: AST.MustacheStatement): void;
    yield(to: string, action: AST.MustacheStatement): void;
    debugger(_name: string, action: AST.MustacheStatement): void;
    hasBlock(name: string, action: AST.Call): void;
    hasBlockParams(name: string, action: AST.Call): void;
    partial(_params: AST.Expression[], action: AST.MustacheStatement): void;
    builtInHelper(expr: AST.Call): void;
    SubExpression(expr: AST.SubExpression): void;
    PathExpression(expr: AST.PathExpression): void;
    StringLiteral(action: AST.StringLiteral): void;
    BooleanLiteral(action: AST.BooleanLiteral): void;
    NumberLiteral(action: AST.NumberLiteral): void;
    NullLiteral(action: AST.NullLiteral): void;
    UndefinedLiteral(action: AST.UndefinedLiteral): void;
    opcode(name: any, action: any, ...args: any[]): void;
    prepareHelper(expr: AST.Call): void;
    prepareParams(params: AST.Expression[]): void;
    prepareHash(hash: AST.Hash): void;
    prepareAttributeValue(value: AST.AttrNode['value']): boolean;
    prepareConcatParts(parts: AST.ConcatStatement['parts']): void;
    attributeMustache([action]: [AST.MustacheStatement]): void;
    meta(node: AST.BaseNode): (string | any[])[];
}
