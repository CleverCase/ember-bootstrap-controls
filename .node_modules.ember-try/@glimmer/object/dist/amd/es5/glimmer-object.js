define('@glimmer/object', ['exports', '@glimmer/object-reference', '@glimmer/util'], function (exports, _glimmer_objectReference, _glimmer_util) { 'use strict';

var HAS_SUPER_PATTERN = /\.(_super|call\(this|apply\(this)/;
var checkHasSuper = function () {
    var sourceAvailable = function () {
        return this;
    }.toString().indexOf('return this') > -1;
    if (sourceAvailable) {
        return function checkHasSuper(func) {
            return HAS_SUPER_PATTERN.test(func.toString());
        };
    }
    return function checkHasSuper() {
        return true;
    };
}();
function ROOT() {}
ROOT.__hasSuper = false;

function _defaults$1(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults$1(subClass, superClass); }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var isArray$1 = Array.isArray;


var BLUEPRINT = "8d97cf5f-db9e-48d8-a6b2-7a75b7170805";
var Descriptor = function Descriptor() {
    _classCallCheck$1(this, Descriptor);

    this["5d90f84f-908e-4a42-9749-3d0f523c262c"] = true;
};
var Blueprint = function Blueprint() {
    _classCallCheck$1(this, Blueprint);

    this["8d97cf5f-db9e-48d8-a6b2-7a75b7170805"] = true;
};
var Mixin = function () {
    function Mixin(extensions, mixins) {
        var _dependencies;

        _classCallCheck$1(this, Mixin);

        this.extensions = null;
        this.concatenatedProperties = [];
        this.mergedProperties = [];
        this.dependencies = [];
        this.reopen(extensions);
        (_dependencies = this.dependencies).push.apply(_dependencies, mixins);
    }

    Mixin.create = function create() {
        for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            args[_key2] = arguments[_key2];
        }

        var extensions = args[args.length - 1];
        if (args.length === 0) {
            return new this({}, []);
        } else if (extensions instanceof Mixin) {
            return new this({}, args);
        } else {
            var deps = args.slice(0, -1).map(toMixin);
            return new this(extensions, deps);
        }
    };

    Mixin.mixins = function mixins(obj) {
        if (typeof obj !== 'object' || obj === null) return [];
        var meta = ClassMeta.for(obj);
        if (!meta) return [];
        return meta.getAppliedMixins();
    };

    Mixin.prototype.detect = function detect(obj) {
        if (typeof obj !== 'object' || obj === null) return false;
        if (obj instanceof Mixin) {
            return obj.dependencies.indexOf(this) !== -1;
        }
        var meta = ClassMeta.for(obj);
        return !!meta && meta.hasAppliedMixin(this);
    };

    Mixin.prototype.reopen = function reopen(extensions) {
        if (this.extensions) {
            this.dependencies.push(toMixin(this.extensions));
        }
        if (typeof extensions === 'object' && 'concatenatedProperties' in extensions) {
            var concat = void 0;
            var rawConcat = extensions.concatenatedProperties;
            if (isArray$1(rawConcat)) {
                concat = rawConcat.slice();
            } else if (rawConcat === null || rawConcat === undefined) {
                concat = [];
            } else {
                concat = [rawConcat];
            }
            delete extensions.concatenatedProperties;
            this.concatenatedProperties = concat;
        }
        if (typeof extensions === 'object' && 'mergedProperties' in extensions) {
            var merged = void 0;
            var rawMerged = extensions.mergedProperties;
            if (isArray$1(rawMerged)) {
                merged = rawMerged.slice();
            } else if (rawMerged === null || rawMerged === undefined) {
                merged = [];
            } else {
                merged = [rawMerged];
            }
            delete extensions.mergedProperties;
            this.mergedProperties = merged;
        }
        var normalized = Object.keys(extensions).reduce(function (obj, key) {
            var value = extensions[key];
            switch (typeof value) {
                case 'function':
                    obj[key] = new MethodBlueprint({ value: value });
                    break;
                case 'object':
                    if (value && BLUEPRINT in value) {
                        obj[key] = value;
                        break;
                    }
                /* falls through */
                default:
                    obj[key] = new DataBlueprint({ value: value });
            }
            return obj;
        }, _glimmer_util.dict());
        this.extensions = _glimmer_util.dict();
        _glimmer_util.assign(this.extensions, turbocharge(normalized));
    };

    Mixin.prototype.apply = function apply(target) {
        var meta = target[_glimmer_objectReference.CLASS_META] = target[_glimmer_objectReference.CLASS_META] || new ClassMeta();
        this.dependencies.forEach(function (m) {
            return m.apply(target);
        });
        this.mergeProperties(target, target, meta);
        meta.addMixin(this);
        meta.seal();
        meta.reseal(target);
        return target;
    };

    Mixin.prototype.extendPrototype = function extendPrototype(Original) {
        Original.prototype = Object.create(Original.prototype);
        this.dependencies.forEach(function (m) {
            return m.extendPrototype(Original);
        });
        this.extendPrototypeOnto(Original, Original);
    };

    Mixin.prototype.extendPrototypeOnto = function extendPrototypeOnto(Subclass, Parent) {
        this.dependencies.forEach(function (m) {
            return m.extendPrototypeOnto(Subclass, Parent);
        });
        this.mergeProperties(Subclass.prototype, Parent.prototype, Subclass[_glimmer_objectReference.CLASS_META]);
        Subclass[_glimmer_objectReference.CLASS_META].addMixin(this);
    };

    Mixin.prototype.extendStatic = function extendStatic(Target) {
        this.dependencies.forEach(function (m) {
            return m.extendStatic(Target);
        });
        this.mergeProperties(Target, Object.getPrototypeOf(Target), Target[_glimmer_objectReference.CLASS_META][_glimmer_objectReference.CLASS_META]);
        Target[_glimmer_objectReference.CLASS_META].addStaticMixin(this);
    };

    Mixin.prototype.mergeProperties = function mergeProperties(target, parent, meta) {
        var _this = this;

        if (meta.hasAppliedMixin(this)) return;
        meta.addAppliedMixin(this);
        this.mergedProperties.forEach(function (k) {
            return meta.addMergedProperty(k, parent[k]);
        });
        this.concatenatedProperties.forEach(function (k) {
            return meta.addConcatenatedProperty(k, []);
        });
        new ValueDescriptor({ value: meta.getConcatenatedProperties() }).define(target, 'concatenatedProperties');
        new ValueDescriptor({ value: meta.getMergedProperties() }).define(target, 'mergedProperties');
        Object.keys(this.extensions).forEach(function (key) {
            var extension = _this.extensions[key];
            var desc = extension.descriptor(target, key, meta);
            desc.define(target, key, parent);
        });
        new ValueDescriptor({ value: ROOT }).define(target, '_super');
    };

    return Mixin;
}();
function extend(Parent) {
    var Super = Parent;
    var Subclass = function (_Super) {
        _inherits$1(Subclass, _Super);

        function Subclass() {
            _classCallCheck$1(this, Subclass);

            return _possibleConstructorReturn$1(this, _Super.apply(this, arguments));
        }

        return Subclass;
    }(Super);
    Subclass[_glimmer_objectReference.CLASS_META] = InstanceMeta.fromParent(Parent[_glimmer_objectReference.CLASS_META]);

    for (var _len2 = arguments.length, extensions = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
        extensions[_key3 - 1] = arguments[_key3];
    }

    var mixins = extensions.map(toMixin);
    Parent[_glimmer_objectReference.CLASS_META].addSubclass(Subclass);
    mixins.forEach(function (m) {
        return Subclass[_glimmer_objectReference.CLASS_META].addMixin(m);
    });
    ClassMeta.applyAllMixins(Subclass, Parent);
    return Subclass;
}
function relinkSubclasses(Parent) {
    Parent[_glimmer_objectReference.CLASS_META].getSubclasses().forEach(function (Subclass) {
        Subclass[_glimmer_objectReference.CLASS_META].reset(Parent[_glimmer_objectReference.CLASS_META]);
        Subclass.prototype = Object.create(Parent.prototype);
        ClassMeta.applyAllMixins(Subclass, Parent);
        // recurse into sub-subclasses
        relinkSubclasses(Subclass);
    });
}
function toMixin(extension) {
    if (extension instanceof Mixin) return extension;else return new Mixin(extension, []);
}

var ValueDescriptor = function (_Descriptor) {
    _inherits$1(ValueDescriptor, _Descriptor);

    function ValueDescriptor(_ref) {
        var _ref$enumerable = _ref.enumerable,
            enumerable = _ref$enumerable === undefined ? true : _ref$enumerable,
            _ref$configurable = _ref.configurable,
            configurable = _ref$configurable === undefined ? true : _ref$configurable,
            _ref$writable = _ref.writable,
            writable = _ref$writable === undefined ? true : _ref$writable,
            value = _ref.value;

        _classCallCheck$1(this, ValueDescriptor);

        var _this3 = _possibleConstructorReturn$1(this, _Descriptor.call(this));

        _this3.enumerable = enumerable;
        _this3.configurable = configurable;
        _this3.writable = writable;
        _this3.value = value;
        return _this3;
    }

    ValueDescriptor.prototype.define = function define(target, key, _home) {
        Object.defineProperty(target, key, {
            enumerable: this.enumerable,
            configurable: this.configurable,
            writable: this.writable,
            value: this.value
        });
    };

    return ValueDescriptor;
}(Descriptor);

var DataBlueprint = function (_Blueprint) {
    _inherits$1(DataBlueprint, _Blueprint);

    function DataBlueprint(_ref2) {
        var _ref2$enumerable = _ref2.enumerable,
            enumerable = _ref2$enumerable === undefined ? true : _ref2$enumerable,
            _ref2$configurable = _ref2.configurable,
            configurable = _ref2$configurable === undefined ? true : _ref2$configurable,
            _ref2$writable = _ref2.writable,
            writable = _ref2$writable === undefined ? true : _ref2$writable,
            value = _ref2.value;

        _classCallCheck$1(this, DataBlueprint);

        var _this4 = _possibleConstructorReturn$1(this, _Blueprint.call(this));

        _this4.enumerable = enumerable;
        _this4.configurable = configurable;
        _this4.value = value;
        _this4.writable = writable;
        return _this4;
    }

    DataBlueprint.prototype.descriptor = function descriptor(_target, key, classMeta) {
        var enumerable = this.enumerable,
            configurable = this.configurable,
            writable = this.writable,
            value = this.value;

        if (classMeta.hasConcatenatedProperty(key)) {
            classMeta.addConcatenatedProperty(key, value);
            value = classMeta.getConcatenatedProperty(key);
        } else if (classMeta.hasMergedProperty(key)) {
            classMeta.addMergedProperty(key, value);
            value = classMeta.getMergedProperty(key);
        }
        return new ValueDescriptor({ enumerable: enumerable, configurable: configurable, writable: writable, value: value });
    };

    return DataBlueprint;
}(Blueprint);
var AccessorBlueprint = function (_Blueprint2) {
    _inherits$1(AccessorBlueprint, _Blueprint2);

    function AccessorBlueprint(_ref3) {
        var _ref3$enumerable = _ref3.enumerable,
            enumerable = _ref3$enumerable === undefined ? true : _ref3$enumerable,
            _ref3$configurable = _ref3.configurable,
            configurable = _ref3$configurable === undefined ? true : _ref3$configurable,
            get = _ref3.get,
            set = _ref3.set;

        _classCallCheck$1(this, AccessorBlueprint);

        var _this5 = _possibleConstructorReturn$1(this, _Blueprint2.call(this));

        _this5.enumerable = enumerable;
        _this5.configurable = configurable;
        _this5.get = get;
        _this5.set = set;
        return _this5;
    }

    AccessorBlueprint.prototype.descriptor = function descriptor(_target, _key, _classMeta) {
        return new ValueDescriptor({
            enumerable: this.enumerable,
            configurable: this.configurable,
            get: this.get,
            set: this.set
        });
    };

    return AccessorBlueprint;
}(Blueprint);

var MethodDescriptor = function (_ValueDescriptor) {
    _inherits$1(MethodDescriptor, _ValueDescriptor);

    function MethodDescriptor() {
        _classCallCheck$1(this, MethodDescriptor);

        return _possibleConstructorReturn$1(this, _ValueDescriptor.apply(this, arguments));
    }

    MethodDescriptor.prototype.define = function define(target, key, home) {
        this.value = wrapMethod(home, key, this.value);
        _ValueDescriptor.prototype.define.call(this, target, key, home);
    };

    return MethodDescriptor;
}(ValueDescriptor);

var MethodBlueprint = function (_DataBlueprint) {
    _inherits$1(MethodBlueprint, _DataBlueprint);

    function MethodBlueprint() {
        _classCallCheck$1(this, MethodBlueprint);

        return _possibleConstructorReturn$1(this, _DataBlueprint.apply(this, arguments));
    }

    MethodBlueprint.prototype.descriptor = function descriptor(target, key, classMeta) {
        var desc = _DataBlueprint.prototype.descriptor.call(this, target, key, classMeta);
        return new MethodDescriptor(desc);
    };

    return MethodBlueprint;
}(DataBlueprint);

function wrapMethod(home, methodName, original) {
    if (!(methodName in home)) return maybeWrap(original);
    var superMethod = home[methodName];
    var func = function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
            args[_key4] = arguments[_key4];
        }

        if (!this) return original.apply(this, args);
        var lastSuper = this._super;
        this._super = superMethod;
        try {
            return original.apply(this, args);
        } finally {
            this._super = lastSuper;
        }
    };
    func.__wrapped = true;
    return func;
}
function maybeWrap(original) {
    if ('__wrapped' in original) return original;
    return function () {
        for (var _len4 = arguments.length, args = Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
            args[_key5] = arguments[_key5];
        }

        if (!this) return original.apply(this, args);
        var lastSuper = this._super;
        this._super = ROOT;
        try {
            return original.apply(this, args);
        } finally {
            this._super = lastSuper;
        }
    };
}

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var isArray = Array.isArray;

var EMPTY_CACHE = function EMPTY_CACHE() {};
var CLASS_META$1 = "df8be4c8-4e89-44e2-a8f9-550c8dacdca7";
function turbocharge(obj) {
    // function Dummy() {}
    // Dummy.prototype = obj;
    return obj;
}

var SealedMeta = function (_Meta) {
    _inherits(SealedMeta, _Meta);

    function SealedMeta() {
        _classCallCheck(this, SealedMeta);

        return _possibleConstructorReturn(this, _Meta.apply(this, arguments));
    }

    SealedMeta.prototype.addReferenceTypeFor = function addReferenceTypeFor() {
        throw new Error("Cannot modify reference types on a sealed meta");
    };

    return SealedMeta;
}(_glimmer_objectReference.Meta);

var ClassMeta = function () {
    function ClassMeta() {
        _classCallCheck(this, ClassMeta);

        this.referenceTypes = _glimmer_util.dict();
        this.propertyMetadata = _glimmer_util.dict();
        this.concatenatedProperties = _glimmer_util.dict();
        this.hasConcatenatedProperties = false;
        this.mergedProperties = _glimmer_util.dict();
        this.hasMergedProperties = false;
        this.mixins = [];
        this.appliedMixins = [];
        this.staticMixins = [];
        this.subclasses = [];
        this.slots = [];
        this.InstanceMetaConstructor = null;
    }

    ClassMeta.fromParent = function fromParent(parent) {
        var meta = new this();
        meta.reset(parent);
        return meta;
    };

    ClassMeta.for = function _for(object) {
        if (CLASS_META$1 in object) return object[CLASS_META$1];else if (object.constructor) return object.constructor[CLASS_META$1] || null;else return null;
    };

    ClassMeta.prototype.init = function init(object, attrs) {
        if (typeof attrs !== 'object' || attrs === null) return;
        if (this.hasConcatenatedProperties) {
            var concatProps = this.concatenatedProperties;
            for (var prop in concatProps) {
                if (prop in attrs) {
                    var concat = concatProps[prop].slice();
                    object[prop] = concat.concat(attrs[prop]);
                }
            }
        }
        if (this.hasMergedProperties) {
            var mergedProps = this.mergedProperties;
            for (var _prop in mergedProps) {
                if (_prop in attrs) {
                    var merged = _glimmer_util.assign({}, mergedProps[_prop]);
                    object[_prop] = _glimmer_util.assign(merged, attrs[_prop]);
                }
            }
        }
    };

    ClassMeta.prototype.addStaticMixin = function addStaticMixin(mixin) {
        this.staticMixins.push(mixin);
    };

    ClassMeta.prototype.addMixin = function addMixin(mixin) {
        this.mixins.push(mixin);
    };

    ClassMeta.prototype.getStaticMixins = function getStaticMixins() {
        return this.staticMixins;
    };

    ClassMeta.prototype.getMixins = function getMixins() {
        return this.mixins;
    };

    ClassMeta.prototype.addAppliedMixin = function addAppliedMixin(mixin) {
        this.appliedMixins.push(mixin);
    };

    ClassMeta.prototype.hasAppliedMixin = function hasAppliedMixin(mixin) {
        return this.appliedMixins.indexOf(mixin) !== -1;
    };

    ClassMeta.prototype.getAppliedMixins = function getAppliedMixins() {
        return this.appliedMixins;
    };

    ClassMeta.prototype.hasStaticMixin = function hasStaticMixin(mixin) {
        return this.staticMixins.indexOf(mixin) !== -1;
    };

    ClassMeta.applyAllMixins = function applyAllMixins(Subclass, Parent) {
        Subclass[CLASS_META$1].getMixins().forEach(function (m) {
            return m.extendPrototypeOnto(Subclass, Parent);
        });
        Subclass[CLASS_META$1].getStaticMixins().forEach(function (m) {
            return m.extendStatic(Subclass);
        });
        Subclass[CLASS_META$1].seal();
    };

    ClassMeta.prototype.addSubclass = function addSubclass(constructor) {
        this.subclasses.push(constructor);
    };

    ClassMeta.prototype.getSubclasses = function getSubclasses() {
        return this.subclasses;
    };

    ClassMeta.prototype.addPropertyMetadata = function addPropertyMetadata(property, value) {
        this.propertyMetadata[property] = value;
    };

    ClassMeta.prototype.metadataForProperty = function metadataForProperty(property) {
        return this.propertyMetadata[property];
    };

    ClassMeta.prototype.addReferenceTypeFor = function addReferenceTypeFor(property, type) {
        this.referenceTypes[property] = type;
    };

    ClassMeta.prototype.addSlotFor = function addSlotFor(property) {
        this.slots.push(property);
    };

    ClassMeta.prototype.hasConcatenatedProperty = function hasConcatenatedProperty(property) {
        if (!this.hasConcatenatedProperties) return false;
        return property in this.concatenatedProperties;
    };

    ClassMeta.prototype.getConcatenatedProperty = function getConcatenatedProperty(property) {
        return this.concatenatedProperties[property];
    };

    ClassMeta.prototype.getConcatenatedProperties = function getConcatenatedProperties() {
        return Object.keys(this.concatenatedProperties);
    };

    ClassMeta.prototype.addConcatenatedProperty = function addConcatenatedProperty(property, value) {
        this.hasConcatenatedProperties = true;
        if (property in this.concatenatedProperties) {
            var val = this.concatenatedProperties[property].concat(value);
            this.concatenatedProperties[property] = val;
        } else {
            this.concatenatedProperties[property] = value;
        }
    };

    ClassMeta.prototype.hasMergedProperty = function hasMergedProperty(property) {
        if (!this.hasMergedProperties) return false;
        return property in this.mergedProperties;
    };

    ClassMeta.prototype.getMergedProperty = function getMergedProperty(property) {
        return this.mergedProperties[property];
    };

    ClassMeta.prototype.getMergedProperties = function getMergedProperties() {
        return Object.keys(this.mergedProperties);
    };

    ClassMeta.prototype.addMergedProperty = function addMergedProperty(property, value) {
        this.hasMergedProperties = true;
        if (isArray(value)) {
            throw new Error('You passed in `' + JSON.stringify(value) + '` as the value for `foo` but `foo` cannot be an Array');
        }
        if (property in this.mergedProperties && this.mergedProperties[property] && value) {
            this.mergedProperties[property] = mergeMergedProperties(value, this.mergedProperties[property]);
        } else {
            value = value === null ? value : value || {};
            this.mergedProperties[property] = value;
        }
    };

    ClassMeta.prototype.getReferenceTypes = function getReferenceTypes() {
        return this.referenceTypes;
    };

    ClassMeta.prototype.getPropertyMetadata = function getPropertyMetadata() {
        return this.propertyMetadata;
    };

    ClassMeta.prototype.reset = function reset(parent) {
        this.referenceTypes = _glimmer_util.dict();
        this.propertyMetadata = _glimmer_util.dict();
        this.concatenatedProperties = _glimmer_util.dict();
        this.mergedProperties = _glimmer_util.dict();
        if (parent) {
            this.hasConcatenatedProperties = parent.hasConcatenatedProperties;
            for (var prop in parent.concatenatedProperties) {
                this.concatenatedProperties[prop] = parent.concatenatedProperties[prop].slice();
            }
            this.hasMergedProperties = parent.hasMergedProperties;
            for (var _prop2 in parent.mergedProperties) {
                this.mergedProperties[_prop2] = _glimmer_util.assign({}, parent.mergedProperties[_prop2]);
            }
            _glimmer_util.assign(this.referenceTypes, parent.referenceTypes);
            _glimmer_util.assign(this.propertyMetadata, parent.propertyMetadata);
        }
    };

    ClassMeta.prototype.reseal = function reseal(obj) {
        var meta = _glimmer_objectReference.Meta.for(obj);
        var fresh = new this.InstanceMetaConstructor(obj, {});
        var referenceTypes = meta.getReferenceTypes();
        var slots = meta.getSlots();
        turbocharge(_glimmer_util.assign(referenceTypes, this.referenceTypes));
        turbocharge(_glimmer_util.assign(slots, fresh.getSlots()));
    };

    ClassMeta.prototype.seal = function seal() {
        var referenceTypes = turbocharge(_glimmer_util.assign({}, this.referenceTypes));
        turbocharge(this.concatenatedProperties);
        turbocharge(this.mergedProperties);
        if (!this.hasMergedProperties && !this.hasConcatenatedProperties) {
            this.init = function () {};
        }
        var slots = this.slots;

        var Slots = function Slots() {
            var _this2 = this;

            _classCallCheck(this, Slots);

            slots.forEach(function (name) {
                _this2[name] = EMPTY_CACHE;
            });
        };

        this.InstanceMetaConstructor = function (_SealedMeta) {
            _inherits(_class, _SealedMeta);

            function _class() {
                _classCallCheck(this, _class);

                var _this3 = _possibleConstructorReturn(this, _SealedMeta.apply(this, arguments));

                _this3.slots = new Slots();
                _this3.referenceTypes = referenceTypes;
                return _this3;
            }

            _class.prototype.getReferenceTypes = function getReferenceTypes() {
                return this.referenceTypes;
            };

            _class.prototype.referenceTypeFor = function referenceTypeFor(property) {
                return this.referenceTypes[property] || _glimmer_objectReference.PropertyReference;
            };

            _class.prototype.getSlots = function getSlots() {
                return this.slots;
            };

            return _class;
        }(SealedMeta);
        turbocharge(this);
    };

    return ClassMeta;
}();
function mergeMergedProperties(attrs, parent) {
    var merged = _glimmer_util.assign({}, parent);
    for (var prop in attrs) {
        if (prop in parent && typeof parent[prop] === 'function' && typeof attrs[prop] === 'function') {
            var wrapped = wrapMethod(parent, prop, attrs[prop]);
            merged[prop] = wrapped;
        } else {
            merged[prop] = attrs[prop];
        }
    }
    return merged;
}
var InstanceMeta = function (_ClassMeta) {
    _inherits(InstanceMeta, _ClassMeta);

    function InstanceMeta() {
        _classCallCheck(this, InstanceMeta);

        var _this4 = _possibleConstructorReturn(this, _ClassMeta.apply(this, arguments));

        _this4["df8be4c8-4e89-44e2-a8f9-550c8dacdca7"] = ClassMeta.fromParent(null);
        return _this4;
    }

    InstanceMeta.fromParent = function fromParent(parent) {
        return _ClassMeta.fromParent.call(this, parent);
    };

    InstanceMeta.prototype.reset = function reset(parent) {
        _ClassMeta.prototype.reset.call(this, parent);
        if (parent) this[CLASS_META$1].reset(parent[CLASS_META$1]);
    };

    InstanceMeta.prototype.seal = function seal() {
        _ClassMeta.prototype.seal.call(this);
        this[CLASS_META$1].seal();
    };

    return InstanceMeta;
}(ClassMeta);

var GlimmerObject = function () {
    function GlimmerObject(attrs) {
        _classCallCheck(this, GlimmerObject);

        this._super = ROOT;
        this._meta = null;
        if (attrs) _glimmer_util.assign(this, attrs);
        this.constructor[CLASS_META$1].init(this, attrs || null);
        this._super = ROOT;
        _glimmer_util.initializeGuid(this);
        this.init();
    }

    GlimmerObject.extend = function extend$$1() {
        for (var _len = arguments.length, extensions = Array(_len), _key = 0; _key < _len; _key++) {
            extensions[_key] = arguments[_key];
        }

        return extend.apply(undefined, [this].concat(extensions));
    };

    GlimmerObject.create = function create(attrs) {
        return new this(attrs);
    };

    GlimmerObject.reopen = function reopen(extensions) {
        toMixin(extensions).extendPrototype(this);
        this[CLASS_META$1].seal();
        relinkSubclasses(this);
    };

    GlimmerObject.reopenClass = function reopenClass(extensions) {
        toMixin(extensions).extendStatic(this);
        this[CLASS_META$1].seal();
    };

    GlimmerObject.metaForProperty = function metaForProperty(property) {
        var value = this[CLASS_META$1].metadataForProperty(property);
        if (!value) throw new Error('metaForProperty() could not find a computed property with key \'' + property + '\'.');
        return value;
    };

    GlimmerObject.eachComputedProperty = function eachComputedProperty(callback) {
        var metadata = this[CLASS_META$1].getPropertyMetadata();
        if (!metadata) return;
        for (var prop in metadata) {
            callback(prop, metadata[prop]);
        }
    };

    GlimmerObject.prototype.init = function init() {};

    GlimmerObject.prototype.get = function get(key) {
        return this[key];
    };

    GlimmerObject.prototype.set = function set(key, value) {
        this[key] = value;
    };

    GlimmerObject.prototype.setProperties = function setProperties(attrs) {
        _glimmer_util.assign(this, attrs);
    };

    GlimmerObject.prototype.destroy = function destroy() {};

    return GlimmerObject;
}();

GlimmerObject["df8be4c8-4e89-44e2-a8f9-550c8dacdca7"] = InstanceMeta.fromParent(null);
GlimmerObject.isClass = true;

function _defaults$2(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults$2(subClass, superClass); }

var ComputedBlueprint = function (_Blueprint) {
    _inherits$2(ComputedBlueprint, _Blueprint);

    function ComputedBlueprint(accessor) {
        var deps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        _classCallCheck$2(this, ComputedBlueprint);

        var _this = _possibleConstructorReturn$2(this, _Blueprint.call(this));

        _this.metadata = {};
        _this.accessor = accessor;
        _this.deps = deps;
        return _this;
    }

    ComputedBlueprint.prototype.descriptor = function descriptor(_target, key, classMeta) {
        classMeta.addReferenceTypeFor(key, _glimmer_objectReference.ComputedReferenceBlueprint(key, this.deps));
        classMeta.addPropertyMetadata(key, this.metadata);
        classMeta.addSlotFor(key);
        return new Computed(this.accessor);
    };

    ComputedBlueprint.prototype.property = function property() {
        for (var _len = arguments.length, paths = Array(_len), _key = 0; _key < _len; _key++) {
            paths[_key] = arguments[_key];
        }

        this.deps = paths.map(function (d) {
            return d.split('.');
        });
        return this;
    };

    ComputedBlueprint.prototype.meta = function meta(object) {
        this.metadata = object;
        return this;
    };

    ComputedBlueprint.prototype.volatile = function volatile() {
        return this;
    };

    return ComputedBlueprint;
}(Blueprint);

var Computed = function () {
    function Computed(accessor) {
        _classCallCheck$2(this, Computed);

        this["5d90f84f-908e-4a42-9749-3d0f523c262c"] = true;
        this.accessor = accessor;
    }

    Computed.prototype.define = function define(prototype, key, home) {
        Object.defineProperty(prototype, key, wrapAccessor(home, key, this.accessor));
    };

    return Computed;
}();

function wrapAccessor(home, accessorName, _desc) {
    var superDesc = getPropertyDescriptor(home, accessorName);
    var originalGet = void 0;
    var originalSet = void 0;
    var desc = {
        enumerable: true,
        configurable: true
    };
    var get = _desc.get;
    if (get && get.length > 0) {
        originalGet = function () {
            return get.call(this, accessorName);
        };
    } else {
        originalGet = _desc.get;
    }
    var set = _desc.set;
    if (set && set.length > 1) {
        originalSet = function (value) {
            return set.call(this, accessorName, value);
        };
    } else {
        originalSet = _desc.set;
    }
    var cacheGet = function () {
        if (_glimmer_objectReference.Meta.exists(this)) {
            var slot = _glimmer_objectReference.Meta.for(this).getSlots()[accessorName];
            if (slot !== EMPTY_CACHE) return slot;
        }
        return originalGet.call(this);
    };
    var cacheSet = void 0;
    if (originalSet) {
        cacheSet = function (value) {
            var meta = _glimmer_objectReference.Meta.for(this);
            var slots = meta.getSlots();
            var ret = originalSet.call(this, value);
            if (ret !== undefined) {
                slots[accessorName] = ret;
            }
        };
    } else {
        cacheSet = function (value) {
            var meta = _glimmer_objectReference.Meta.for(this);
            var slots = meta.getSlots();
            if (value !== undefined) slots[accessorName] = value;
        };
    }
    if (!superDesc || 'value' in superDesc) {
        desc.get = cacheGet;
        desc.set = cacheSet;
        return desc;
    }
    desc.get = function () {
        var lastSuper = this._super;
        this._super = function () {
            return superDesc.get.call(this);
        };
        try {
            return cacheGet.call(this);
        } finally {
            this._super = lastSuper;
        }
    };
    desc.set = function (val) {
        var lastSuper = this._super;
        this._super = function () {
            return superDesc.set.call(this, val);
        };
        try {
            return cacheSet.call(this, val);
        } finally {
            this._super = lastSuper;
        }
    };
    return desc;
}
function getPropertyDescriptor(subject, name) {
    var pd = Object.getOwnPropertyDescriptor(subject, name);
    var proto = Object.getPrototypeOf(subject);
    while (typeof pd === 'undefined' && proto !== null) {
        pd = Object.getOwnPropertyDescriptor(proto, name);
        proto = Object.getPrototypeOf(proto);
    }
    return pd;
}
function computed() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
    }

    var last = args.pop();
    var deps = args;
    if (typeof last === 'function') {
        var _ref;

        return (_ref = new ComputedBlueprint({
            get: last
        })).property.apply(_ref, deps);
    } else if (typeof last === 'object') {
        var _ref2;

        return (_ref2 = new ComputedBlueprint(last)).property.apply(_ref2, deps);
    } else {
        throw new TypeError("computed expects a function or an object as last argument");
    }
}
function observer() {}

function _defaults$3(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults$3(subClass, superClass); }

var AliasMethodDescriptor = function (_Descriptor) {
    _inherits$3(AliasMethodDescriptor, _Descriptor);

    function AliasMethodDescriptor(name) {
        _classCallCheck$3(this, AliasMethodDescriptor);

        var _this = _possibleConstructorReturn$3(this, _Descriptor.call(this));

        _this.name = name;
        return _this;
    }

    AliasMethodDescriptor.prototype.define = function define(target, key, _home) {
        var name = this.name;
        Object.defineProperty(target, key, {
            enumerable: true,
            configurable: true,
            get: function () {
                return this[name];
            }
        });
    };

    return AliasMethodDescriptor;
}(Descriptor);

var AliasMethodBlueprint = function (_Blueprint) {
    _inherits$3(AliasMethodBlueprint, _Blueprint);

    function AliasMethodBlueprint(name) {
        _classCallCheck$3(this, AliasMethodBlueprint);

        var _this2 = _possibleConstructorReturn$3(this, _Blueprint.call(this));

        _this2.name = name;
        return _this2;
    }

    AliasMethodBlueprint.prototype.descriptor = function descriptor(_target, _key, _meta) {
        return new AliasMethodDescriptor(this.name);
    };

    return AliasMethodBlueprint;
}(Blueprint);

function aliasMethod(name) {
    return new AliasMethodBlueprint(name);
}

var AliasBlueprint = function (_ComputedBlueprint) {
    _inherits$3(AliasBlueprint, _ComputedBlueprint);

    function AliasBlueprint(name) {
        _classCallCheck$3(this, AliasBlueprint);

        var parent = name.slice(0, -1);
        var last = name[name.length - 1];
        var get = function () {
            return name.reduce(function (obj, n) {
                return obj[n];
            }, this);
        };
        var set = function (value) {
            var p = parent.reduce(function (obj, n) {
                return obj[n];
            }, this);
            p[last] = value;
        };

        var _this3 = _possibleConstructorReturn$3(this, _ComputedBlueprint.call(this, { get: get, set: set }, [name]));

        _this3.name = name;
        return _this3;
    }

    AliasBlueprint.prototype.descriptor = function descriptor(target, key, meta) {
        if (this.name[0] === key) throw new Error('Setting alias \'' + key + '\' on self');
        return _ComputedBlueprint.prototype.descriptor.call(this, target, key, meta);
    };

    return AliasBlueprint;
}(ComputedBlueprint);

function alias(name) {
    return new AliasBlueprint(name.split('.'));
}

exports['default'] = GlimmerObject;
exports.ClassMeta = ClassMeta;
exports.InstanceMeta = InstanceMeta;
exports.computed = computed;
exports.observer = observer;
exports.Mixin = Mixin;
exports.Blueprint = Blueprint;
exports.toMixin = toMixin;
exports.aliasMethod = aliasMethod;
exports.alias = alias;

Object.defineProperty(exports, '__esModule', { value: true });

});
