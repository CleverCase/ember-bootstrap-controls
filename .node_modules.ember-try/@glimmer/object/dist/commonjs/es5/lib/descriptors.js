"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.aliasMethod = aliasMethod;
exports.alias = alias;

var _mixin = require("./mixin");

var _computed = require("./computed");

function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);for (var i = 0; i < keys.length; i++) {
        var key = keys[i];var value = Object.getOwnPropertyDescriptor(defaults, key);if (value && value.configurable && obj[key] === undefined) {
            Object.defineProperty(obj, key, value);
        }
    }return obj;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
}

var AliasMethodDescriptor = function (_Descriptor) {
    _inherits(AliasMethodDescriptor, _Descriptor);

    function AliasMethodDescriptor(name) {
        _classCallCheck(this, AliasMethodDescriptor);

        var _this = _possibleConstructorReturn(this, _Descriptor.call(this));

        _this.name = name;
        return _this;
    }

    AliasMethodDescriptor.prototype.define = function define(target, key, _home) {
        var name = this.name;
        Object.defineProperty(target, key, {
            enumerable: true,
            configurable: true,
            get: function () {
                return this[name];
            }
        });
    };

    return AliasMethodDescriptor;
}(_mixin.Descriptor);

var AliasMethodBlueprint = function (_Blueprint) {
    _inherits(AliasMethodBlueprint, _Blueprint);

    function AliasMethodBlueprint(name) {
        _classCallCheck(this, AliasMethodBlueprint);

        var _this2 = _possibleConstructorReturn(this, _Blueprint.call(this));

        _this2.name = name;
        return _this2;
    }

    AliasMethodBlueprint.prototype.descriptor = function descriptor(_target, _key, _meta) {
        return new AliasMethodDescriptor(this.name);
    };

    return AliasMethodBlueprint;
}(_mixin.Blueprint);

function aliasMethod(name) {
    return new AliasMethodBlueprint(name);
}

var AliasBlueprint = function (_ComputedBlueprint) {
    _inherits(AliasBlueprint, _ComputedBlueprint);

    function AliasBlueprint(name) {
        _classCallCheck(this, AliasBlueprint);

        var parent = name.slice(0, -1);
        var last = name[name.length - 1];
        var get = function () {
            return name.reduce(function (obj, n) {
                return obj[n];
            }, this);
        };
        var set = function (value) {
            var p = parent.reduce(function (obj, n) {
                return obj[n];
            }, this);
            p[last] = value;
        };

        var _this3 = _possibleConstructorReturn(this, _ComputedBlueprint.call(this, { get: get, set: set }, [name]));

        _this3.name = name;
        return _this3;
    }

    AliasBlueprint.prototype.descriptor = function descriptor(target, key, meta) {
        if (this.name[0] === key) throw new Error('Setting alias \'' + key + '\' on self');
        return _ComputedBlueprint.prototype.descriptor.call(this, target, key, meta);
    };

    return AliasBlueprint;
}(_computed.ComputedBlueprint);

function alias(name) {
    return new AliasBlueprint(name.split('.'));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kZXNjcmlwdG9ycy5qcyJdLCJuYW1lcyI6WyJCbHVlcHJpbnQiLCJEZXNjcmlwdG9yIiwiQ29tcHV0ZWRCbHVlcHJpbnQiLCJBbGlhc01ldGhvZERlc2NyaXB0b3IiLCJuYW1lIiwiZGVmaW5lIiwidGFyZ2V0Iiwia2V5IiwiX2hvbWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJBbGlhc01ldGhvZEJsdWVwcmludCIsImRlc2NyaXB0b3IiLCJfdGFyZ2V0IiwiX2tleSIsIl9tZXRhIiwiYWxpYXNNZXRob2QiLCJBbGlhc0JsdWVwcmludCIsInBhcmVudCIsInNsaWNlIiwibGFzdCIsImxlbmd0aCIsInJlZHVjZSIsIm9iaiIsIm4iLCJzZXQiLCJ2YWx1ZSIsInAiLCJtZXRhIiwiRXJyb3IiLCJhbGlhcyIsInNwbGl0Il0sIm1hcHBpbmdzIjoiOzs7OztRQTJCTyxBQUFTO1FBc0JULEFBQVM7O0FBakRoQixBQUFTLEFBQVcsQUFBa0I7O0FBQ3RDLEFBQVMsQUFBeUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SSxBQUM1QjtxQ0FDRjs7bUNBQUEsQUFBWSxNQUFNOzhCQUFBOztxREFDZCxpQkFEYyxBQUVkOztjQUFBLEFBQUssT0FGUyxBQUVkLEFBQVk7ZUFDZjs7O29DLEFBQ0QseUIsQUFBTyxRQUFRLEEsSyxBQUFLLE9BQU8sQUFDdkI7WUFBSSxPQUFPLEtBQVgsQUFBZ0IsQUFDaEI7ZUFBQSxBQUFPLGVBQVAsQUFBc0IsUUFBdEIsQUFBOEI7d0JBQUssQUFDbkIsQUFDWjswQkFGK0IsQUFFakIsQUFDZDtBQUgrQiw2QkFHekIsQUFDRjt1QkFBTyxLQUFQLEFBQU8sQUFBSyxBQUNmO0FBTEwsQUFBbUMsQUFPdEM7QUFQc0MsQUFDL0I7QTs7O0FBUndCLEE7O0lBZ0I5QixBO29DQUNGOztrQ0FBQSxBQUFZLE1BQU07OEJBQUE7O3NEQUNkLGdCQURjLEFBRWQ7O2VBQUEsQUFBSyxPQUZTLEFBRWQsQUFBWTtlQUNmOzs7bUNBQ0QsQSxpQ0FBVyxBLFMsQUFBUyxNQUFNLEEsT0FBTyxBQUM3QjtlQUFPLElBQUEsQUFBSSxzQkFBc0IsS0FBakMsQUFBTyxBQUErQixBQUN6QztBOzs7QUFFTCxBLEFBVG1DOztBQVM1QixxQkFBQSxBQUFxQixNQUFNLEFBQzlCO1dBQU8sSUFBQSxBQUFJLHFCQUFYLEFBQU8sQUFBeUIsQUFDbkM7OztJLEFBQ0s7OEJBQ0Y7OzRCQUFBLEFBQVksTUFBTTs4QkFDZDs7WUFBSSxTQUFTLEtBQUEsQUFBSyxNQUFMLEFBQVcsR0FBRyxDQUEzQixBQUFhLEFBQWUsQUFDNUI7WUFBSSxPQUFPLEtBQUssS0FBQSxBQUFLLFNBQXJCLEFBQVcsQUFBbUIsQUFDOUI7WUFBSSxNQUFNLFlBQVksQUFDbEI7d0JBQU8sQUFBSyxPQUFPLFVBQUEsQUFBQyxLQUFELEFBQU0sR0FBTjt1QkFBWSxJQUFaLEFBQVksQUFBSTtBQUE1QixhQUFBLEVBQVAsQUFBTyxBQUFnQyxBQUMxQztBQUZELEFBR0E7WUFBSSxNQUFNLFVBQUEsQUFBVSxPQUFPLEFBQ3ZCO2dCQUFJLFdBQUksQUFBTyxPQUFPLFVBQUEsQUFBQyxLQUFELEFBQU0sR0FBTjt1QkFBWSxJQUFaLEFBQVksQUFBSTtBQUE5QixhQUFBLEVBQVIsQUFBUSxBQUFrQyxBQUMxQztjQUFBLEFBQUUsUUFBRixBQUFVLEFBQ2I7QUFUYSxBQU1kOztzREFJQSw4QkFBTSxFQUFFLEtBQUYsS0FBTyxLQUFiLEFBQU0sT0FBYyxDQVZOLEFBVWQsQUFBb0IsQUFBQyxBQUNyQjs7ZUFBQSxBQUFLLE9BWFMsQUFXZCxBQUFZO2VBQ2Y7Ozs2QixBQUNELGlDLEFBQVcsUSxBQUFRLEtBQUssQSxNQUFNLEFBQzFCO1lBQUksS0FBQSxBQUFLLEtBQUwsQUFBVSxPQUFkLEFBQXFCLEtBQUssTUFBTSxJQUFBLEFBQUksMkJBQUosQUFBNEIsTUFBbEMsQUFDMUI7ZUFBTyw2QkFBQSxBQUFNLHNCQUFOLEFBQWlCLFFBQWpCLEFBQXlCLEtBQWhDLEFBQU8sQUFBOEIsQUFDeEM7QTs7O0EsQUFqQndCLEFBbUI3Qjs7QUFBTyxlQUFBLEFBQWUsTUFBTSxBQUN4QjtXQUFPLElBQUEsQUFBSSxlQUFlLEtBQUEsQUFBSyxNQUEvQixBQUFPLEFBQW1CLEFBQVcsQUFDeEMiLCJmaWxlIjoibGliL2Rlc2NyaXB0b3JzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmx1ZXByaW50LCBEZXNjcmlwdG9yIH0gZnJvbSAnLi9taXhpbic7XG5pbXBvcnQgeyBDb21wdXRlZEJsdWVwcmludCB9IGZyb20gJy4vY29tcHV0ZWQnO1xuY2xhc3MgQWxpYXNNZXRob2REZXNjcmlwdG9yIGV4dGVuZHMgRGVzY3JpcHRvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBkZWZpbmUodGFyZ2V0LCBrZXksIF9ob21lKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEFsaWFzTWV0aG9kQmx1ZXByaW50IGV4dGVuZHMgQmx1ZXByaW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIGRlc2NyaXB0b3IoX3RhcmdldCwgX2tleSwgX21ldGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbGlhc01ldGhvZERlc2NyaXB0b3IodGhpcy5uYW1lKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWxpYXNNZXRob2QobmFtZSkge1xuICAgIHJldHVybiBuZXcgQWxpYXNNZXRob2RCbHVlcHJpbnQobmFtZSk7XG59XG5jbGFzcyBBbGlhc0JsdWVwcmludCBleHRlbmRzIENvbXB1dGVkQmx1ZXByaW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgbGV0IGxhc3QgPSBuYW1lW25hbWUubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS5yZWR1Y2UoKG9iaiwgbikgPT4gb2JqW25dLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IHAgPSBwYXJlbnQucmVkdWNlKChvYmosIG4pID0+IG9ialtuXSwgdGhpcyk7XG4gICAgICAgICAgICBwW2xhc3RdID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKHsgZ2V0LCBzZXQgfSwgW25hbWVdKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgZGVzY3JpcHRvcih0YXJnZXQsIGtleSwgbWV0YSkge1xuICAgICAgICBpZiAodGhpcy5uYW1lWzBdID09PSBrZXkpIHRocm93IG5ldyBFcnJvcihgU2V0dGluZyBhbGlhcyAnJHtrZXl9JyBvbiBzZWxmYCk7XG4gICAgICAgIHJldHVybiBzdXBlci5kZXNjcmlwdG9yKHRhcmdldCwga2V5LCBtZXRhKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWxpYXMobmFtZSkge1xuICAgIHJldHVybiBuZXcgQWxpYXNCbHVlcHJpbnQobmFtZS5zcGxpdCgnLicpKTtcbn0iXX0=