function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { CLASS_META } from '@glimmer/object-reference';
import { dict, assign } from '@glimmer/util';
import { ClassMeta, InstanceMeta, turbocharge } from './object';
import { ROOT } from './utils';
var isArray = Array.isArray;

export var DESCRIPTOR = "5d90f84f-908e-4a42-9749-3d0f523c262c";
export var BLUEPRINT = "8d97cf5f-db9e-48d8-a6b2-7a75b7170805";
export var Descriptor = function Descriptor() {
    _classCallCheck(this, Descriptor);

    this["5d90f84f-908e-4a42-9749-3d0f523c262c"] = true;
};
export var Blueprint = function Blueprint() {
    _classCallCheck(this, Blueprint);

    this["8d97cf5f-db9e-48d8-a6b2-7a75b7170805"] = true;
};
export var Mixin = function () {
    function Mixin(extensions, mixins) {
        var _dependencies;

        _classCallCheck(this, Mixin);

        this.extensions = null;
        this.concatenatedProperties = [];
        this.mergedProperties = [];
        this.dependencies = [];
        this.reopen(extensions);
        (_dependencies = this.dependencies).push.apply(_dependencies, mixins);
    }

    Mixin.create = function create() {
        for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            args[_key2] = arguments[_key2];
        }

        var extensions = args[args.length - 1];
        if (args.length === 0) {
            return new this({}, []);
        } else if (extensions instanceof Mixin) {
            return new this({}, args);
        } else {
            var deps = args.slice(0, -1).map(toMixin);
            return new this(extensions, deps);
        }
    };

    Mixin.mixins = function mixins(obj) {
        if (typeof obj !== 'object' || obj === null) return [];
        var meta = ClassMeta.for(obj);
        if (!meta) return [];
        return meta.getAppliedMixins();
    };

    Mixin.prototype.detect = function detect(obj) {
        if (typeof obj !== 'object' || obj === null) return false;
        if (obj instanceof Mixin) {
            return obj.dependencies.indexOf(this) !== -1;
        }
        var meta = ClassMeta.for(obj);
        return !!meta && meta.hasAppliedMixin(this);
    };

    Mixin.prototype.reopen = function reopen(extensions) {
        if (this.extensions) {
            this.dependencies.push(toMixin(this.extensions));
        }
        if (typeof extensions === 'object' && 'concatenatedProperties' in extensions) {
            var concat = void 0;
            var rawConcat = extensions.concatenatedProperties;
            if (isArray(rawConcat)) {
                concat = rawConcat.slice();
            } else if (rawConcat === null || rawConcat === undefined) {
                concat = [];
            } else {
                concat = [rawConcat];
            }
            delete extensions.concatenatedProperties;
            this.concatenatedProperties = concat;
        }
        if (typeof extensions === 'object' && 'mergedProperties' in extensions) {
            var merged = void 0;
            var rawMerged = extensions.mergedProperties;
            if (isArray(rawMerged)) {
                merged = rawMerged.slice();
            } else if (rawMerged === null || rawMerged === undefined) {
                merged = [];
            } else {
                merged = [rawMerged];
            }
            delete extensions.mergedProperties;
            this.mergedProperties = merged;
        }
        var normalized = Object.keys(extensions).reduce(function (obj, key) {
            var value = extensions[key];
            switch (typeof value) {
                case 'function':
                    obj[key] = new MethodBlueprint({ value: value });
                    break;
                case 'object':
                    if (value && BLUEPRINT in value) {
                        obj[key] = value;
                        break;
                    }
                /* falls through */
                default:
                    obj[key] = new DataBlueprint({ value: value });
            }
            return obj;
        }, dict());
        this.extensions = dict();
        assign(this.extensions, turbocharge(normalized));
    };

    Mixin.prototype.apply = function apply(target) {
        var meta = target[CLASS_META] = target[CLASS_META] || new ClassMeta();
        this.dependencies.forEach(function (m) {
            return m.apply(target);
        });
        this.mergeProperties(target, target, meta);
        meta.addMixin(this);
        meta.seal();
        meta.reseal(target);
        return target;
    };

    Mixin.prototype.extendPrototype = function extendPrototype(Original) {
        Original.prototype = Object.create(Original.prototype);
        this.dependencies.forEach(function (m) {
            return m.extendPrototype(Original);
        });
        this.extendPrototypeOnto(Original, Original);
    };

    Mixin.prototype.extendPrototypeOnto = function extendPrototypeOnto(Subclass, Parent) {
        this.dependencies.forEach(function (m) {
            return m.extendPrototypeOnto(Subclass, Parent);
        });
        this.mergeProperties(Subclass.prototype, Parent.prototype, Subclass[CLASS_META]);
        Subclass[CLASS_META].addMixin(this);
    };

    Mixin.prototype.extendStatic = function extendStatic(Target) {
        this.dependencies.forEach(function (m) {
            return m.extendStatic(Target);
        });
        this.mergeProperties(Target, Object.getPrototypeOf(Target), Target[CLASS_META][CLASS_META]);
        Target[CLASS_META].addStaticMixin(this);
    };

    Mixin.prototype.mergeProperties = function mergeProperties(target, parent, meta) {
        var _this = this;

        if (meta.hasAppliedMixin(this)) return;
        meta.addAppliedMixin(this);
        this.mergedProperties.forEach(function (k) {
            return meta.addMergedProperty(k, parent[k]);
        });
        this.concatenatedProperties.forEach(function (k) {
            return meta.addConcatenatedProperty(k, []);
        });
        new ValueDescriptor({ value: meta.getConcatenatedProperties() }).define(target, 'concatenatedProperties');
        new ValueDescriptor({ value: meta.getMergedProperties() }).define(target, 'mergedProperties');
        Object.keys(this.extensions).forEach(function (key) {
            var extension = _this.extensions[key];
            var desc = extension.descriptor(target, key, meta);
            desc.define(target, key, parent);
        });
        new ValueDescriptor({ value: ROOT }).define(target, '_super');
    };

    return Mixin;
}();
export function extend(Parent) {
    var Super = Parent;
    var Subclass = function (_Super) {
        _inherits(Subclass, _Super);

        function Subclass() {
            _classCallCheck(this, Subclass);

            return _possibleConstructorReturn(this, _Super.apply(this, arguments));
        }

        return Subclass;
    }(Super);
    Subclass[CLASS_META] = InstanceMeta.fromParent(Parent[CLASS_META]);

    for (var _len2 = arguments.length, extensions = Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
        extensions[_key3 - 1] = arguments[_key3];
    }

    var mixins = extensions.map(toMixin);
    Parent[CLASS_META].addSubclass(Subclass);
    mixins.forEach(function (m) {
        return Subclass[CLASS_META].addMixin(m);
    });
    ClassMeta.applyAllMixins(Subclass, Parent);
    return Subclass;
}
export function relinkSubclasses(Parent) {
    Parent[CLASS_META].getSubclasses().forEach(function (Subclass) {
        Subclass[CLASS_META].reset(Parent[CLASS_META]);
        Subclass.prototype = Object.create(Parent.prototype);
        ClassMeta.applyAllMixins(Subclass, Parent);
        // recurse into sub-subclasses
        relinkSubclasses(Subclass);
    });
}
export function toMixin(extension) {
    if (extension instanceof Mixin) return extension;else return new Mixin(extension, []);
}

var ValueDescriptor = function (_Descriptor) {
    _inherits(ValueDescriptor, _Descriptor);

    function ValueDescriptor(_ref) {
        var _ref$enumerable = _ref.enumerable,
            enumerable = _ref$enumerable === undefined ? true : _ref$enumerable,
            _ref$configurable = _ref.configurable,
            configurable = _ref$configurable === undefined ? true : _ref$configurable,
            _ref$writable = _ref.writable,
            writable = _ref$writable === undefined ? true : _ref$writable,
            value = _ref.value;

        _classCallCheck(this, ValueDescriptor);

        var _this3 = _possibleConstructorReturn(this, _Descriptor.call(this));

        _this3.enumerable = enumerable;
        _this3.configurable = configurable;
        _this3.writable = writable;
        _this3.value = value;
        return _this3;
    }

    ValueDescriptor.prototype.define = function define(target, key, _home) {
        Object.defineProperty(target, key, {
            enumerable: this.enumerable,
            configurable: this.configurable,
            writable: this.writable,
            value: this.value
        });
    };

    return ValueDescriptor;
}(Descriptor);

export var DataBlueprint = function (_Blueprint) {
    _inherits(DataBlueprint, _Blueprint);

    function DataBlueprint(_ref2) {
        var _ref2$enumerable = _ref2.enumerable,
            enumerable = _ref2$enumerable === undefined ? true : _ref2$enumerable,
            _ref2$configurable = _ref2.configurable,
            configurable = _ref2$configurable === undefined ? true : _ref2$configurable,
            _ref2$writable = _ref2.writable,
            writable = _ref2$writable === undefined ? true : _ref2$writable,
            value = _ref2.value;

        _classCallCheck(this, DataBlueprint);

        var _this4 = _possibleConstructorReturn(this, _Blueprint.call(this));

        _this4.enumerable = enumerable;
        _this4.configurable = configurable;
        _this4.value = value;
        _this4.writable = writable;
        return _this4;
    }

    DataBlueprint.prototype.descriptor = function descriptor(_target, key, classMeta) {
        var enumerable = this.enumerable,
            configurable = this.configurable,
            writable = this.writable,
            value = this.value;

        if (classMeta.hasConcatenatedProperty(key)) {
            classMeta.addConcatenatedProperty(key, value);
            value = classMeta.getConcatenatedProperty(key);
        } else if (classMeta.hasMergedProperty(key)) {
            classMeta.addMergedProperty(key, value);
            value = classMeta.getMergedProperty(key);
        }
        return new ValueDescriptor({ enumerable: enumerable, configurable: configurable, writable: writable, value: value });
    };

    return DataBlueprint;
}(Blueprint);
export var AccessorBlueprint = function (_Blueprint2) {
    _inherits(AccessorBlueprint, _Blueprint2);

    function AccessorBlueprint(_ref3) {
        var _ref3$enumerable = _ref3.enumerable,
            enumerable = _ref3$enumerable === undefined ? true : _ref3$enumerable,
            _ref3$configurable = _ref3.configurable,
            configurable = _ref3$configurable === undefined ? true : _ref3$configurable,
            get = _ref3.get,
            set = _ref3.set;

        _classCallCheck(this, AccessorBlueprint);

        var _this5 = _possibleConstructorReturn(this, _Blueprint2.call(this));

        _this5.enumerable = enumerable;
        _this5.configurable = configurable;
        _this5.get = get;
        _this5.set = set;
        return _this5;
    }

    AccessorBlueprint.prototype.descriptor = function descriptor(_target, _key, _classMeta) {
        return new ValueDescriptor({
            enumerable: this.enumerable,
            configurable: this.configurable,
            get: this.get,
            set: this.set
        });
    };

    return AccessorBlueprint;
}(Blueprint);

var MethodDescriptor = function (_ValueDescriptor) {
    _inherits(MethodDescriptor, _ValueDescriptor);

    function MethodDescriptor() {
        _classCallCheck(this, MethodDescriptor);

        return _possibleConstructorReturn(this, _ValueDescriptor.apply(this, arguments));
    }

    MethodDescriptor.prototype.define = function define(target, key, home) {
        this.value = wrapMethod(home, key, this.value);
        _ValueDescriptor.prototype.define.call(this, target, key, home);
    };

    return MethodDescriptor;
}(ValueDescriptor);

var MethodBlueprint = function (_DataBlueprint) {
    _inherits(MethodBlueprint, _DataBlueprint);

    function MethodBlueprint() {
        _classCallCheck(this, MethodBlueprint);

        return _possibleConstructorReturn(this, _DataBlueprint.apply(this, arguments));
    }

    MethodBlueprint.prototype.descriptor = function descriptor(target, key, classMeta) {
        var desc = _DataBlueprint.prototype.descriptor.call(this, target, key, classMeta);
        return new MethodDescriptor(desc);
    };

    return MethodBlueprint;
}(DataBlueprint);

export function wrapMethod(home, methodName, original) {
    if (!(methodName in home)) return maybeWrap(original);
    var superMethod = home[methodName];
    var func = function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
            args[_key4] = arguments[_key4];
        }

        if (!this) return original.apply(this, args);
        var lastSuper = this._super;
        this._super = superMethod;
        try {
            return original.apply(this, args);
        } finally {
            this._super = lastSuper;
        }
    };
    func.__wrapped = true;
    return func;
}
function maybeWrap(original) {
    if ('__wrapped' in original) return original;
    return function () {
        for (var _len4 = arguments.length, args = Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
            args[_key5] = arguments[_key5];
        }

        if (!this) return original.apply(this, args);
        var lastSuper = this._super;
        this._super = ROOT;
        try {
            return original.apply(this, args);
        } finally {
            this._super = lastSuper;
        }
    };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9taXhpbi5qcyJdLCJuYW1lcyI6WyJDTEFTU19NRVRBIiwiZGljdCIsImFzc2lnbiIsIkNsYXNzTWV0YSIsIkluc3RhbmNlTWV0YSIsInR1cmJvY2hhcmdlIiwiUk9PVCIsImlzQXJyYXkiLCJBcnJheSIsIkRFU0NSSVBUT1IiLCJCTFVFUFJJTlQiLCJEZXNjcmlwdG9yIiwiQmx1ZXByaW50IiwiTWl4aW4iLCJleHRlbnNpb25zIiwibWl4aW5zIiwiY29uY2F0ZW5hdGVkUHJvcGVydGllcyIsIm1lcmdlZFByb3BlcnRpZXMiLCJkZXBlbmRlbmNpZXMiLCJyZW9wZW4iLCJwdXNoIiwiY3JlYXRlIiwiYXJncyIsImxlbmd0aCIsImRlcHMiLCJzbGljZSIsIm1hcCIsInRvTWl4aW4iLCJvYmoiLCJtZXRhIiwiZm9yIiwiZ2V0QXBwbGllZE1peGlucyIsImRldGVjdCIsImluZGV4T2YiLCJoYXNBcHBsaWVkTWl4aW4iLCJjb25jYXQiLCJyYXdDb25jYXQiLCJ1bmRlZmluZWQiLCJtZXJnZWQiLCJyYXdNZXJnZWQiLCJub3JtYWxpemVkIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImtleSIsInZhbHVlIiwiTWV0aG9kQmx1ZXByaW50IiwiRGF0YUJsdWVwcmludCIsImFwcGx5IiwidGFyZ2V0IiwiZm9yRWFjaCIsIm0iLCJtZXJnZVByb3BlcnRpZXMiLCJhZGRNaXhpbiIsInNlYWwiLCJyZXNlYWwiLCJleHRlbmRQcm90b3R5cGUiLCJPcmlnaW5hbCIsInByb3RvdHlwZSIsImV4dGVuZFByb3RvdHlwZU9udG8iLCJTdWJjbGFzcyIsIlBhcmVudCIsImV4dGVuZFN0YXRpYyIsIlRhcmdldCIsImdldFByb3RvdHlwZU9mIiwiYWRkU3RhdGljTWl4aW4iLCJwYXJlbnQiLCJhZGRBcHBsaWVkTWl4aW4iLCJhZGRNZXJnZWRQcm9wZXJ0eSIsImsiLCJhZGRDb25jYXRlbmF0ZWRQcm9wZXJ0eSIsIlZhbHVlRGVzY3JpcHRvciIsImdldENvbmNhdGVuYXRlZFByb3BlcnRpZXMiLCJkZWZpbmUiLCJnZXRNZXJnZWRQcm9wZXJ0aWVzIiwiZXh0ZW5zaW9uIiwiZGVzYyIsImRlc2NyaXB0b3IiLCJleHRlbmQiLCJTdXBlciIsImZyb21QYXJlbnQiLCJhZGRTdWJjbGFzcyIsImFwcGx5QWxsTWl4aW5zIiwicmVsaW5rU3ViY2xhc3NlcyIsImdldFN1YmNsYXNzZXMiLCJyZXNldCIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9ob21lIiwiZGVmaW5lUHJvcGVydHkiLCJfdGFyZ2V0IiwiY2xhc3NNZXRhIiwiaGFzQ29uY2F0ZW5hdGVkUHJvcGVydHkiLCJnZXRDb25jYXRlbmF0ZWRQcm9wZXJ0eSIsImhhc01lcmdlZFByb3BlcnR5IiwiZ2V0TWVyZ2VkUHJvcGVydHkiLCJBY2Nlc3NvckJsdWVwcmludCIsImdldCIsInNldCIsIl9rZXkiLCJfY2xhc3NNZXRhIiwiTWV0aG9kRGVzY3JpcHRvciIsImhvbWUiLCJ3cmFwTWV0aG9kIiwibWV0aG9kTmFtZSIsIm9yaWdpbmFsIiwibWF5YmVXcmFwIiwic3VwZXJNZXRob2QiLCJmdW5jIiwibGFzdFN1cGVyIiwiX3N1cGVyIiwiX193cmFwcGVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLFNBQVNBLFVBQVQsUUFBMkIsMkJBQTNCO0FBQ0EsU0FBU0MsSUFBVCxFQUFlQyxNQUFmLFFBQTZCLGVBQTdCO0FBQ0EsU0FBU0MsU0FBVCxFQUFvQkMsWUFBcEIsRUFBa0NDLFdBQWxDLFFBQXFELFVBQXJEO0FBQ0EsU0FBU0MsSUFBVCxRQUFxQixTQUFyQjtJQUNRQyxPLEdBQVlDLEssQ0FBWkQsTzs7QUFDUixPQUFPLElBQU1FLGFBQWEsc0NBQW5CO0FBQ1AsT0FBTyxJQUFNQyxZQUFZLHNDQUFsQjtBQUNQLFdBQWFDLFVBQWIsR0FDSSxzQkFBYztBQUFBOztBQUNWLFNBQUssc0NBQUwsSUFBK0MsSUFBL0M7QUFDSCxDQUhMO0FBS0EsV0FBYUMsU0FBYixHQUNJLHFCQUFjO0FBQUE7O0FBQ1YsU0FB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O0FBQUEsMkNBQU5wRixJQUFNO0FBQU5BLGdCQUFNO0FBQUE7O0FBQ3RCLFlBQUksQ0FBQyxJQUFMLEVBQVcsT0FBT29GLFNBQVMxRCxLQUFULENBQWUsSUFBZixFQUFxQjFCLElBQXJCLENBQVA7QUFDWCxZQUFJd0YsWUFBWSxLQUFLQyxNQUFyQjtBQUNBLGFBQUtBLE1BQUwsR0FBY3pHLElBQWQ7QUFDQSxZQUFJO0FBQ0EsbUJBQU9vRyxTQUFTMUQsS0FBVCxDQUFlLElBQWYsRUFBcUIxQixJQUFyQixDQUFQO0FBQ0gsU0FGRCxTQUVVO0FBQ04saUJBQUt5RixNQUFMLEdBQWNELFNBQWQ7QUFDSDtBQUNKLEtBVEQ7QUFVSCIsImZpbGUiOiJsaWIvbWl4aW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDTEFTU19NRVRBIH0gZnJvbSAnQGdsaW1tZXIvb2JqZWN0LXJlZmVyZW5jZSc7XG5pbXBvcnQgeyBkaWN0LCBhc3NpZ24gfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IENsYXNzTWV0YSwgSW5zdGFuY2VNZXRhLCB0dXJib2NoYXJnZSB9IGZyb20gJy4vb2JqZWN0JztcbmltcG9ydCB7IFJPT1QgfSBmcm9tICcuL3V0aWxzJztcbmNvbnN0IHsgaXNBcnJheSB9ID0gQXJyYXk7XG5leHBvcnQgY29uc3QgREVTQ1JJUFRPUiA9IFwiNWQ5MGY4NGYtOTA4ZS00YTQyLTk3NDktM2QwZjUyM2MyNjJjXCI7XG5leHBvcnQgY29uc3QgQkxVRVBSSU5UID0gXCI4ZDk3Y2Y1Zi1kYjllLTQ4ZDgtYTZiMi03YTc1YjcxNzA4MDVcIjtcbmV4cG9ydCBjbGFzcyBEZXNjcmlwdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpc1tcIjVkOTBmODRmLTkwOGUtNGE0Mi05NzQ5LTNkMGY1MjNjMjYyY1wiXSA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJsdWVwcmludCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXNbXCI4ZDk3Y2Y1Zi1kYjllLTQ4ZDgtYTZiMi03YTc1YjcxNzA4MDVcIl0gPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNaXhpbiB7XG4gICAgY29uc3RydWN0b3IoZXh0ZW5zaW9ucywgbWl4aW5zKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uY2F0ZW5hdGVkUHJvcGVydGllcyA9IFtdO1xuICAgICAgICB0aGlzLm1lcmdlZFByb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yZW9wZW4oZXh0ZW5zaW9ucyk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLnB1c2goLi4ubWl4aW5zKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZSguLi5hcmdzKSB7XG4gICAgICAgIGxldCBleHRlbnNpb25zID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyh7fSwgW10pO1xuICAgICAgICB9IGVsc2UgaWYgKGV4dGVuc2lvbnMgaW5zdGFuY2VvZiBNaXhpbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHt9LCBhcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkZXBzID0gYXJncy5zbGljZSgwLCAtMSkubWFwKHRvTWl4aW4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGV4dGVuc2lvbnMsIGRlcHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBtaXhpbnMob2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBbXTtcbiAgICAgICAgbGV0IG1ldGEgPSBDbGFzc01ldGEuZm9yKG9iaik7XG4gICAgICAgIGlmICghbWV0YSkgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gbWV0YS5nZXRBcHBsaWVkTWl4aW5zKCk7XG4gICAgfVxuICAgIGRldGVjdChvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTWl4aW4pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZGVwZW5kZW5jaWVzLmluZGV4T2YodGhpcykgIT09IC0xO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRhID0gQ2xhc3NNZXRhLmZvcihvYmopO1xuICAgICAgICByZXR1cm4gISFtZXRhICYmIG1ldGEuaGFzQXBwbGllZE1peGluKHRoaXMpO1xuICAgIH1cbiAgICByZW9wZW4oZXh0ZW5zaW9ucykge1xuICAgICAgICBpZiAodGhpcy5leHRlbnNpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKHRvTWl4aW4odGhpcy5leHRlbnNpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb25zID09PSAnb2JqZWN0JyAmJiAnY29uY2F0ZW5hdGVkUHJvcGVydGllcycgaW4gZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgbGV0IGNvbmNhdDtcbiAgICAgICAgICAgIGxldCByYXdDb25jYXQgPSBleHRlbnNpb25zLmNvbmNhdGVuYXRlZFByb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShyYXdDb25jYXQpKSB7XG4gICAgICAgICAgICAgICAgY29uY2F0ID0gcmF3Q29uY2F0LnNsaWNlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJhd0NvbmNhdCA9PT0gbnVsbCB8fCByYXdDb25jYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbmNhdCA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25jYXQgPSBbcmF3Q29uY2F0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBleHRlbnNpb25zLmNvbmNhdGVuYXRlZFByb3BlcnRpZXM7XG4gICAgICAgICAgICB0aGlzLmNvbmNhdGVuYXRlZFByb3BlcnRpZXMgPSBjb25jYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb25zID09PSAnb2JqZWN0JyAmJiAnbWVyZ2VkUHJvcGVydGllcycgaW4gZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgbGV0IG1lcmdlZDtcbiAgICAgICAgICAgIGxldCByYXdNZXJnZWQgPSBleHRlbnNpb25zLm1lcmdlZFByb3BlcnRpZXM7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShyYXdNZXJnZWQpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkID0gcmF3TWVyZ2VkLnNsaWNlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJhd01lcmdlZCA9PT0gbnVsbCB8fCByYXdNZXJnZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWQgPSBbcmF3TWVyZ2VkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBleHRlbnNpb25zLm1lcmdlZFByb3BlcnRpZXM7XG4gICAgICAgICAgICB0aGlzLm1lcmdlZFByb3BlcnRpZXMgPSBtZXJnZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vcm1hbGl6ZWQgPSBPYmplY3Qua2V5cyhleHRlbnNpb25zKS5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBleHRlbnNpb25zW2tleV07XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBuZXcgTWV0aG9kQmx1ZXByaW50KHsgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBCTFVFUFJJTlQgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IG5ldyBEYXRhQmx1ZXByaW50KHsgdmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCBkaWN0KCkpO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbnMgPSBkaWN0KCk7XG4gICAgICAgIGFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHR1cmJvY2hhcmdlKG5vcm1hbGl6ZWQpKTtcbiAgICB9XG4gICAgYXBwbHkodGFyZ2V0KSB7XG4gICAgICAgIGxldCBtZXRhID0gdGFyZ2V0W0NMQVNTX01FVEFdID0gdGFyZ2V0W0NMQVNTX01FVEFdIHx8IG5ldyBDbGFzc01ldGEoKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMuZm9yRWFjaChtID0+IG0uYXBwbHkodGFyZ2V0KSk7XG4gICAgICAgIHRoaXMubWVyZ2VQcm9wZXJ0aWVzKHRhcmdldCwgdGFyZ2V0LCBtZXRhKTtcbiAgICAgICAgbWV0YS5hZGRNaXhpbih0aGlzKTtcbiAgICAgICAgbWV0YS5zZWFsKCk7XG4gICAgICAgIG1ldGEucmVzZWFsKHRhcmdldCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGV4dGVuZFByb3RvdHlwZShPcmlnaW5hbCkge1xuICAgICAgICBPcmlnaW5hbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9yaWdpbmFsLnByb3RvdHlwZSk7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLmZvckVhY2gobSA9PiBtLmV4dGVuZFByb3RvdHlwZShPcmlnaW5hbCkpO1xuICAgICAgICB0aGlzLmV4dGVuZFByb3RvdHlwZU9udG8oT3JpZ2luYWwsIE9yaWdpbmFsKTtcbiAgICB9XG4gICAgZXh0ZW5kUHJvdG90eXBlT250byhTdWJjbGFzcywgUGFyZW50KSB7XG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzLmZvckVhY2gobSA9PiBtLmV4dGVuZFByb3RvdHlwZU9udG8oU3ViY2xhc3MsIFBhcmVudCkpO1xuICAgICAgICB0aGlzLm1lcmdlUHJvcGVydGllcyhTdWJjbGFzcy5wcm90b3R5cGUsIFBhcmVudC5wcm90b3R5cGUsIFN1YmNsYXNzW0NMQVNTX01FVEFdKTtcbiAgICAgICAgU3ViY2xhc3NbQ0xBU1NfTUVUQV0uYWRkTWl4aW4odGhpcyk7XG4gICAgfVxuICAgIGV4dGVuZFN0YXRpYyhUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMuZm9yRWFjaChtID0+IG0uZXh0ZW5kU3RhdGljKFRhcmdldCkpO1xuICAgICAgICB0aGlzLm1lcmdlUHJvcGVydGllcyhUYXJnZXQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihUYXJnZXQpLCBUYXJnZXRbQ0xBU1NfTUVUQV1bQ0xBU1NfTUVUQV0pO1xuICAgICAgICBUYXJnZXRbQ0xBU1NfTUVUQV0uYWRkU3RhdGljTWl4aW4odGhpcyk7XG4gICAgfVxuICAgIG1lcmdlUHJvcGVydGllcyh0YXJnZXQsIHBhcmVudCwgbWV0YSkge1xuICAgICAgICBpZiAobWV0YS5oYXNBcHBsaWVkTWl4aW4odGhpcykpIHJldHVybjtcbiAgICAgICAgbWV0YS5hZGRBcHBsaWVkTWl4aW4odGhpcyk7XG4gICAgICAgIHRoaXMubWVyZ2VkUHJvcGVydGllcy5mb3JFYWNoKGsgPT4gbWV0YS5hZGRNZXJnZWRQcm9wZXJ0eShrLCBwYXJlbnRba10pKTtcbiAgICAgICAgdGhpcy5jb25jYXRlbmF0ZWRQcm9wZXJ0aWVzLmZvckVhY2goayA9PiBtZXRhLmFkZENvbmNhdGVuYXRlZFByb3BlcnR5KGssIFtdKSk7XG4gICAgICAgIG5ldyBWYWx1ZURlc2NyaXB0b3IoeyB2YWx1ZTogbWV0YS5nZXRDb25jYXRlbmF0ZWRQcm9wZXJ0aWVzKCkgfSkuZGVmaW5lKHRhcmdldCwgJ2NvbmNhdGVuYXRlZFByb3BlcnRpZXMnKTtcbiAgICAgICAgbmV3IFZhbHVlRGVzY3JpcHRvcih7IHZhbHVlOiBtZXRhLmdldE1lcmdlZFByb3BlcnRpZXMoKSB9KS5kZWZpbmUodGFyZ2V0LCAnbWVyZ2VkUHJvcGVydGllcycpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmV4dGVuc2lvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCBleHRlbnNpb24gPSB0aGlzLmV4dGVuc2lvbnNba2V5XTtcbiAgICAgICAgICAgIGxldCBkZXNjID0gZXh0ZW5zaW9uLmRlc2NyaXB0b3IodGFyZ2V0LCBrZXksIG1ldGEpO1xuICAgICAgICAgICAgZGVzYy5kZWZpbmUodGFyZ2V0LCBrZXksIHBhcmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXcgVmFsdWVEZXNjcmlwdG9yKHsgdmFsdWU6IFJPT1QgfSkuZGVmaW5lKHRhcmdldCwgJ19zdXBlcicpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoUGFyZW50LCAuLi5leHRlbnNpb25zKSB7XG4gICAgbGV0IFN1cGVyID0gUGFyZW50O1xuICAgIGxldCBTdWJjbGFzcyA9IGNsYXNzIGV4dGVuZHMgU3VwZXIge307XG4gICAgU3ViY2xhc3NbQ0xBU1NfTUVUQV0gPSBJbnN0YW5jZU1ldGEuZnJvbVBhcmVudChQYXJlbnRbQ0xBU1NfTUVUQV0pO1xuICAgIGxldCBtaXhpbnMgPSBleHRlbnNpb25zLm1hcCh0b01peGluKTtcbiAgICBQYXJlbnRbQ0xBU1NfTUVUQV0uYWRkU3ViY2xhc3MoU3ViY2xhc3MpO1xuICAgIG1peGlucy5mb3JFYWNoKG0gPT4gU3ViY2xhc3NbQ0xBU1NfTUVUQV0uYWRkTWl4aW4obSkpO1xuICAgIENsYXNzTWV0YS5hcHBseUFsbE1peGlucyhTdWJjbGFzcywgUGFyZW50KTtcbiAgICByZXR1cm4gU3ViY2xhc3M7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVsaW5rU3ViY2xhc3NlcyhQYXJlbnQpIHtcbiAgICBQYXJlbnRbQ0xBU1NfTUVUQV0uZ2V0U3ViY2xhc3NlcygpLmZvckVhY2goU3ViY2xhc3MgPT4ge1xuICAgICAgICBTdWJjbGFzc1tDTEFTU19NRVRBXS5yZXNldChQYXJlbnRbQ0xBU1NfTUVUQV0pO1xuICAgICAgICBTdWJjbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhcmVudC5wcm90b3R5cGUpO1xuICAgICAgICBDbGFzc01ldGEuYXBwbHlBbGxNaXhpbnMoU3ViY2xhc3MsIFBhcmVudCk7XG4gICAgICAgIC8vIHJlY3Vyc2UgaW50byBzdWItc3ViY2xhc3Nlc1xuICAgICAgICByZWxpbmtTdWJjbGFzc2VzKFN1YmNsYXNzKTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b01peGluKGV4dGVuc2lvbikge1xuICAgIGlmIChleHRlbnNpb24gaW5zdGFuY2VvZiBNaXhpbikgcmV0dXJuIGV4dGVuc2lvbjtlbHNlIHJldHVybiBuZXcgTWl4aW4oZXh0ZW5zaW9uLCBbXSk7XG59XG5jbGFzcyBWYWx1ZURlc2NyaXB0b3IgZXh0ZW5kcyBEZXNjcmlwdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGVudW1lcmFibGUgPSB0cnVlLCBjb25maWd1cmFibGUgPSB0cnVlLCB3cml0YWJsZSA9IHRydWUsIHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZTtcbiAgICAgICAgdGhpcy5jb25maWd1cmFibGUgPSBjb25maWd1cmFibGU7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB3cml0YWJsZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBkZWZpbmUodGFyZ2V0LCBrZXksIF9ob21lKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdGhpcy5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0aGlzLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0aGlzLndyaXRhYmxlLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERhdGFCbHVlcHJpbnQgZXh0ZW5kcyBCbHVlcHJpbnQge1xuICAgIGNvbnN0cnVjdG9yKHsgZW51bWVyYWJsZSA9IHRydWUsIGNvbmZpZ3VyYWJsZSA9IHRydWUsIHdyaXRhYmxlID0gdHJ1ZSwgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVudW1lcmFibGUgPSBlbnVtZXJhYmxlO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gd3JpdGFibGU7XG4gICAgfVxuICAgIGRlc2NyaXB0b3IoX3RhcmdldCwga2V5LCBjbGFzc01ldGEpIHtcbiAgICAgICAgbGV0IHsgZW51bWVyYWJsZSwgY29uZmlndXJhYmxlLCB3cml0YWJsZSwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjbGFzc01ldGEuaGFzQ29uY2F0ZW5hdGVkUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY2xhc3NNZXRhLmFkZENvbmNhdGVuYXRlZFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUgPSBjbGFzc01ldGEuZ2V0Q29uY2F0ZW5hdGVkUHJvcGVydHkoa2V5KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbGFzc01ldGEuaGFzTWVyZ2VkUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY2xhc3NNZXRhLmFkZE1lcmdlZFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUgPSBjbGFzc01ldGEuZ2V0TWVyZ2VkUHJvcGVydHkoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlRGVzY3JpcHRvcih7IGVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUsIHZhbHVlIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBY2Nlc3NvckJsdWVwcmludCBleHRlbmRzIEJsdWVwcmludCB7XG4gICAgY29uc3RydWN0b3IoeyBlbnVtZXJhYmxlID0gdHJ1ZSwgY29uZmlndXJhYmxlID0gdHJ1ZSwgZ2V0LCBzZXQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVudW1lcmFibGUgPSBlbnVtZXJhYmxlO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYWJsZSA9IGNvbmZpZ3VyYWJsZTtcbiAgICAgICAgdGhpcy5nZXQgPSBnZXQ7XG4gICAgICAgIHRoaXMuc2V0ID0gc2V0O1xuICAgIH1cbiAgICBkZXNjcmlwdG9yKF90YXJnZXQsIF9rZXksIF9jbGFzc01ldGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZURlc2NyaXB0b3Ioe1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdGhpcy5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0aGlzLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIGdldDogdGhpcy5nZXQsXG4gICAgICAgICAgICBzZXQ6IHRoaXMuc2V0XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIE1ldGhvZERlc2NyaXB0b3IgZXh0ZW5kcyBWYWx1ZURlc2NyaXB0b3Ige1xuICAgIGRlZmluZSh0YXJnZXQsIGtleSwgaG9tZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gd3JhcE1ldGhvZChob21lLCBrZXksIHRoaXMudmFsdWUpO1xuICAgICAgICBzdXBlci5kZWZpbmUodGFyZ2V0LCBrZXksIGhvbWUpO1xuICAgIH1cbn1cbmNsYXNzIE1ldGhvZEJsdWVwcmludCBleHRlbmRzIERhdGFCbHVlcHJpbnQge1xuICAgIGRlc2NyaXB0b3IodGFyZ2V0LCBrZXksIGNsYXNzTWV0YSkge1xuICAgICAgICBsZXQgZGVzYyA9IHN1cGVyLmRlc2NyaXB0b3IodGFyZ2V0LCBrZXksIGNsYXNzTWV0YSk7XG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kRGVzY3JpcHRvcihkZXNjKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcE1ldGhvZChob21lLCBtZXRob2ROYW1lLCBvcmlnaW5hbCkge1xuICAgIGlmICghKG1ldGhvZE5hbWUgaW4gaG9tZSkpIHJldHVybiBtYXliZVdyYXAob3JpZ2luYWwpO1xuICAgIGxldCBzdXBlck1ldGhvZCA9IGhvbWVbbWV0aG9kTmFtZV07XG4gICAgbGV0IGZ1bmMgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMpIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbGV0IGxhc3RTdXBlciA9IHRoaXMuX3N1cGVyO1xuICAgICAgICB0aGlzLl9zdXBlciA9IHN1cGVyTWV0aG9kO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fc3VwZXIgPSBsYXN0U3VwZXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmMuX193cmFwcGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZnVuYztcbn1cbmZ1bmN0aW9uIG1heWJlV3JhcChvcmlnaW5hbCkge1xuICAgIGlmICgnX193cmFwcGVkJyBpbiBvcmlnaW5hbCkgcmV0dXJuIG9yaWdpbmFsO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICBpZiAoIXRoaXMpIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbGV0IGxhc3RTdXBlciA9IHRoaXMuX3N1cGVyO1xuICAgICAgICB0aGlzLl9zdXBlciA9IFJPT1Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9zdXBlciA9IGxhc3RTdXBlcjtcbiAgICAgICAgfVxuICAgIH07XG59Il19