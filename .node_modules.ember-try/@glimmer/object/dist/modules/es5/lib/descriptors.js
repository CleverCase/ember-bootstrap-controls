function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

import { Blueprint, Descriptor } from './mixin';
import { ComputedBlueprint } from './computed';

var AliasMethodDescriptor = function (_Descriptor) {
    _inherits(AliasMethodDescriptor, _Descriptor);

    function AliasMethodDescriptor(name) {
        _classCallCheck(this, AliasMethodDescriptor);

        var _this = _possibleConstructorReturn(this, _Descriptor.call(this));

        _this.name = name;
        return _this;
    }

    AliasMethodDescriptor.prototype.define = function define(target, key, _home) {
        var name = this.name;
        Object.defineProperty(target, key, {
            enumerable: true,
            configurable: true,
            get: function () {
                return this[name];
            }
        });
    };

    return AliasMethodDescriptor;
}(Descriptor);

var AliasMethodBlueprint = function (_Blueprint) {
    _inherits(AliasMethodBlueprint, _Blueprint);

    function AliasMethodBlueprint(name) {
        _classCallCheck(this, AliasMethodBlueprint);

        var _this2 = _possibleConstructorReturn(this, _Blueprint.call(this));

        _this2.name = name;
        return _this2;
    }

    AliasMethodBlueprint.prototype.descriptor = function descriptor(_target, _key, _meta) {
        return new AliasMethodDescriptor(this.name);
    };

    return AliasMethodBlueprint;
}(Blueprint);

export function aliasMethod(name) {
    return new AliasMethodBlueprint(name);
}

var AliasBlueprint = function (_ComputedBlueprint) {
    _inherits(AliasBlueprint, _ComputedBlueprint);

    function AliasBlueprint(name) {
        _classCallCheck(this, AliasBlueprint);

        var parent = name.slice(0, -1);
        var last = name[name.length - 1];
        var get = function () {
            return name.reduce(function (obj, n) {
                return obj[n];
            }, this);
        };
        var set = function (value) {
            var p = parent.reduce(function (obj, n) {
                return obj[n];
            }, this);
            p[last] = value;
        };

        var _this3 = _possibleConstructorReturn(this, _ComputedBlueprint.call(this, { get: get, set: set }, [name]));

        _this3.name = name;
        return _this3;
    }

    AliasBlueprint.prototype.descriptor = function descriptor(target, key, meta) {
        if (this.name[0] === key) throw new Error('Setting alias \'' + key + '\' on self');
        return _ComputedBlueprint.prototype.descriptor.call(this, target, key, meta);
    };

    return AliasBlueprint;
}(ComputedBlueprint);

export function alias(name) {
    return new AliasBlueprint(name.split('.'));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kZXNjcmlwdG9ycy5qcyJdLCJuYW1lcyI6WyJCbHVlcHJpbnQiLCJEZXNjcmlwdG9yIiwiQ29tcHV0ZWRCbHVlcHJpbnQiLCJBbGlhc01ldGhvZERlc2NyaXB0b3IiLCJuYW1lIiwiZGVmaW5lIiwidGFyZ2V0Iiwia2V5IiwiX2hvbWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJBbGlhc01ldGhvZEJsdWVwcmludCIsImRlc2NyaXB0b3IiLCJfdGFyZ2V0IiwiX2tleSIsIl9tZXRhIiwiYWxpYXNNZXRob2QiLCJBbGlhc0JsdWVwcmludCIsInBhcmVudCIsInNsaWNlIiwibGFzdCIsImxlbmd0aCIsInJlZHVjZSIsIm9iaiIsIm4iLCJzZXQiLCJ2YWx1ZSIsInAiLCJtZXRhIiwiRXJyb3IiLCJhbGlhcyIsInNwbGl0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLFNBQVNBLFNBQVQsRUFBb0JDLFVBQXBCLFFBQXNDLFNBQXRDO0FBQ0EsU0FBU0MsaUJBQVQsUUFBa0MsWUFBbEM7O0lBQ01DLHFCOzs7QUFDRixtQ0FBWUMsSUFBWixFQUFrQjtBQUFBOztBQUFBLHFEQUNkLHNCQURjOztBQUVkLGNBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUZjO0FBR2pCOztvQ0FDREMsTSxtQkFBT0MsTSxFQUFRQyxHLEVBQUtDLEssRUFBTztBQUN2QixZQUFJSixPQUFPLEtBQUtBLElBQWhCO0FBQ0FLLGVBQU9DLGNBQVAsQ0FBc0JKLE1BQXRCLEVBQThCQyxHQUE5QixFQUFtQztBQUMvQkksd0JBQVksSUFEbUI7QUFFL0JDLDBCQUFjLElBRmlCO0FBRy9CQyxlQUgrQixjQUd6QjtBQUNGLHVCQUFPLEtBQUtULElBQUwsQ0FBUDtBQUNIO0FBTDhCLFNBQW5DO0FBT0gsSzs7O0VBZCtCSCxVOztJQWdCOUJhLG9COzs7QUFDRixrQ0FBWVYsSUFBWixFQUFrQjtBQUFBOztBQUFBLHNEQUNkLHFCQURjOztBQUVkLGVBQUtBLElBQUwsR0FBWUEsSUFBWjtBQUZjO0FBR2pCOzttQ0FDRFcsVSx1QkFBV0MsTyxFQUFTQyxJLEVBQU1DLEssRUFBTztBQUM3QixlQUFPLElBQUlmLHFCQUFKLENBQTBCLEtBQUtDLElBQS9CLENBQVA7QUFDSCxLOzs7RUFQOEJKLFM7O0FBU25DLE9BQU8sU0FBU21CLFdBQVQsQ0FBcUJmLElBQXJCLEVBQTJCO0FBQzlCLFdBQU8sSUFBSVUsb0JBQUosQ0FBeUJWLElBQXpCLENBQVA7QUFDSDs7SUFDS2dCLGM7OztBQUNGLDRCQUFZaEIsSUFBWixFQUFrQjtBQUFBOztBQUNkLFlBQUlpQixTQUFTakIsS0FBS2tCLEtBQUwsQ0FBVyxDQUFYLEVBQWMsQ0FBQyxDQUFmLENBQWI7QUFDQSxZQUFJQyxPQUFPbkIsS0FBS0EsS0FBS29CLE1BQUwsR0FBYyxDQUFuQixDQUFYO0FBQ0EsWUFBSVgsTUFBTSxZQUFZO0FBQ2xCLG1CQUFPVCxLQUFLcUIsTUFBTCxDQUFZLFVBQUNDLEdBQUQsRUFBTUMsQ0FBTjtBQUFBLHVCQUFZRCxJQUFJQyxDQUFKLENBQVo7QUFBQSxhQUFaLEVBQWdDLElBQWhDLENBQVA7QUFDSCxTQUZEO0FBR0EsWUFBSUMsTUFBTSxVQUFVQyxLQUFWLEVBQWlCO0FBQ3ZCLGdCQUFJQyxJQUFJVCxPQUFPSSxNQUFQLENBQWMsVUFBQ0MsR0FBRCxFQUFNQyxDQUFOO0FBQUEsdUJBQVlELElBQUlDLENBQUosQ0FBWjtBQUFBLGFBQWQsRUFBa0MsSUFBbEMsQ0FBUjtBQUNBRyxjQUFFUCxJQUFGLElBQVVNLEtBQVY7QUFDSCxTQUhEOztBQU5jLHNEQVVkLDhCQUFNLEVBQUVoQixRQUFGLEVBQU9lLFFBQVAsRUFBTixFQUFvQixDQUFDeEIsSUFBRCxDQUFwQixDQVZjOztBQVdkLGVBQUtBLElBQUwsR0FBWUEsSUFBWjtBQVhjO0FBWWpCOzs2QkFDRFcsVSx1QkFBV1QsTSxFQUFRQyxHLEVBQUt3QixJLEVBQU07QUFDMUIsWUFBSSxLQUFLM0IsSUFBTCxDQUFVLENBQVYsTUFBaUJHLEdBQXJCLEVBQTBCLE1BQU0sSUFBSXlCLEtBQUosc0JBQTRCekIsR0FBNUIsZ0JBQU47QUFDMUIsZUFBTyw2QkFBTVEsVUFBTixZQUFpQlQsTUFBakIsRUFBeUJDLEdBQXpCLEVBQThCd0IsSUFBOUIsQ0FBUDtBQUNILEs7OztFQWpCd0I3QixpQjs7QUFtQjdCLE9BQU8sU0FBUytCLEtBQVQsQ0FBZTdCLElBQWYsRUFBcUI7QUFDeEIsV0FBTyxJQUFJZ0IsY0FBSixDQUFtQmhCLEtBQUs4QixLQUFMLENBQVcsR0FBWCxDQUFuQixDQUFQO0FBQ0giLCJmaWxlIjoibGliL2Rlc2NyaXB0b3JzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmx1ZXByaW50LCBEZXNjcmlwdG9yIH0gZnJvbSAnLi9taXhpbic7XG5pbXBvcnQgeyBDb21wdXRlZEJsdWVwcmludCB9IGZyb20gJy4vY29tcHV0ZWQnO1xuY2xhc3MgQWxpYXNNZXRob2REZXNjcmlwdG9yIGV4dGVuZHMgRGVzY3JpcHRvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBkZWZpbmUodGFyZ2V0LCBrZXksIF9ob21lKSB7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEFsaWFzTWV0aG9kQmx1ZXByaW50IGV4dGVuZHMgQmx1ZXByaW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIGRlc2NyaXB0b3IoX3RhcmdldCwgX2tleSwgX21ldGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbGlhc01ldGhvZERlc2NyaXB0b3IodGhpcy5uYW1lKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWxpYXNNZXRob2QobmFtZSkge1xuICAgIHJldHVybiBuZXcgQWxpYXNNZXRob2RCbHVlcHJpbnQobmFtZSk7XG59XG5jbGFzcyBBbGlhc0JsdWVwcmludCBleHRlbmRzIENvbXB1dGVkQmx1ZXByaW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBuYW1lLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgbGV0IGxhc3QgPSBuYW1lW25hbWUubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBnZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZS5yZWR1Y2UoKG9iaiwgbikgPT4gb2JqW25dLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IHAgPSBwYXJlbnQucmVkdWNlKChvYmosIG4pID0+IG9ialtuXSwgdGhpcyk7XG4gICAgICAgICAgICBwW2xhc3RdID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKHsgZ2V0LCBzZXQgfSwgW25hbWVdKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgZGVzY3JpcHRvcih0YXJnZXQsIGtleSwgbWV0YSkge1xuICAgICAgICBpZiAodGhpcy5uYW1lWzBdID09PSBrZXkpIHRocm93IG5ldyBFcnJvcihgU2V0dGluZyBhbGlhcyAnJHtrZXl9JyBvbiBzZWxmYCk7XG4gICAgICAgIHJldHVybiBzdXBlci5kZXNjcmlwdG9yKHRhcmdldCwga2V5LCBtZXRhKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWxpYXMobmFtZSkge1xuICAgIHJldHVybiBuZXcgQWxpYXNCbHVlcHJpbnQobmFtZS5zcGxpdCgnLicpKTtcbn0iXX0=