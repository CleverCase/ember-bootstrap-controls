import { Meta, InnerReferenceFactory } from '@glimmer/object-reference';
import { Dict } from '@glimmer/util';
import { Mixin } from './mixin';
import { ROOT } from './utils';
import { Option } from "@glimmer/interfaces";
export declare const EMPTY_CACHE: () => void;
export interface ObjectWithMixins {
    "df8be4c8-4e89-44e2-a8f9-550c8dacdca7": ClassMeta;
    _meta: Meta;
}
export interface InstanceWithMixins {
    constructor: ObjectWithMixins;
}
export interface GlimmerObjectFactory<T> {
    new <U>(attrs?: U): T & U;
    extend(): GlimmerObjectFactory<Object>;
    extend<T>(extension: T): GlimmerObjectFactory<T>;
    extend(...extensions: Object[]): GlimmerObjectFactory<Object>;
    create<U>(attrs?: U): GlimmerObject & T & U;
    reopen<U>(extensions: U): void;
    reopenClass<U>(extensions: U): void;
    metaForProperty(property: string): Object;
    eachComputedProperty(callback: (s: string, o: Object) => void): void;
    "df8be4c8-4e89-44e2-a8f9-550c8dacdca7": InstanceMeta;
}
export declare function turbocharge<T>(obj: T): T;
export declare class ClassMeta {
    private referenceTypes;
    private propertyMetadata;
    private concatenatedProperties;
    private hasConcatenatedProperties;
    private mergedProperties;
    private hasMergedProperties;
    private mixins;
    private appliedMixins;
    private staticMixins;
    private subclasses;
    private slots;
    InstanceMetaConstructor: Option<typeof Meta>;
    static fromParent(parent: Option<ClassMeta>): ClassMeta;
    static for(object: ObjectWithMixins | InstanceWithMixins): Option<ClassMeta>;
    init(object: GlimmerObject, attrs: Option<Object>): void;
    addStaticMixin(mixin: Mixin): void;
    addMixin(mixin: Mixin): void;
    getStaticMixins(): Mixin[];
    getMixins(): Mixin[];
    addAppliedMixin(mixin: Mixin): void;
    hasAppliedMixin(mixin: Mixin): boolean;
    getAppliedMixins(): Mixin[];
    hasStaticMixin(mixin: Mixin): boolean;
    static applyAllMixins(Subclass: GlimmerObjectFactory<any>, Parent: GlimmerObjectFactory<any>): void;
    addSubclass(constructor: GlimmerObjectFactory<any>): void;
    getSubclasses(): Function[];
    addPropertyMetadata(property: string, value: any): void;
    metadataForProperty(property: string): Object;
    addReferenceTypeFor(property: string, type: InnerReferenceFactory<any>): void;
    addSlotFor(property: string): void;
    hasConcatenatedProperty(property: string): boolean;
    getConcatenatedProperty(property: string): any[];
    getConcatenatedProperties(): string[];
    addConcatenatedProperty(property: string, value: any): void;
    hasMergedProperty(property: string): boolean;
    getMergedProperty(property: string): Object;
    getMergedProperties(): string[];
    addMergedProperty(property: string, value: Object): void;
    getReferenceTypes(): Dict<InnerReferenceFactory<any>>;
    getPropertyMetadata(): Dict<any>;
    reset(parent: Option<ClassMeta>): void;
    reseal(obj: Object): void;
    seal(): void;
}
export declare class InstanceMeta extends ClassMeta {
    "df8be4c8-4e89-44e2-a8f9-550c8dacdca7": ClassMeta;
    static fromParent(parent: Option<InstanceMeta>): InstanceMeta;
    reset(parent: InstanceMeta): void;
    seal(): void;
}
export default class GlimmerObject {
    static "df8be4c8-4e89-44e2-a8f9-550c8dacdca7": InstanceMeta;
    static isClass: boolean;
    static extend(): typeof GlimmerObject;
    static extend<T>(extension: T): typeof GlimmerObject;
    static extend(...extensions: Object[]): typeof GlimmerObject;
    static create(attrs?: Object | null): GlimmerObject;
    static reopen<U>(extensions: U): void;
    static reopenClass(extensions: Object): void;
    static metaForProperty(property: string): Object;
    static eachComputedProperty(callback: (s: string, o: Object) => void): void;
    _super: typeof ROOT;
    _meta: any;
    _guid: number;
    init(): void;
    constructor(attrs?: Object | null);
    get(key: string): any;
    set(key: string, value: any): void;
    setProperties(attrs: Object): void;
    destroy(): void;
}
