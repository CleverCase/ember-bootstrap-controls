function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

import b, { SYNTHETIC } from "../builders";
import { appendChild, parseElementBlockParams } from "../utils";
import { HandlebarsNodeVisitors } from './handlebars-node-visitors';
import SyntaxError from '../errors/syntax-error';
import builders from "../builders";
import traverse from "../traversal/traverse";
import print from "../generation/print";
import Walker from "../traversal/walker";
import * as handlebars from "handlebars";
import { assign } from '@glimmer/util';
var voidMap = Object.create(null);
var voidTagNames = "area base br col command embed hr img input keygen link meta param source track wbr";
voidTagNames.split(" ").forEach(function (tagName) {
    voidMap[tagName] = true;
});
export var TokenizerEventHandlers = function (_HandlebarsNodeVisito) {
    _inherits(TokenizerEventHandlers, _HandlebarsNodeVisito);

    function TokenizerEventHandlers() {
        _classCallCheck(this, TokenizerEventHandlers);

        var _this = _possibleConstructorReturn(this, _HandlebarsNodeVisito.apply(this, arguments));

        _this.tagOpenLine = 0;
        _this.tagOpenColumn = 0;
        return _this;
    }

    TokenizerEventHandlers.prototype.reset = function reset() {
        this.currentNode = null;
    };
    // Comment


    TokenizerEventHandlers.prototype.beginComment = function beginComment() {
        this.currentNode = b.comment("");
        this.currentNode.loc = {
            source: null,
            start: b.pos(this.tagOpenLine, this.tagOpenColumn),
            end: null
        };
    };

    TokenizerEventHandlers.prototype.appendToCommentData = function appendToCommentData(char) {
        this.currentComment.value += char;
    };

    TokenizerEventHandlers.prototype.finishComment = function finishComment() {
        this.currentComment.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);
        appendChild(this.currentElement(), this.currentComment);
    };
    // Data


    TokenizerEventHandlers.prototype.beginData = function beginData() {
        this.currentNode = b.text();
        this.currentNode.loc = {
            source: null,
            start: b.pos(this.tokenizer.line, this.tokenizer.column),
            end: null
        };
    };

    TokenizerEventHandlers.prototype.appendToData = function appendToData(char) {
        this.currentData.chars += char;
    };

    TokenizerEventHandlers.prototype.finishData = function finishData() {
        this.currentData.loc.end = b.pos(this.tokenizer.line, this.tokenizer.column);
        appendChild(this.currentElement(), this.currentData);
    };
    // Tags - basic


    TokenizerEventHandlers.prototype.tagOpen = function tagOpen() {
        this.tagOpenLine = this.tokenizer.line;
        this.tagOpenColumn = this.tokenizer.column;
    };

    TokenizerEventHandlers.prototype.beginStartTag = function beginStartTag() {
        this.currentNode = {
            type: 'StartTag',
            name: "",
            attributes: [],
            modifiers: [],
            comments: [],
            selfClosing: false,
            loc: SYNTHETIC
        };
    };

    TokenizerEventHandlers.prototype.beginEndTag = function beginEndTag() {
        this.currentNode = {
            type: 'EndTag',
            name: "",
            attributes: [],
            modifiers: [],
            comments: [],
            selfClosing: false,
            loc: SYNTHETIC
        };
    };

    TokenizerEventHandlers.prototype.finishTag = function finishTag() {
        var _tokenizer = this.tokenizer,
            line = _tokenizer.line,
            column = _tokenizer.column;

        var tag = this.currentTag;
        tag.loc = b.loc(this.tagOpenLine, this.tagOpenColumn, line, column);
        if (tag.type === 'StartTag') {
            this.finishStartTag();
            if (voidMap[tag.name] || tag.selfClosing) {
                this.finishEndTag(true);
            }
        } else if (tag.type === 'EndTag') {
            this.finishEndTag(false);
        }
    };

    TokenizerEventHandlers.prototype.finishStartTag = function finishStartTag() {
        var _currentStartTag = this.currentStartTag,
            name = _currentStartTag.name,
            attributes = _currentStartTag.attributes,
            modifiers = _currentStartTag.modifiers,
            comments = _currentStartTag.comments;

        var loc = b.loc(this.tagOpenLine, this.tagOpenColumn);
        var element = b.element(name, attributes, modifiers, [], comments, loc);
        this.elementStack.push(element);
    };

    TokenizerEventHandlers.prototype.finishEndTag = function finishEndTag(isVoid) {
        var tag = this.currentTag;
        var element = this.elementStack.pop();
        var parent = this.currentElement();
        validateEndTag(tag, element, isVoid);
        element.loc.end.line = this.tokenizer.line;
        element.loc.end.column = this.tokenizer.column;
        parseElementBlockParams(element);
        appendChild(parent, element);
    };

    TokenizerEventHandlers.prototype.markTagAsSelfClosing = function markTagAsSelfClosing() {
        this.currentTag.selfClosing = true;
    };
    // Tags - name


    TokenizerEventHandlers.prototype.appendToTagName = function appendToTagName(char) {
        this.currentTag.name += char;
    };
    // Tags - attributes


    TokenizerEventHandlers.prototype.beginAttribute = function beginAttribute() {
        var tag = this.currentTag;
        if (tag.type === 'EndTag') {
            throw new SyntaxError("Invalid end tag: closing tag must not have attributes, " + ("in `" + tag.name + "` (on line " + this.tokenizer.line + ")."), tag.loc);
        }
        this.currentAttribute = {
            name: "",
            parts: [],
            isQuoted: false,
            isDynamic: false,
            start: b.pos(this.tokenizer.line, this.tokenizer.column),
            valueStartLine: 0,
            valueStartColumn: 0
        };
    };

    TokenizerEventHandlers.prototype.appendToAttributeName = function appendToAttributeName(char) {
        this.currentAttr.name += char;
    };

    TokenizerEventHandlers.prototype.beginAttributeValue = function beginAttributeValue(isQuoted) {
        this.currentAttr.isQuoted = isQuoted;
        this.currentAttr.valueStartLine = this.tokenizer.line;
        this.currentAttr.valueStartColumn = this.tokenizer.column;
    };

    TokenizerEventHandlers.prototype.appendToAttributeValue = function appendToAttributeValue(char) {
        var parts = this.currentAttr.parts;
        var lastPart = parts[parts.length - 1];
        if (lastPart && lastPart.type === 'TextNode') {
            lastPart.chars += char;
            // update end location for each added char
            lastPart.loc.end.line = this.tokenizer.line;
            lastPart.loc.end.column = this.tokenizer.column;
        } else {
            // initially assume the text node is a single char
            var loc = b.loc(this.tokenizer.line, this.tokenizer.column, this.tokenizer.line, this.tokenizer.column);
            // correct for `\n` as first char
            if (char === '\n') {
                loc.start.line -= 1;
                loc.start.column = lastPart ? lastPart.loc.end.column : this.currentAttr.valueStartColumn;
            }
            var text = b.text(char, loc);
            parts.push(text);
        }
    };

    TokenizerEventHandlers.prototype.finishAttributeValue = function finishAttributeValue() {
        var _currentAttr = this.currentAttr,
            name = _currentAttr.name,
            parts = _currentAttr.parts,
            isQuoted = _currentAttr.isQuoted,
            isDynamic = _currentAttr.isDynamic,
            valueStartLine = _currentAttr.valueStartLine,
            valueStartColumn = _currentAttr.valueStartColumn;

        var value = assembleAttributeValue(parts, isQuoted, isDynamic, this.tokenizer.line);
        value.loc = b.loc(valueStartLine, valueStartColumn, this.tokenizer.line, this.tokenizer.column);
        var loc = b.loc(this.currentAttr.start.line, this.currentAttr.start.column, this.tokenizer.line, this.tokenizer.column);
        var attribute = b.attr(name, value, loc);
        this.currentStartTag.attributes.push(attribute);
    };

    TokenizerEventHandlers.prototype.reportSyntaxError = function reportSyntaxError(message) {
        throw new SyntaxError("Syntax error at line " + this.tokenizer.line + " col " + this.tokenizer.column + ": " + message, b.loc(this.tokenizer.line, this.tokenizer.column));
    };

    return TokenizerEventHandlers;
}(HandlebarsNodeVisitors);
;
function assembleAttributeValue(parts, isQuoted, isDynamic, line) {
    if (isDynamic) {
        if (isQuoted) {
            return assembleConcatenatedValue(parts);
        } else {
            if (parts.length === 1 || parts.length === 2 && parts[1].type === 'TextNode' && parts[1].chars === '/') {
                return parts[0];
            } else {
                throw new SyntaxError("An unquoted attribute value must be a string or a mustache, " + "preceeded by whitespace or a '=' character, and " + ("followed by whitespace, a '>' character, or '/>' (on line " + line + ")"), b.loc(line, 0));
            }
        }
    } else {
        return parts.length > 0 ? parts[0] : b.text("");
    }
}
function assembleConcatenatedValue(parts) {
    for (var i = 0; i < parts.length; i++) {
        var part = parts[i];
        if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {
            throw new SyntaxError("Unsupported node in quoted attribute value: " + part['type'], part.loc);
        }
    }
    return b.concat(parts);
}
function validateEndTag(tag, element, selfClosing) {
    var error = void 0;
    if (voidMap[tag.name] && !selfClosing) {
        // EngTag is also called by StartTag for void and self-closing tags (i.e.
        // <input> or <br />, so we need to check for that here. Otherwise, we would
        // throw an error for those cases.
        error = "Invalid end tag " + formatEndTagInfo(tag) + " (void elements cannot have end tags).";
    } else if (element.tag === undefined) {
        error = "Closing tag " + formatEndTagInfo(tag) + " without an open tag.";
    } else if (element.tag !== tag.name) {
        error = "Closing tag " + formatEndTagInfo(tag) + " did not match last open tag `" + element.tag + "` (on line " + element.loc.start.line + ").";
    }
    if (error) {
        throw new SyntaxError(error, element.loc);
    }
}
function formatEndTagInfo(tag) {
    return "`" + tag.name + "` (on line " + tag.loc.end.line + ")";
}
export var syntax = {
    parse: preprocess,
    builders: builders,
    print: print,
    traverse: traverse,
    Walker: Walker
};
export function preprocess(html, options) {
    var ast = typeof html === 'object' ? html : handlebars.parse(html);
    var program = new TokenizerEventHandlers(html, options).acceptNode(ast);
    if (options && options.plugins && options.plugins.ast) {
        for (var i = 0, l = options.plugins.ast.length; i < l; i++) {
            var transform = options.plugins.ast[i];
            var env = assign({}, options, { syntax: syntax }, { plugins: undefined });
            var pluginResult = transform(env);
            traverse(program, pluginResult.visitors);
        }
    }
    return program;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9wYXJzZXIvdG9rZW5pemVyLWV2ZW50LWhhbmRsZXJzLmpzIl0sIm5hbWVzIjpbImIiLCJTWU5USEVUSUMiLCJhcHBlbmRDaGlsZCIsInBhcnNlRWxlbWVudEJsb2NrUGFyYW1zIiwiSGFuZGxlYmFyc05vZGVWaXNpdG9ycyIsIlN5bnRheEVycm9yIiwiYnVpbGRlcnMiLCJ0cmF2ZXJzZSIsInByaW50IiwiV2Fsa2VyIiwiaGFuZGxlYmFycyIsImFzc2lnbiIsInZvaWRNYXAiLCJPYmplY3QiLCJjcmVhdGUiLCJ2b2lkVGFnTmFtZXMiLCJzcGxpdCIsImZvckVhY2giLCJ0YWdOYW1lIiwiVG9rZW5pemVyRXZlbnRIYW5kbGVycyIsImFyZ3VtZW50cyIsInRhZ09wZW5MaW5lIiwidGFnT3BlbkNvbHVtbiIsInJlc2V0IiwiY3VycmVudE5vZGUiLCJiZWdpbkNvbW1lbnQiLCJjb21tZW50IiwibG9jIiwic291cmNlIiwic3RhcnQiLCJwb3MiLCJlbmQiLCJhcHBlbmRUb0NvbW1lbnREYXRhIiwiY2hhciIsImN1cnJlbnRDb21tZW50IiwidmFsdWUiLCJmaW5pc2hDb21tZW50IiwidG9rZW5pemVyIiwibGluZSIsImNvbHVtbiIsImN1cnJlbnRFbGVtZW50IiwiYmVnaW5EYXRhIiwidGV4dCIsImFwcGVuZFRvRGF0YSIsImN1cnJlbnREYXRhIiwiY2hhcnMiLCJmaW5pc2hEYXRhIiwidGFnT3BlbiIsImJlZ2luU3RhcnRUYWciLCJ0eXBlIiwibmFtZSIsImF0dHJpYnV0ZXMiLCJtb2RpZmllcnMiLCJjb21tZW50cyIsInNlbGZDbG9zaW5nIiwiYmVnaW5FbmRUYWciLCJmaW5pc2hUYWciLCJ0YWciLCJjdXJyZW50VGFnIiwiZmluaXNoU3RhcnRUYWciLCJmaW5pc2hFbmRUYWciLCJjdXJyZW50U3RhcnRUYWciLCJlbGVtZW50IiwiZWxlbWVudFN0YWNrIiwicHVzaCIsImlzVm9pZCIsInBvcCIsInBhcmVudCIsInZhbGlkYXRlRW5kVGFnIiwibWFya1RhZ0FzU2VsZkNsb3NpbmciLCJhcHBlbmRUb1RhZ05hbWUiLCJiZWdpbkF0dHJpYnV0ZSIsImN1cnJlbnRBdHRyaWJ1dGUiLCJwYXJ0cyIsImlzUXVvdGVkIiwiaXNEeW5hbWljIiwidmFsdWVTdGFydExpbmUiLCJ2YWx1ZVN0YXJ0Q29sdW1uIiwiYXBwZW5kVG9BdHRyaWJ1dGVOYW1lIiwiY3VycmVudEF0dHIiLCJiZWdpbkF0dHJpYnV0ZVZhbHVlIiwiYXBwZW5kVG9BdHRyaWJ1dGVWYWx1ZSIsImxhc3RQYXJ0IiwibGVuZ3RoIiwiZmluaXNoQXR0cmlidXRlVmFsdWUiLCJhc3NlbWJsZUF0dHJpYnV0ZVZhbHVlIiwiYXR0cmlidXRlIiwiYXR0ciIsInJlcG9ydFN5bnRheEVycm9yIiwibWVzc2FnZSIsImFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUiLCJpIiwicGFydCIsImNvbmNhdCIsImVycm9yIiwiZm9ybWF0RW5kVGFnSW5mbyIsInVuZGVmaW5lZCIsInN5bnRheCIsInBhcnNlIiwicHJlcHJvY2VzcyIsImh0bWwiLCJvcHRpb25zIiwiYXN0IiwicHJvZ3JhbSIsImFjY2VwdE5vZGUiLCJwbHVnaW5zIiwibCIsInRyYW5zZm9ybSIsImVudiIsInBsdWdpblJlc3VsdCIsInZpc2l0b3JzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLE9BQU9BLENBQVAsSUFBWUMsU0FBWixRQUE2QixhQUE3QjtBQUNBLFNBQVNDLFdBQVQsRUFBc0JDLHVCQUF0QixRQUFxRCxVQUFyRDtBQUNBLFNBQVNDLHNCQUFULFFBQXVDLDRCQUF2QztBQUNBLE9BQU9DLFdBQVAsTUFBd0Isd0JBQXhCO0FBQ0EsT0FBT0MsUUFBUCxNQUFxQixhQUFyQjtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsdUJBQXJCO0FBQ0EsT0FBT0MsS0FBUCxNQUFrQixxQkFBbEI7QUFDQSxPQUFPQyxNQUFQLE1BQW1CLHFCQUFuQjtBQUNBLE9BQU8sS0FBS0MsVUFBWixNQUE0QixZQUE1QjtBQUNBLFNBQVNDLE1BQVQsUUFBdUIsZUFBdkI7QUFD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RyxVQUFVLElBQUlwRixzQkFBSixDQUEyQmlGLElBQTNCLEVBQWlDQyxPQUFqQyxFQUEwQ0csVUFBMUMsQ0FBcURGLEdBQXJELENBQWQ7QUFDQSxRQUFJRCxXQUFXQSxRQUFRSSxPQUFuQixJQUE4QkosUUFBUUksT0FBUixDQUFnQkgsR0FBbEQsRUFBdUQ7QUFDbkQsYUFBSyxJQUFJWCxJQUFJLENBQVIsRUFBV2UsSUFBSUwsUUFBUUksT0FBUixDQUFnQkgsR0FBaEIsQ0FBb0JuQixNQUF4QyxFQUFnRFEsSUFBSWUsQ0FBcEQsRUFBdURmLEdBQXZELEVBQTREO0FBQ3hELGdCQUFJZ0IsWUFBWU4sUUFBUUksT0FBUixDQUFnQkgsR0FBaEIsQ0FBb0JYLENBQXBCLENBQWhCO0FBQ0EsZ0JBQUlpQixNQUFNakcsT0FBTyxFQUFQLEVBQVcwRixPQUFYLEVBQW9CLEVBQUVKLGNBQUYsRUFBcEIsRUFBZ0MsRUFBRVEsU0FBU1QsU0FBWCxFQUFoQyxDQUFWO0FBQ0EsZ0JBQUlhLGVBQWVGLFVBQVVDLEdBQVYsQ0FBbkI7QUFDQXJHLHFCQUFTZ0csT0FBVCxFQUFrQk0sYUFBYUMsUUFBL0I7QUFDSDtBQUNKO0FBQ0QsV0FBT1AsT0FBUDtBQUNIIiwiZmlsZSI6ImxpYi9wYXJzZXIvdG9rZW5pemVyLWV2ZW50LWhhbmRsZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGIsIHsgU1lOVEhFVElDIH0gZnJvbSBcIi4uL2J1aWxkZXJzXCI7XG5pbXBvcnQgeyBhcHBlbmRDaGlsZCwgcGFyc2VFbGVtZW50QmxvY2tQYXJhbXMgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCB7IEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMgfSBmcm9tICcuL2hhbmRsZWJhcnMtbm9kZS12aXNpdG9ycyc7XG5pbXBvcnQgU3ludGF4RXJyb3IgZnJvbSAnLi4vZXJyb3JzL3N5bnRheC1lcnJvcic7XG5pbXBvcnQgYnVpbGRlcnMgZnJvbSBcIi4uL2J1aWxkZXJzXCI7XG5pbXBvcnQgdHJhdmVyc2UgZnJvbSBcIi4uL3RyYXZlcnNhbC90cmF2ZXJzZVwiO1xuaW1wb3J0IHByaW50IGZyb20gXCIuLi9nZW5lcmF0aW9uL3ByaW50XCI7XG5pbXBvcnQgV2Fsa2VyIGZyb20gXCIuLi90cmF2ZXJzYWwvd2Fsa2VyXCI7XG5pbXBvcnQgKiBhcyBoYW5kbGViYXJzIGZyb20gXCJoYW5kbGViYXJzXCI7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmNvbnN0IHZvaWRNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xubGV0IHZvaWRUYWdOYW1lcyA9IFwiYXJlYSBiYXNlIGJyIGNvbCBjb21tYW5kIGVtYmVkIGhyIGltZyBpbnB1dCBrZXlnZW4gbGluayBtZXRhIHBhcmFtIHNvdXJjZSB0cmFjayB3YnJcIjtcbnZvaWRUYWdOYW1lcy5zcGxpdChcIiBcIikuZm9yRWFjaCh0YWdOYW1lID0+IHtcbiAgICB2b2lkTWFwW3RhZ05hbWVdID0gdHJ1ZTtcbn0pO1xuZXhwb3J0IGNsYXNzIFRva2VuaXplckV2ZW50SGFuZGxlcnMgZXh0ZW5kcyBIYW5kbGViYXJzTm9kZVZpc2l0b3JzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50YWdPcGVuTGluZSA9IDA7XG4gICAgICAgIHRoaXMudGFnT3BlbkNvbHVtbiA9IDA7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQ29tbWVudFxuICAgIGJlZ2luQ29tbWVudCgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IGIuY29tbWVudChcIlwiKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZS5sb2MgPSB7XG4gICAgICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgICAgICBzdGFydDogYi5wb3ModGhpcy50YWdPcGVuTGluZSwgdGhpcy50YWdPcGVuQ29sdW1uKSxcbiAgICAgICAgICAgIGVuZDogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhcHBlbmRUb0NvbW1lbnREYXRhKGNoYXIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Q29tbWVudC52YWx1ZSArPSBjaGFyO1xuICAgIH1cbiAgICBmaW5pc2hDb21tZW50KCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRDb21tZW50LmxvYy5lbmQgPSBiLnBvcyh0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW4pO1xuICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIHRoaXMuY3VycmVudENvbW1lbnQpO1xuICAgIH1cbiAgICAvLyBEYXRhXG4gICAgYmVnaW5EYXRhKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gYi50ZXh0KCk7XG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUubG9jID0ge1xuICAgICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgICAgc3RhcnQ6IGIucG9zKHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtbiksXG4gICAgICAgICAgICBlbmQ6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kVG9EYXRhKGNoYXIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YS5jaGFycyArPSBjaGFyO1xuICAgIH1cbiAgICBmaW5pc2hEYXRhKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhLmxvYy5lbmQgPSBiLnBvcyh0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW4pO1xuICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIHRoaXMuY3VycmVudERhdGEpO1xuICAgIH1cbiAgICAvLyBUYWdzIC0gYmFzaWNcbiAgICB0YWdPcGVuKCkge1xuICAgICAgICB0aGlzLnRhZ09wZW5MaW5lID0gdGhpcy50b2tlbml6ZXIubGluZTtcbiAgICAgICAgdGhpcy50YWdPcGVuQ29sdW1uID0gdGhpcy50b2tlbml6ZXIuY29sdW1uO1xuICAgIH1cbiAgICBiZWdpblN0YXJ0VGFnKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0ge1xuICAgICAgICAgICAgdHlwZTogJ1N0YXJ0VGFnJyxcbiAgICAgICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgICAgICAgIG1vZGlmaWVyczogW10sXG4gICAgICAgICAgICBjb21tZW50czogW10sXG4gICAgICAgICAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgICAgICAgICBsb2M6IFNZTlRIRVRJQ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBiZWdpbkVuZFRhZygpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdFbmRUYWcnLFxuICAgICAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgICAgICAgIGNvbW1lbnRzOiBbXSxcbiAgICAgICAgICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGxvYzogU1lOVEhFVElDXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmlzaFRhZygpIHtcbiAgICAgICAgbGV0IHsgbGluZSwgY29sdW1uIH0gPSB0aGlzLnRva2VuaXplcjtcbiAgICAgICAgbGV0IHRhZyA9IHRoaXMuY3VycmVudFRhZztcbiAgICAgICAgdGFnLmxvYyA9IGIubG9jKHRoaXMudGFnT3BlbkxpbmUsIHRoaXMudGFnT3BlbkNvbHVtbiwgbGluZSwgY29sdW1uKTtcbiAgICAgICAgaWYgKHRhZy50eXBlID09PSAnU3RhcnRUYWcnKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaFN0YXJ0VGFnKCk7XG4gICAgICAgICAgICBpZiAodm9pZE1hcFt0YWcubmFtZV0gfHwgdGFnLnNlbGZDbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hFbmRUYWcodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGFnLnR5cGUgPT09ICdFbmRUYWcnKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaEVuZFRhZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoU3RhcnRUYWcoKSB7XG4gICAgICAgIGxldCB7IG5hbWUsIGF0dHJpYnV0ZXMsIG1vZGlmaWVycywgY29tbWVudHMgfSA9IHRoaXMuY3VycmVudFN0YXJ0VGFnO1xuICAgICAgICBsZXQgbG9jID0gYi5sb2ModGhpcy50YWdPcGVuTGluZSwgdGhpcy50YWdPcGVuQ29sdW1uKTtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBiLmVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgbW9kaWZpZXJzLCBbXSwgY29tbWVudHMsIGxvYyk7XG4gICAgICAgIHRoaXMuZWxlbWVudFN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIGZpbmlzaEVuZFRhZyhpc1ZvaWQpIHtcbiAgICAgICAgbGV0IHRhZyA9IHRoaXMuY3VycmVudFRhZztcbiAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKTtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuY3VycmVudEVsZW1lbnQoKTtcbiAgICAgICAgdmFsaWRhdGVFbmRUYWcodGFnLCBlbGVtZW50LCBpc1ZvaWQpO1xuICAgICAgICBlbGVtZW50LmxvYy5lbmQubGluZSA9IHRoaXMudG9rZW5pemVyLmxpbmU7XG4gICAgICAgIGVsZW1lbnQubG9jLmVuZC5jb2x1bW4gPSB0aGlzLnRva2VuaXplci5jb2x1bW47XG4gICAgICAgIHBhcnNlRWxlbWVudEJsb2NrUGFyYW1zKGVsZW1lbnQpO1xuICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBtYXJrVGFnQXNTZWxmQ2xvc2luZygpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VGFnLnNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVGFncyAtIG5hbWVcbiAgICBhcHBlbmRUb1RhZ05hbWUoY2hhcikge1xuICAgICAgICB0aGlzLmN1cnJlbnRUYWcubmFtZSArPSBjaGFyO1xuICAgIH1cbiAgICAvLyBUYWdzIC0gYXR0cmlidXRlc1xuICAgIGJlZ2luQXR0cmlidXRlKCkge1xuICAgICAgICBsZXQgdGFnID0gdGhpcy5jdXJyZW50VGFnO1xuICAgICAgICBpZiAodGFnLnR5cGUgPT09ICdFbmRUYWcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZW5kIHRhZzogY2xvc2luZyB0YWcgbXVzdCBub3QgaGF2ZSBhdHRyaWJ1dGVzLCBgICsgYGluIFxcYCR7dGFnLm5hbWV9XFxgIChvbiBsaW5lICR7dGhpcy50b2tlbml6ZXIubGluZX0pLmAsIHRhZy5sb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZSA9IHtcbiAgICAgICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgICAgICBwYXJ0czogW10sXG4gICAgICAgICAgICBpc1F1b3RlZDogZmFsc2UsXG4gICAgICAgICAgICBpc0R5bmFtaWM6IGZhbHNlLFxuICAgICAgICAgICAgc3RhcnQ6IGIucG9zKHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtbiksXG4gICAgICAgICAgICB2YWx1ZVN0YXJ0TGluZTogMCxcbiAgICAgICAgICAgIHZhbHVlU3RhcnRDb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kVG9BdHRyaWJ1dGVOYW1lKGNoYXIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0ci5uYW1lICs9IGNoYXI7XG4gICAgfVxuICAgIGJlZ2luQXR0cmlidXRlVmFsdWUoaXNRdW90ZWQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0ci5pc1F1b3RlZCA9IGlzUXVvdGVkO1xuICAgICAgICB0aGlzLmN1cnJlbnRBdHRyLnZhbHVlU3RhcnRMaW5lID0gdGhpcy50b2tlbml6ZXIubGluZTtcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0ci52YWx1ZVN0YXJ0Q29sdW1uID0gdGhpcy50b2tlbml6ZXIuY29sdW1uO1xuICAgIH1cbiAgICBhcHBlbmRUb0F0dHJpYnV0ZVZhbHVlKGNoYXIpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gdGhpcy5jdXJyZW50QXR0ci5wYXJ0cztcbiAgICAgICAgbGV0IGxhc3RQYXJ0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0UGFydCAmJiBsYXN0UGFydC50eXBlID09PSAnVGV4dE5vZGUnKSB7XG4gICAgICAgICAgICBsYXN0UGFydC5jaGFycyArPSBjaGFyO1xuICAgICAgICAgICAgLy8gdXBkYXRlIGVuZCBsb2NhdGlvbiBmb3IgZWFjaCBhZGRlZCBjaGFyXG4gICAgICAgICAgICBsYXN0UGFydC5sb2MuZW5kLmxpbmUgPSB0aGlzLnRva2VuaXplci5saW5lO1xuICAgICAgICAgICAgbGFzdFBhcnQubG9jLmVuZC5jb2x1bW4gPSB0aGlzLnRva2VuaXplci5jb2x1bW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpbml0aWFsbHkgYXNzdW1lIHRoZSB0ZXh0IG5vZGUgaXMgYSBzaW5nbGUgY2hhclxuICAgICAgICAgICAgbGV0IGxvYyA9IGIubG9jKHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtbiwgdGhpcy50b2tlbml6ZXIubGluZSwgdGhpcy50b2tlbml6ZXIuY29sdW1uKTtcbiAgICAgICAgICAgIC8vIGNvcnJlY3QgZm9yIGBcXG5gIGFzIGZpcnN0IGNoYXJcbiAgICAgICAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIGxvYy5zdGFydC5saW5lIC09IDE7XG4gICAgICAgICAgICAgICAgbG9jLnN0YXJ0LmNvbHVtbiA9IGxhc3RQYXJ0ID8gbGFzdFBhcnQubG9jLmVuZC5jb2x1bW4gOiB0aGlzLmN1cnJlbnRBdHRyLnZhbHVlU3RhcnRDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGV4dCA9IGIudGV4dChjaGFyLCBsb2MpO1xuICAgICAgICAgICAgcGFydHMucHVzaCh0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5pc2hBdHRyaWJ1dGVWYWx1ZSgpIHtcbiAgICAgICAgbGV0IHsgbmFtZSwgcGFydHMsIGlzUXVvdGVkLCBpc0R5bmFtaWMsIHZhbHVlU3RhcnRMaW5lLCB2YWx1ZVN0YXJ0Q29sdW1uIH0gPSB0aGlzLmN1cnJlbnRBdHRyO1xuICAgICAgICBsZXQgdmFsdWUgPSBhc3NlbWJsZUF0dHJpYnV0ZVZhbHVlKHBhcnRzLCBpc1F1b3RlZCwgaXNEeW5hbWljLCB0aGlzLnRva2VuaXplci5saW5lKTtcbiAgICAgICAgdmFsdWUubG9jID0gYi5sb2ModmFsdWVTdGFydExpbmUsIHZhbHVlU3RhcnRDb2x1bW4sIHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtbik7XG4gICAgICAgIGxldCBsb2MgPSBiLmxvYyh0aGlzLmN1cnJlbnRBdHRyLnN0YXJ0LmxpbmUsIHRoaXMuY3VycmVudEF0dHIuc3RhcnQuY29sdW1uLCB0aGlzLnRva2VuaXplci5saW5lLCB0aGlzLnRva2VuaXplci5jb2x1bW4pO1xuICAgICAgICBsZXQgYXR0cmlidXRlID0gYi5hdHRyKG5hbWUsIHZhbHVlLCBsb2MpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydFRhZy5hdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlKTtcbiAgICB9XG4gICAgcmVwb3J0U3ludGF4RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFN5bnRheCBlcnJvciBhdCBsaW5lICR7dGhpcy50b2tlbml6ZXIubGluZX0gY29sICR7dGhpcy50b2tlbml6ZXIuY29sdW1ufTogJHttZXNzYWdlfWAsIGIubG9jKHRoaXMudG9rZW5pemVyLmxpbmUsIHRoaXMudG9rZW5pemVyLmNvbHVtbikpO1xuICAgIH1cbn1cbjtcbmZ1bmN0aW9uIGFzc2VtYmxlQXR0cmlidXRlVmFsdWUocGFydHMsIGlzUXVvdGVkLCBpc0R5bmFtaWMsIGxpbmUpIHtcbiAgICBpZiAoaXNEeW5hbWljKSB7XG4gICAgICAgIGlmIChpc1F1b3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUocGFydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSB8fCBwYXJ0cy5sZW5ndGggPT09IDIgJiYgcGFydHNbMV0udHlwZSA9PT0gJ1RleHROb2RlJyAmJiBwYXJ0c1sxXS5jaGFycyA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgbXVzdGFjaGUsIGAgKyBgcHJlY2VlZGVkIGJ5IHdoaXRlc3BhY2Ugb3IgYSAnPScgY2hhcmFjdGVyLCBhbmQgYCArIGBmb2xsb3dlZCBieSB3aGl0ZXNwYWNlLCBhICc+JyBjaGFyYWN0ZXIsIG9yICcvPicgKG9uIGxpbmUgJHtsaW5lfSlgLCBiLmxvYyhsaW5lLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogYi50ZXh0KFwiXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUocGFydHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgIT09ICdNdXN0YWNoZVN0YXRlbWVudCcgJiYgcGFydC50eXBlICE9PSAnVGV4dE5vZGUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJVbnN1cHBvcnRlZCBub2RlIGluIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWU6IFwiICsgcGFydFsndHlwZSddLCBwYXJ0LmxvYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGIuY29uY2F0KHBhcnRzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRW5kVGFnKHRhZywgZWxlbWVudCwgc2VsZkNsb3NpbmcpIHtcbiAgICBsZXQgZXJyb3I7XG4gICAgaWYgKHZvaWRNYXBbdGFnLm5hbWVdICYmICFzZWxmQ2xvc2luZykge1xuICAgICAgICAvLyBFbmdUYWcgaXMgYWxzbyBjYWxsZWQgYnkgU3RhcnRUYWcgZm9yIHZvaWQgYW5kIHNlbGYtY2xvc2luZyB0YWdzIChpLmUuXG4gICAgICAgIC8vIDxpbnB1dD4gb3IgPGJyIC8+LCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciB0aGF0IGhlcmUuIE90aGVyd2lzZSwgd2Ugd291bGRcbiAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgZm9yIHRob3NlIGNhc2VzLlxuICAgICAgICBlcnJvciA9IFwiSW52YWxpZCBlbmQgdGFnIFwiICsgZm9ybWF0RW5kVGFnSW5mbyh0YWcpICsgXCIgKHZvaWQgZWxlbWVudHMgY2Fubm90IGhhdmUgZW5kIHRhZ3MpLlwiO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvciA9IFwiQ2xvc2luZyB0YWcgXCIgKyBmb3JtYXRFbmRUYWdJbmZvKHRhZykgKyBcIiB3aXRob3V0IGFuIG9wZW4gdGFnLlwiO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWcgIT09IHRhZy5uYW1lKSB7XG4gICAgICAgIGVycm9yID0gXCJDbG9zaW5nIHRhZyBcIiArIGZvcm1hdEVuZFRhZ0luZm8odGFnKSArIFwiIGRpZCBub3QgbWF0Y2ggbGFzdCBvcGVuIHRhZyBgXCIgKyBlbGVtZW50LnRhZyArIFwiYCAob24gbGluZSBcIiArIGVsZW1lbnQubG9jLnN0YXJ0LmxpbmUgKyBcIikuXCI7XG4gICAgfVxuICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoZXJyb3IsIGVsZW1lbnQubG9jKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmb3JtYXRFbmRUYWdJbmZvKHRhZykge1xuICAgIHJldHVybiBcImBcIiArIHRhZy5uYW1lICsgXCJgIChvbiBsaW5lIFwiICsgdGFnLmxvYy5lbmQubGluZSArIFwiKVwiO1xufVxuZXhwb3J0IGNvbnN0IHN5bnRheCA9IHtcbiAgICBwYXJzZTogcHJlcHJvY2VzcyxcbiAgICBidWlsZGVycyxcbiAgICBwcmludCxcbiAgICB0cmF2ZXJzZSxcbiAgICBXYWxrZXJcbn07XG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2VzcyhodG1sLCBvcHRpb25zKSB7XG4gICAgbGV0IGFzdCA9IHR5cGVvZiBodG1sID09PSAnb2JqZWN0JyA/IGh0bWwgOiBoYW5kbGViYXJzLnBhcnNlKGh0bWwpO1xuICAgIGxldCBwcm9ncmFtID0gbmV3IFRva2VuaXplckV2ZW50SGFuZGxlcnMoaHRtbCwgb3B0aW9ucykuYWNjZXB0Tm9kZShhc3QpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGx1Z2lucyAmJiBvcHRpb25zLnBsdWdpbnMuYXN0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3B0aW9ucy5wbHVnaW5zLmFzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB0cmFuc2Zvcm0gPSBvcHRpb25zLnBsdWdpbnMuYXN0W2ldO1xuICAgICAgICAgICAgbGV0IGVudiA9IGFzc2lnbih7fSwgb3B0aW9ucywgeyBzeW50YXggfSwgeyBwbHVnaW5zOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICBsZXQgcGx1Z2luUmVzdWx0ID0gdHJhbnNmb3JtKGVudik7XG4gICAgICAgICAgICB0cmF2ZXJzZShwcm9ncmFtLCBwbHVnaW5SZXN1bHQudmlzaXRvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9ncmFtO1xufSJdfQ==