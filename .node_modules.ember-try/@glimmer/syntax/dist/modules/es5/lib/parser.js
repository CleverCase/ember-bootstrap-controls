var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { EventedTokenizer, EntityParser, HTML5NamedCharRefs as namedCharRefs } from "simple-html-tokenizer";
import { assert } from '@glimmer/util';
var entityParser = new EntityParser(namedCharRefs);
export var Parser = function () {
    function Parser(source) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Parser);

        this.elementStack = [];
        this.currentAttribute = null;
        this.currentNode = null;
        this.tokenizer = new EventedTokenizer(this, entityParser);
        this.options = options;
        this.source = source.split(/(?:\r\n?|\n)/g);
    }

    Parser.prototype.acceptNode = function acceptNode(node) {
        return this[node.type](node);
    };

    Parser.prototype.currentElement = function currentElement() {
        return this.elementStack[this.elementStack.length - 1];
    };

    Parser.prototype.sourceForNode = function sourceForNode(node, endNode) {
        var firstLine = node.loc.start.line - 1;
        var currentLine = firstLine - 1;
        var firstColumn = node.loc.start.column;
        var string = [];
        var line = void 0;
        var lastLine = void 0;
        var lastColumn = void 0;
        if (endNode) {
            lastLine = endNode.loc.end.line - 1;
            lastColumn = endNode.loc.end.column;
        } else {
            lastLine = node.loc.end.line - 1;
            lastColumn = node.loc.end.column;
        }
        while (currentLine < lastLine) {
            currentLine++;
            line = this.source[currentLine];
            if (currentLine === firstLine) {
                if (firstLine === lastLine) {
                    string.push(line.slice(firstColumn, lastColumn));
                } else {
                    string.push(line.slice(firstColumn));
                }
            } else if (currentLine === lastLine) {
                string.push(line.slice(0, lastColumn));
            } else {
                string.push(line);
            }
        }
        return string.join('\n');
    };

    _createClass(Parser, [{
        key: 'currentAttr',
        get: function () {
            return this.currentAttribute;
        }
    }, {
        key: 'currentTag',
        get: function () {
            var node = this.currentNode;
            assert(node && (node.type === 'StartTag' || node.type === 'EndTag'), 'expected tag');
            return node;
        }
    }, {
        key: 'currentStartTag',
        get: function () {
            var node = this.currentNode;
            assert(node && node.type === 'StartTag', 'expected start tag');
            return node;
        }
    }, {
        key: 'currentEndTag',
        get: function () {
            var node = this.currentNode;
            assert(node && node.type === 'EndTag', 'expected end tag');
            return node;
        }
    }, {
        key: 'currentComment',
        get: function () {
            var node = this.currentNode;
            assert(node && node.type === 'CommentStatement', 'expected a comment');
            return node;
        }
    }, {
        key: 'currentData',
        get: function () {
            var node = this.currentNode;
            assert(node && node.type === 'TextNode', 'expected a text node');
            return node;
        }
    }]);

    return Parser;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9wYXJzZXIuanMiXSwibmFtZXMiOlsiRXZlbnRlZFRva2VuaXplciIsIkVudGl0eVBhcnNlciIsIkhUTUw1TmFtZWRDaGFyUmVmcyIsIm5hbWVkQ2hhclJlZnMiLCJhc3NlcnQiLCJlbnRpdHlQYXJzZXIiLCJQYXJzZXIiLCJzb3VyY2UiLCJvcHRpb25zIiwiZWxlbWVudFN0YWNrIiwiY3VycmVudEF0dHJpYnV0ZSIsImN1cnJlbnROb2RlIiwidG9rZW5pemVyIiwic3BsaXQiLCJhY2NlcHROb2RlIiwibm9kZSIsInR5cGUiLCJjdXJyZW50RWxlbWVudCIsImxlbmd0aCIsInNvdXJjZUZvck5vZGUiLCJlbmROb2RlIiwiZmlyc3RMaW5lIiwibG9jIiwic3RhcnQiLCJsaW5lIiwiY3VycmVudExpbmUiLCJmaXJzdENvbHVtbiIsImNvbHVtbiIsInN0cmluZyIsImxhc3RMaW5lIiwibGFzdENvbHVtbiIsImVuZCIsInB1c2giLCJzbGljZSIsImpvaW4iXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQSxnQkFBVCxFQUEyQkMsWUFBM0IsRUFBeUNDLHNCQUFzQkMsYUFBL0QsUUFBb0YsdUJBQXBGO0FBQ0EsU0FBU0MsTUFBVCxRQUErQixlQUEvQjtBQUNBLElBQU1DLGVBQWUsSUFBSUosWUFBSixDQUFpQkUsYUFBakIsQ0FBckI7QUFDQSxXQUFhRyxNQUFiO0FBQ0ksb0JBQVlDLE1BQVosRUFBa0M7QUFBQSxZQUFkQyxPQUFjLHVFQUFKLEVBQUk7O0FBQUE7O0FBQzlCLGFBQUtDLFlBQUwsR0FBb0IsRUFBcEI7QUFDQSxhQUFLQyxnQkFBTCxHQUF3QixJQUF4QjtBQUNBLGFBQUtDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxhQUFLQyxTQUFMLEdBQWlCLElBQUlaLGdCQUFKLENBQXFCLElBQXJCLEVBQTJCSyxZQUEzQixDQUFqQjtBQUNBLGFBQUtHLE9BQUwsR0FBZUEsT0FBZjtBQUNBLGFBQUtELE1BQUwsR0FBY0EsT0FBT00sS0FBUCxDQUFhLGVBQWIs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RDtBQUNBLG1CQUFPRCxJQUFQO0FBQ0g7QUEvQkw7QUFBQTtBQUFBLHlCQWdDc0I7QUFDZCxnQkFBSUEsT0FBTyxLQUFLSixXQUFoQjtBQUNBUCxtQkFBT1csUUFBUUEsS0FBS0MsSUFBTCxLQUFjLFVBQTdCLEVBQXlDLHNCQUF6QztBQUNBLG1CQUFPRCxJQUFQO0FBQ0g7QUFwQ0w7O0FBQUE7QUFBQSIsImZpbGUiOiJsaWIvcGFyc2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRlZFRva2VuaXplciwgRW50aXR5UGFyc2VyLCBIVE1MNU5hbWVkQ2hhclJlZnMgYXMgbmFtZWRDaGFyUmVmcyB9IGZyb20gXCJzaW1wbGUtaHRtbC10b2tlbml6ZXJcIjtcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5jb25zdCBlbnRpdHlQYXJzZXIgPSBuZXcgRW50aXR5UGFyc2VyKG5hbWVkQ2hhclJlZnMpO1xuZXhwb3J0IGNsYXNzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50QXR0cmlidXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gbmV3IEV2ZW50ZWRUb2tlbml6ZXIodGhpcywgZW50aXR5UGFyc2VyKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2Uuc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRBdHRyKCkge1xuICAgICAgICByZXR1cm4gZXhwZWN0KHRoaXMuY3VycmVudEF0dHJpYnV0ZSwgJ2V4cGVjdGVkIGF0dHJpYnV0ZScpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRhZygpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgICAgICBhc3NlcnQobm9kZSAmJiAobm9kZS50eXBlID09PSAnU3RhcnRUYWcnIHx8IG5vZGUudHlwZSA9PT0gJ0VuZFRhZycpLCAnZXhwZWN0ZWQgdGFnJyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFN0YXJ0VGFnKCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ1N0YXJ0VGFnJywgJ2V4cGVjdGVkIHN0YXJ0IHRhZycpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFbmRUYWcoKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICAgICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnRW5kVGFnJywgJ2V4cGVjdGVkIGVuZCB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGdldCBjdXJyZW50Q29tbWVudCgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgICAgICBhc3NlcnQobm9kZSAmJiBub2RlLnR5cGUgPT09ICdDb21tZW50U3RhdGVtZW50JywgJ2V4cGVjdGVkIGEgY29tbWVudCcpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnREYXRhKCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ1RleHROb2RlJywgJ2V4cGVjdGVkIGEgdGV4dCBub2RlJyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBhY2NlcHROb2RlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbm9kZS50eXBlXShub2RlKTtcbiAgICB9XG4gICAgY3VycmVudEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFja1t0aGlzLmVsZW1lbnRTdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgc291cmNlRm9yTm9kZShub2RlLCBlbmROb2RlKSB7XG4gICAgICAgIGxldCBmaXJzdExpbmUgPSBub2RlLmxvYy5zdGFydC5saW5lIC0gMTtcbiAgICAgICAgbGV0IGN1cnJlbnRMaW5lID0gZmlyc3RMaW5lIC0gMTtcbiAgICAgICAgbGV0IGZpcnN0Q29sdW1uID0gbm9kZS5sb2Muc3RhcnQuY29sdW1uO1xuICAgICAgICBsZXQgc3RyaW5nID0gW107XG4gICAgICAgIGxldCBsaW5lO1xuICAgICAgICBsZXQgbGFzdExpbmU7XG4gICAgICAgIGxldCBsYXN0Q29sdW1uO1xuICAgICAgICBpZiAoZW5kTm9kZSkge1xuICAgICAgICAgICAgbGFzdExpbmUgPSBlbmROb2RlLmxvYy5lbmQubGluZSAtIDE7XG4gICAgICAgICAgICBsYXN0Q29sdW1uID0gZW5kTm9kZS5sb2MuZW5kLmNvbHVtbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RMaW5lID0gbm9kZS5sb2MuZW5kLmxpbmUgLSAxO1xuICAgICAgICAgICAgbGFzdENvbHVtbiA9IG5vZGUubG9jLmVuZC5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGN1cnJlbnRMaW5lIDwgbGFzdExpbmUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lKys7XG4gICAgICAgICAgICBsaW5lID0gdGhpcy5zb3VyY2VbY3VycmVudExpbmVdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lID09PSBmaXJzdExpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RMaW5lID09PSBsYXN0TGluZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChsaW5lLnNsaWNlKGZpcnN0Q29sdW1uLCBsYXN0Q29sdW1uKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2gobGluZS5zbGljZShmaXJzdENvbHVtbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudExpbmUgPT09IGxhc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2gobGluZS5zbGljZSgwLCBsYXN0Q29sdW1uKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmcuam9pbignXFxuJyk7XG4gICAgfVxufSJdfQ==