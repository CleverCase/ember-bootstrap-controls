import * as AST from './types/nodes';
function buildMustache(path, params, hash, raw, loc) {
    if (!AST.isLiteral(path)) {
        path = buildPath(path);
    }
    return {
        type: "MustacheStatement",
        path,
        params: params || [],
        hash: hash || buildHash([]),
        escaped: !raw,
        loc: buildLoc(loc || null)
    };
}
function buildBlock(path, params, hash, program, inverse, loc) {
    return {
        type: "BlockStatement",
        path: buildPath(path),
        params: params || [],
        hash: hash || buildHash([]),
        program: program || null,
        inverse: inverse || null,
        loc: buildLoc(loc || null)
    };
}
function buildElementModifier(path, params, hash, loc) {
    return {
        type: "ElementModifierStatement",
        path: buildPath(path),
        params: params || [],
        hash: hash || buildHash([]),
        loc: buildLoc(loc || null)
    };
}
function buildPartial(name, params, hash, indent, loc) {
    return {
        type: "PartialStatement",
        name: name,
        params: params || [],
        hash: hash || buildHash([]),
        indent: indent || '',
        strip: { open: false, close: false },
        loc: buildLoc(loc || null)
    };
}
function buildComment(value, loc) {
    return {
        type: "CommentStatement",
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildMustacheComment(value, loc) {
    return {
        type: "MustacheCommentStatement",
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildConcat(parts, loc) {
    return {
        type: "ConcatStatement",
        parts: parts || [],
        loc: buildLoc(loc || null)
    };
}
function buildElement(tag, attributes, modifiers, children, comments, loc) {
    // this is used for backwards compat prior to `comments` being added to the AST
    if (!Array.isArray(comments)) {
        loc = comments;
        comments = [];
    }
    return {
        type: "ElementNode",
        tag: tag || "",
        attributes: attributes || [],
        blockParams: [],
        modifiers: modifiers || [],
        comments: comments || [],
        children: children || [],
        loc: buildLoc(loc || null)
    };
}
function buildAttr(name, value, loc) {
    return {
        type: "AttrNode",
        name: name,
        value: value,
        loc: buildLoc(loc || null)
    };
}
function buildText(chars, loc) {
    return {
        type: "TextNode",
        chars: chars || "",
        loc: buildLoc(loc || null)
    };
}
// Expressions
function buildSexpr(path, params, hash, loc) {
    return {
        type: "SubExpression",
        path: buildPath(path),
        params: params || [],
        hash: hash || buildHash([]),
        loc: buildLoc(loc || null)
    };
}
function buildPath(original, loc) {
    if (typeof original !== 'string') return original;
    let parts = original.split('.');
    let thisHead = false;
    if (parts[0] === 'this') {
        thisHead = true;
        parts = parts.slice(1);
    }
    return {
        type: "PathExpression",
        original,
        this: thisHead,
        parts,
        data: false,
        loc: buildLoc(loc || null)
    };
}
function buildLiteral(type, value, loc) {
    return {
        type,
        value,
        original: value,
        loc: buildLoc(loc || null)
    };
}
// Miscellaneous
function buildHash(pairs, loc) {
    return {
        type: "Hash",
        pairs: pairs || [],
        loc: buildLoc(loc || null)
    };
}
function buildPair(key, value, loc) {
    return {
        type: "HashPair",
        key: key,
        value,
        loc: buildLoc(loc || null)
    };
}
function buildProgram(body, blockParams, loc) {
    return {
        type: "Program",
        body: body || [],
        blockParams: blockParams || [],
        loc: buildLoc(loc || null)
    };
}
function buildSource(source) {
    return source || null;
}
function buildPosition(line, column) {
    return {
        line,
        column
    };
}
export const SYNTHETIC = { source: '(synthetic)', start: { line: 1, column: 0 }, end: { line: 1, column: 0 } };
function buildLoc(...args) {
    if (args.length === 1) {
        let loc = args[0];
        if (loc && typeof loc === 'object') {
            return {
                source: buildSource(loc.source),
                start: buildPosition(loc.start.line, loc.start.column),
                end: buildPosition(loc.end.line, loc.end.column)
            };
        } else {
            return SYNTHETIC;
        }
    } else {
        let [startLine, startColumn, endLine, endColumn, source] = args;
        return {
            source: buildSource(source),
            start: buildPosition(startLine, startColumn),
            end: buildPosition(endLine, endColumn)
        };
    }
}
export default {
    mustache: buildMustache,
    block: buildBlock,
    partial: buildPartial,
    comment: buildComment,
    mustacheComment: buildMustacheComment,
    element: buildElement,
    elementModifier: buildElementModifier,
    attr: buildAttr,
    text: buildText,
    sexpr: buildSexpr,
    path: buildPath,
    concat: buildConcat,
    hash: buildHash,
    pair: buildPair,
    literal: buildLiteral,
    program: buildProgram,
    loc: buildLoc,
    pos: buildPosition,
    string: literal('StringLiteral'),
    boolean: literal('BooleanLiteral'),
    number: literal('NumberLiteral'),
    undefined() {
        return buildLiteral('UndefinedLiteral', undefined);
    },
    null() {
        return buildLiteral('NullLiteral', null);
    }
};
function literal(type) {
    return function (value) {
        return buildLiteral(type, value);
    };
}