import { EventedTokenizer, EntityParser, HTML5NamedCharRefs as namedCharRefs } from "simple-html-tokenizer";
import { assert, expect } from '@glimmer/util';
const entityParser = new EntityParser(namedCharRefs);
export class Parser {
    constructor(source, options = {}) {
        this.elementStack = [];
        this.currentAttribute = null;
        this.currentNode = null;
        this.tokenizer = new EventedTokenizer(this, entityParser);
        this.options = options;
        this.source = source.split(/(?:\r\n?|\n)/g);
    }
    get currentAttr() {
        return expect(this.currentAttribute, 'expected attribute');
    }
    get currentTag() {
        let node = this.currentNode;
        assert(node && (node.type === 'StartTag' || node.type === 'EndTag'), 'expected tag');
        return node;
    }
    get currentStartTag() {
        let node = this.currentNode;
        assert(node && node.type === 'StartTag', 'expected start tag');
        return node;
    }
    get currentEndTag() {
        let node = this.currentNode;
        assert(node && node.type === 'EndTag', 'expected end tag');
        return node;
    }
    get currentComment() {
        let node = this.currentNode;
        assert(node && node.type === 'CommentStatement', 'expected a comment');
        return node;
    }
    get currentData() {
        let node = this.currentNode;
        assert(node && node.type === 'TextNode', 'expected a text node');
        return node;
    }
    acceptNode(node) {
        return this[node.type](node);
    }
    currentElement() {
        return this.elementStack[this.elementStack.length - 1];
    }
    sourceForNode(node, endNode) {
        let firstLine = node.loc.start.line - 1;
        let currentLine = firstLine - 1;
        let firstColumn = node.loc.start.column;
        let string = [];
        let line;
        let lastLine;
        let lastColumn;
        if (endNode) {
            lastLine = endNode.loc.end.line - 1;
            lastColumn = endNode.loc.end.column;
        } else {
            lastLine = node.loc.end.line - 1;
            lastColumn = node.loc.end.column;
        }
        while (currentLine < lastLine) {
            currentLine++;
            line = this.source[currentLine];
            if (currentLine === firstLine) {
                if (firstLine === lastLine) {
                    string.push(line.slice(firstColumn, lastColumn));
                } else {
                    string.push(line.slice(firstColumn));
                }
            } else if (currentLine === lastLine) {
                string.push(line.slice(0, lastColumn));
            } else {
                string.push(line);
            }
        }
        return string.join('\n');
    }
}