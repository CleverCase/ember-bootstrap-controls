import { EventedTokenizer } from "simple-html-tokenizer";
import { Program } from "./types/nodes";
import * as AST from "./types/nodes";
import * as HandlebarsAST from './types/handlebars-ast';
import { Option } from '@glimmer/interfaces';
export declare type Element = AST.Program | AST.ElementNode;
export interface Tag<T extends 'StartTag' | 'EndTag'> {
    type: T;
    name: string;
    attributes: any[];
    modifiers: any[];
    comments: any[];
    selfClosing: boolean;
    loc: AST.SourceLocation;
}
export interface Attribute {
    name: string;
    parts: (AST.MustacheStatement | AST.TextNode)[];
    isQuoted: boolean;
    isDynamic: boolean;
    start: AST.Position;
    valueStartLine: number;
    valueStartColumn: number;
}
export declare class Parser {
    protected elementStack: Element[];
    private options;
    private source;
    currentAttribute: Option<Attribute>;
    currentNode: Option<AST.CommentStatement | AST.TextNode | Tag<'StartTag' | 'EndTag'>>;
    tokenizer: EventedTokenizer;
    constructor(source: string, options?: Object);
    readonly currentAttr: Attribute;
    readonly currentTag: Tag<'StartTag' | 'EndTag'>;
    readonly currentStartTag: Tag<'StartTag'>;
    readonly currentEndTag: Tag<'EndTag'>;
    readonly currentComment: AST.CommentStatement;
    readonly currentData: AST.TextNode;
    acceptNode(node: HandlebarsAST.Program): Program;
    acceptNode<U extends AST.Node>(node: HandlebarsAST.Node): U;
    currentElement(): Element;
    sourceForNode(node: HandlebarsAST.Node, endNode?: {
        loc: HandlebarsAST.SourceLocation;
    }): string;
}
