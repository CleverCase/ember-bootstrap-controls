import * as AST from './types/nodes';
export declare type BuilderPath = string | AST.PathExpression;
export declare const SYNTHETIC: AST.SourceLocation;
declare var _default: {
    mustache: (path: string | AST.PathExpression | AST.StringLiteral | AST.BooleanLiteral | AST.NumberLiteral | AST.UndefinedLiteral | AST.NullLiteral, params?: AST.Expression[], hash?: AST.Hash, raw?: boolean, loc?: AST.SourceLocation) => AST.MustacheStatement;
    block: (path: BuilderPath, params: any, hash: any, program: AST.Program, inverse?: any, loc?: AST.SourceLocation) => AST.BlockStatement;
    partial: (name: AST.PathExpression, params?: AST.Expression[], hash?: AST.Hash, indent?: string, loc?: AST.SourceLocation) => AST.PartialStatement;
    comment: (value: string, loc?: AST.SourceLocation) => AST.CommentStatement;
    mustacheComment: (value: string, loc?: AST.SourceLocation) => AST.MustacheCommentStatement;
    element: {
        (tag: string, attributes?: AST.AttrNode[], modifiers?: AST.ElementModifierStatement[], children?: AST.Statement[], loc?: AST.SourceLocation): AST.ElementNode;
        (tag: string, attributes?: AST.AttrNode[], modifiers?: AST.ElementModifierStatement[], children?: AST.Statement[], comments?: AST.MustacheCommentStatement[], loc?: AST.SourceLocation): AST.ElementNode;
    };
    elementModifier: (path: BuilderPath, params?: AST.Expression[], hash?: AST.Hash, loc?: any) => AST.ElementModifierStatement;
    attr: (name: string, value: AST.MustacheStatement | AST.TextNode | AST.ConcatStatement, loc?: AST.SourceLocation) => AST.AttrNode;
    text: (chars?: string, loc?: AST.SourceLocation) => AST.TextNode;
    sexpr: (path: AST.PathExpression, params?: AST.Expression[], hash?: AST.Hash, loc?: AST.SourceLocation) => AST.SubExpression;
    path: (original: BuilderPath, loc?: AST.SourceLocation) => AST.PathExpression;
    concat: (parts: (AST.MustacheStatement | AST.TextNode)[], loc?: AST.SourceLocation) => AST.ConcatStatement;
    hash: (pairs?: AST.HashPair[], loc?: AST.SourceLocation) => AST.Hash;
    pair: (key: string, value: AST.Expression, loc?: AST.SourceLocation) => AST.HashPair;
    literal: <T extends AST.Literal>(type: T["type"], value: T["value"], loc?: AST.SourceLocation) => AST.Literal;
    program: (body?: AST.Statement[], blockParams?: string[], loc?: AST.SourceLocation) => AST.Program;
    loc: {
        (loc: any): AST.SourceLocation;
        (startLine: number, startColumn: number, endLine?: number, endColumn?: number, source?: string): AST.SourceLocation;
    };
    pos: (line: number, column: number) => {
        line: number;
        column: number;
    };
    string: (value: string | number | boolean) => AST.Literal;
    boolean: (value: string | number | boolean) => AST.Literal;
    number: (value: string | number | boolean) => AST.Literal;
    undefined(): AST.Literal;
    null(): AST.Literal;
};
export default _default;
