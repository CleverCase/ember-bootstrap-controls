"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Parser = undefined;

var _simpleHtmlTokenizer = require("simple-html-tokenizer");

var _util = require("@glimmer/util");

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var entityParser = new _simpleHtmlTokenizer.EntityParser(_simpleHtmlTokenizer.HTML5NamedCharRefs);
var Parser = exports.Parser = function () {
    function Parser(source) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Parser);

        this.elementStack = [];
        this.currentAttribute = null;
        this.currentNode = null;
        this.tokenizer = new _simpleHtmlTokenizer.EventedTokenizer(this, entityParser);
        this.options = options;
        this.source = source.split(/(?:\r\n?|\n)/g);
    }

    Parser.prototype.acceptNode = function acceptNode(node) {
        return this[node.type](node);
    };

    Parser.prototype.currentElement = function currentElement() {
        return this.elementStack[this.elementStack.length - 1];
    };

    Parser.prototype.sourceForNode = function sourceForNode(node, endNode) {
        var firstLine = node.loc.start.line - 1;
        var currentLine = firstLine - 1;
        var firstColumn = node.loc.start.column;
        var string = [];
        var line = void 0;
        var lastLine = void 0;
        var lastColumn = void 0;
        if (endNode) {
            lastLine = endNode.loc.end.line - 1;
            lastColumn = endNode.loc.end.column;
        } else {
            lastLine = node.loc.end.line - 1;
            lastColumn = node.loc.end.column;
        }
        while (currentLine < lastLine) {
            currentLine++;
            line = this.source[currentLine];
            if (currentLine === firstLine) {
                if (firstLine === lastLine) {
                    string.push(line.slice(firstColumn, lastColumn));
                } else {
                    string.push(line.slice(firstColumn));
                }
            } else if (currentLine === lastLine) {
                string.push(line.slice(0, lastColumn));
            } else {
                string.push(line);
            }
        }
        return string.join('\n');
    };

    _createClass(Parser, [{
        key: 'currentAttr',
        get: function () {
            return this.currentAttribute;
        }
    }, {
        key: 'currentTag',
        get: function () {
            var node = this.currentNode;
            (0, _util.assert)(node && (node.type === 'StartTag' || node.type === 'EndTag'), 'expected tag');
            return node;
        }
    }, {
        key: 'currentStartTag',
        get: function () {
            var node = this.currentNode;
            (0, _util.assert)(node && node.type === 'StartTag', 'expected start tag');
            return node;
        }
    }, {
        key: 'currentEndTag',
        get: function () {
            var node = this.currentNode;
            (0, _util.assert)(node && node.type === 'EndTag', 'expected end tag');
            return node;
        }
    }, {
        key: 'currentComment',
        get: function () {
            var node = this.currentNode;
            (0, _util.assert)(node && node.type === 'CommentStatement', 'expected a comment');
            return node;
        }
    }, {
        key: 'currentData',
        get: function () {
            var node = this.currentNode;
            (0, _util.assert)(node && node.type === 'TextNode', 'expected a text node');
            return node;
        }
    }]);

    return Parser;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9wYXJzZXIuanMiXSwibmFtZXMiOlsiRXZlbnRlZFRva2VuaXplciIsIkVudGl0eVBhcnNlciIsIkhUTUw1TmFtZWRDaGFyUmVmcyIsIm5hbWVkQ2hhclJlZnMiLCJhc3NlcnQiLCJlbnRpdHlQYXJzZXIiLCJQYXJzZXIiLCJzb3VyY2UiLCJvcHRpb25zIiwiZWxlbWVudFN0YWNrIiwiY3VycmVudEF0dHJpYnV0ZSIsImN1cnJlbnROb2RlIiwidG9rZW5pemVyIiwic3BsaXQiLCJhY2NlcHROb2RlIiwibm9kZSIsInR5cGUiLCJjdXJyZW50RWxlbWVudCIsImxlbmd0aCIsInNvdXJjZUZvck5vZGUiLCJlbmROb2RlIiwiZmlyc3RMaW5lIiwibG9jIiwic3RhcnQiLCJsaW5lIiwiY3VycmVudExpbmUiLCJmaXJzdENvbHVtbiIsImNvbHVtbiIsInN0cmluZyIsImxhc3RMaW5lIiwibGFzdENvbHVtbiIsImVuZCIsInB1c2giLCJzbGljZSIsImpvaW4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxBQUFTLEFBQWtCLEFBQWMsQUFBc0IsQUFBcUI7O0FBQ3BGLEFBQVMsQUFBc0I7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUMvQixJQUFNLGVBQU4sQUFBcUIsQUFBSSxBQUFhLEFBQ3RDO0lBQUEsQUFBYSxzQ0FDVDtvQkFBQSxBQUFZLFFBQXNCO1lBQWQsQUFBYyw4RUFBSixBQUFJOzs4QkFDOUI7O2FBQUEsQUFBSyxlQUFMLEFBQW9CLEFBQ3BCO2FBQUEsQUFBSyxtQkFBTCxBQUF3QixBQUN4QjthQUFBLEFBQUssY0FBTCxBQUFtQixBQUNuQjthQUFBLEFBQUssWUFBWSxBQUFJLDBDQUFKLEFBQXFCLE1BQXRDLEFBQWlCLEFBQTJCLEFBQzVDO2FBQUEsQUFBSyxVQUFMLEFBQWUsQUFDZjthQUFBLEFBQUssU0FBUyxPQUFBLEFBQU8sTUFBckIsQUFBYyxBQUFhLEFBQzlCO0FBUkw7O3FCQUFBLEFBcUNJLGlDQXJDSixBQXFDZSxNQUFNLEFBQ2I7ZUFBTyxLQUFL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anMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudGVkVG9rZW5pemVyLCBFbnRpdHlQYXJzZXIsIEhUTUw1TmFtZWRDaGFyUmVmcyBhcyBuYW1lZENoYXJSZWZzIH0gZnJvbSBcInNpbXBsZS1odG1sLXRva2VuaXplclwiO1xuaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmNvbnN0IGVudGl0eVBhcnNlciA9IG5ldyBFbnRpdHlQYXJzZXIobmFtZWRDaGFyUmVmcyk7XG5leHBvcnQgY2xhc3MgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGUgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSBuZXcgRXZlbnRlZFRva2VuaXplcih0aGlzLCBlbnRpdHlQYXJzZXIpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZS5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEF0dHIoKSB7XG4gICAgICAgIHJldHVybiBleHBlY3QodGhpcy5jdXJyZW50QXR0cmlidXRlLCAnZXhwZWN0ZWQgYXR0cmlidXRlJyk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGFnKCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgICAgIGFzc2VydChub2RlICYmIChub2RlLnR5cGUgPT09ICdTdGFydFRhZycgfHwgbm9kZS50eXBlID09PSAnRW5kVGFnJyksICdleHBlY3RlZCB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGdldCBjdXJyZW50U3RhcnRUYWcoKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICAgICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnU3RhcnRUYWcnLCAnZXhwZWN0ZWQgc3RhcnQgdGFnJyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVuZFRhZygpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgICAgICBhc3NlcnQobm9kZSAmJiBub2RlLnR5cGUgPT09ICdFbmRUYWcnLCAnZXhwZWN0ZWQgZW5kIHRhZycpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRDb21tZW50KCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudE5vZGU7XG4gICAgICAgIGFzc2VydChub2RlICYmIG5vZGUudHlwZSA9PT0gJ0NvbW1lbnRTdGF0ZW1lbnQnLCAnZXhwZWN0ZWQgYSBjb21tZW50Jyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXQgY3VycmVudERhdGEoKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICAgICAgYXNzZXJ0KG5vZGUgJiYgbm9kZS50eXBlID09PSAnVGV4dE5vZGUnLCAnZXhwZWN0ZWQgYSB0ZXh0IG5vZGUnKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGFjY2VwdE5vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpc1tub2RlLnR5cGVdKG5vZGUpO1xuICAgIH1cbiAgICBjdXJyZW50RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YWNrW3RoaXMuZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzb3VyY2VGb3JOb2RlKG5vZGUsIGVuZE5vZGUpIHtcbiAgICAgICAgbGV0IGZpcnN0TGluZSA9IG5vZGUubG9jLnN0YXJ0LmxpbmUgLSAxO1xuICAgICAgICBsZXQgY3VycmVudExpbmUgPSBmaXJzdExpbmUgLSAxO1xuICAgICAgICBsZXQgZmlyc3RDb2x1bW4gPSBub2RlLmxvYy5zdGFydC5jb2x1bW47XG4gICAgICAgIGxldCBzdHJpbmcgPSBbXTtcbiAgICAgICAgbGV0IGxpbmU7XG4gICAgICAgIGxldCBsYXN0TGluZTtcbiAgICAgICAgbGV0IGxhc3RDb2x1bW47XG4gICAgICAgIGlmIChlbmROb2RlKSB7XG4gICAgICAgICAgICBsYXN0TGluZSA9IGVuZE5vZGUubG9jLmVuZC5saW5lIC0gMTtcbiAgICAgICAgICAgIGxhc3RDb2x1bW4gPSBlbmROb2RlLmxvYy5lbmQuY29sdW1uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdExpbmUgPSBub2RlLmxvYy5lbmQubGluZSAtIDE7XG4gICAgICAgICAgICBsYXN0Q29sdW1uID0gbm9kZS5sb2MuZW5kLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY3VycmVudExpbmUgPCBsYXN0TGluZSkge1xuICAgICAgICAgICAgY3VycmVudExpbmUrKztcbiAgICAgICAgICAgIGxpbmUgPSB0aGlzLnNvdXJjZVtjdXJyZW50TGluZV07XG4gICAgICAgICAgICBpZiAoY3VycmVudExpbmUgPT09IGZpcnN0TGluZSkge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdExpbmUgPT09IGxhc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGxpbmUuc2xpY2UoZmlyc3RDb2x1bW4sIGxhc3RDb2x1bW4pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChsaW5lLnNsaWNlKGZpcnN0Q29sdW1uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50TGluZSA9PT0gbGFzdExpbmUpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChsaW5lLnNsaWNlKDAsIGxhc3RDb2x1bW4pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2gobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZy5qb2luKCdcXG4nKTtcbiAgICB9XG59Il19