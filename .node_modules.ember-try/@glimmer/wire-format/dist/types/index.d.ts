import { Option } from '@glimmer/util';
import { Opcodes } from './lib/opcodes';
export { Opcodes as Ops } from './lib/opcodes';
export declare type str = string;
export declare type TemplateReference = Option<SerializedBlock>;
export declare type YieldTo = number;
export declare function is<T>(variant: number): (value: any) => value is T;
export declare namespace Core {
    type Expression = Expressions.Expression;
    type Path = str[];
    type Params = Expression[];
    type Hash = Option<[str[], Expression[]]>;
    type Args = [Params, Hash];
    type EvalInfo = number[];
}
export declare namespace Expressions {
    type Path = Core.Path;
    type Params = Core.Params;
    type Hash = Core.Hash;
    type Unknown = [Opcodes.Unknown, str];
    type Get = [Opcodes.Get, number, Path];
    /**
     * Ambiguous between a self lookup (when not inside an eval) and
     * a local variable (when used inside of an eval).
     */
    type MaybeLocal = [Opcodes.MaybeLocal, Path];
    type Value = str | number | boolean | null;
    type HasBlock = [Opcodes.HasBlock, YieldTo];
    type HasBlockParams = [Opcodes.HasBlockParams, YieldTo];
    type Undefined = [Opcodes.Undefined];
    type ClientSide = [Opcodes.ClientSideExpression, any];
    type TupleExpression = Unknown | Get | MaybeLocal | Concat | HasBlock | HasBlockParams | Helper | Undefined | ClientSide;
    type Expression = TupleExpression | Value;
    interface Concat extends Array<any> {
        [0]: Opcodes.Concat;
        [1]: Params;
    }
    interface Helper extends Array<any> {
        [0]: Opcodes.Helper;
        [1]: str;
        [2]: Params;
        [3]: Hash;
    }
    const isUnknown: (value: any) => value is [Opcodes.Unknown, string];
    const isGet: (value: any) => value is [Opcodes.Get, number, string[]];
    const isConcat: (value: any) => value is Concat;
    const isHelper: (value: any) => value is Helper;
    const isHasBlock: (value: any) => value is [Opcodes.HasBlock, number];
    const isHasBlockParams: (value: any) => value is [Opcodes.HasBlockParams, number];
    const isUndefined: (value: any) => value is [Opcodes.Undefined];
    const isClientSide: (value: any) => value is [Opcodes.ClientSideExpression, any];
    const isMaybeLocal: (value: any) => value is [Opcodes.MaybeLocal, string[]];
    function isPrimitiveValue(value: any): value is Value;
}
export declare type Expression = Expressions.Expression;
export declare type TupleExpression = Expressions.TupleExpression;
export declare namespace Statements {
    type Expression = Expressions.Expression;
    type Params = Core.Params;
    type Hash = Core.Hash;
    type Path = Core.Path;
    type Text = [Opcodes.Text, str];
    type Append = [Opcodes.Append, Expression, boolean];
    type Comment = [Opcodes.Comment, str];
    type Modifier = [Opcodes.Modifier, str, Params, Hash];
    type Block = [Opcodes.Block, str, Params, Hash, Option<SerializedInlineBlock>, Option<SerializedInlineBlock>];
    type Component = [Opcodes.Component, str, Attribute[], Hash, Option<SerializedInlineBlock>];
    type OpenElement = [Opcodes.OpenElement, str];
    type FlushElement = [Opcodes.FlushElement];
    type CloseElement = [Opcodes.CloseElement];
    type StaticAttr = [Opcodes.StaticAttr, str, Expression, Option<str>];
    type DynamicAttr = [Opcodes.DynamicAttr, str, Expression, Option<str>];
    type Yield = [Opcodes.Yield, YieldTo, Option<Params>];
    type Partial = [Opcodes.Partial, Expression, Core.EvalInfo];
    type DynamicArg = [Opcodes.DynamicArg, str, Expression];
    type StaticArg = [Opcodes.StaticArg, str, Expression];
    type TrustingAttr = [Opcodes.TrustingAttr, str, Expression, str];
    type Debugger = [Opcodes.Debugger, Core.EvalInfo];
    type ClientSide = [Opcodes.ClientSideStatement, any];
    const isText: (value: any) => value is [Opcodes.Text, string];
    const isAppend: (value: any) => value is [Opcodes.Append, Expressions.Expression, boolean];
    const isComment: (value: any) => value is [Opcodes.Comment, string];
    const isModifier: (value: any) => value is [Opcodes.Modifier, string, Expressions.Expression[], any];
    const isBlock: (value: any) => value is [Opcodes.Block, string, Expressions.Expression[], any, any, any];
    const isComponent: (value: any) => value is [Opcodes.Component, string, Attribute[], any, any];
    const isOpenElement: (value: any) => value is [Opcodes.OpenElement, string];
    const isFlushElement: (value: any) => value is [Opcodes.FlushElement];
    const isCloseElement: (value: any) => value is [Opcodes.CloseElement];
    const isStaticAttr: (value: any) => value is [Opcodes.StaticAttr, string, Expressions.Expression, any];
    const isDynamicAttr: (value: any) => value is [Opcodes.DynamicAttr, string, Expressions.Expression, any];
    const isYield: (value: any) => value is [Opcodes.Yield, number, any];
    const isPartial: (value: any) => value is [Opcodes.Partial, Expressions.Expression, number[]];
    const isDynamicArg: (value: any) => value is [Opcodes.DynamicArg, string, Expressions.Expression];
    const isStaticArg: (value: any) => value is [Opcodes.StaticArg, string, Expressions.Expression];
    const isTrustingAttr: (value: any) => value is [Opcodes.TrustingAttr, string, Expressions.Expression, string];
    const isDebugger: (value: any) => value is [Opcodes.Debugger, number[]];
    const isClientSide: (value: any) => value is [Opcodes.ClientSideStatement, any];
    type Statement = Text | Append | Comment | Modifier | Block | Component | OpenElement | FlushElement | CloseElement | StaticAttr | DynamicAttr | Yield | Partial | StaticArg | DynamicArg | TrustingAttr | Debugger | ClientSide;
    type Attribute = Statements.StaticAttr | Statements.DynamicAttr;
    function isAttribute(val: Statement): val is Attribute;
    type Argument = Statements.StaticArg | Statements.DynamicArg;
    function isArgument(val: Statement): val is Argument;
    type Parameter = Attribute | Argument;
    function isParameter(val: Statement): val is Parameter;
    function getParameterName(s: Parameter): string;
}
export declare type Statement = Statements.Statement;
/**
 * A JSON object of static compile time meta for the template.
 */
export interface TemplateMeta {
    moduleName?: string;
}
/**
 * A JSON object that the Block was serialized into.
 */
export interface SerializedBlock {
    statements: Statements.Statement[];
}
export interface SerializedInlineBlock extends SerializedBlock {
    parameters: number[];
}
/**
 * A JSON object that the compiled TemplateBlock was serialized into.
 */
export interface SerializedTemplateBlock extends SerializedBlock {
    symbols: string[];
    hasEval: boolean;
}
/**
 * A JSON object that the compiled Template was serialized into.
 */
export interface SerializedTemplate<T extends TemplateMeta> {
    block: SerializedTemplateBlock;
    meta: T;
}
/**
 * A string of JSON containing a SerializedTemplateBlock
 */
export declare type SerializedTemplateBlockJSON = string;
/**
 * A JSON object containing the SerializedTemplateBlock as JSON and TemplateMeta.
 */
export interface SerializedTemplateWithLazyBlock<T extends TemplateMeta> {
    id?: Option<string>;
    block: SerializedTemplateBlockJSON;
    meta: T;
}
/**
 * A string of Javascript containing a SerializedTemplateWithLazyBlock to be
 * concatenated into a Javascript module.
 */
export declare type TemplateJavascript = string;
