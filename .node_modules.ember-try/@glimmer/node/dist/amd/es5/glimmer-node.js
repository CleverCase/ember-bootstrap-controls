define('@glimmer/node', ['exports', '@glimmer/runtime'], function (exports, _glimmer_runtime) { 'use strict';

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

var NodeDOMTreeConstruction = function (_DOMTreeConstruction) {
    _inherits(NodeDOMTreeConstruction, _DOMTreeConstruction);

    function NodeDOMTreeConstruction(doc) {
        _classCallCheck(this, NodeDOMTreeConstruction);

        return _possibleConstructorReturn(this, _DOMTreeConstruction.call(this, doc));
    }
    // override to prevent usage of `this.document` until after the constructor


    NodeDOMTreeConstruction.prototype.setupUselessElement = function setupUselessElement() {};

    NodeDOMTreeConstruction.prototype.insertHTMLBefore = function insertHTMLBefore(parent, reference, html) {
        var prev = reference ? reference.previousSibling : parent.lastChild;
        var raw = this.document.createRawHTMLSection(html);
        parent.insertBefore(raw, reference);
        var first = prev ? prev.nextSibling : parent.firstChild;
        var last = reference ? reference.previousSibling : parent.lastChild;
        return new _glimmer_runtime.ConcreteBounds(parent, first, last);
    };
    // override to avoid SVG detection/work when in node (this is not needed in SSR)


    NodeDOMTreeConstruction.prototype.createElement = function createElement(tag) {
        return this.document.createElement(tag);
    };
    // override to avoid namespace shenanigans when in node (this is not needed in SSR)


    NodeDOMTreeConstruction.prototype.setAttribute = function setAttribute(element, name, value) {
        element.setAttribute(name, value);
    };

    return NodeDOMTreeConstruction;
}(_glimmer_runtime.DOMTreeConstruction);

exports.NodeDOMTreeConstruction = NodeDOMTreeConstruction;

Object.defineProperty(exports, '__esModule', { value: true });

});
