import { MetaOptions } from './types';
import { Dict, HasGuid, Set } from '@glimmer/util';
import { PathReferenceFactory, Meta as IMeta, RootReference as IRootReference } from './types';
import { PathReference as IPathReference } from '@glimmer/reference';
import { InnerReferenceFactory } from './references/descriptors';
import { Option } from "@glimmer/interfaces";
export declare const CLASS_META = "df8be4c8-4e89-44e2-a8f9-550c8dacdca7";
declare class Meta implements IMeta, HasGuid {
    static for(obj: any): IMeta;
    static exists(obj: any): boolean;
    static metadataForProperty(_key: string): any;
    private object;
    private RootReferenceFactory;
    private DefaultPathReferenceFactory;
    private rootCache;
    private references;
    _guid: number;
    protected slots: Option<Dict<any>>;
    protected referenceTypes: Option<Dict<InnerReferenceFactory<any>>>;
    protected propertyMetadata: Option<Dict<any>>;
    constructor(object: any, {RootReferenceFactory, DefaultPathReferenceFactory}: MetaOptions);
    addReference(property: string, reference: IPathReference<any> & HasGuid): void;
    addReferenceTypeFor(property: string, type: PathReferenceFactory<any>): void;
    referenceTypeFor(property: string): InnerReferenceFactory<any>;
    removeReference(property: string, reference: IPathReference<any> & HasGuid): void;
    getReferenceTypes(): Dict<InnerReferenceFactory<any>>;
    referencesFor(property: string): Option<Set<IPathReference<any>>>;
    getSlots(): any;
    root(): IRootReference<any>;
}
export default Meta;
export declare function metaFor(obj: any): IMeta;
