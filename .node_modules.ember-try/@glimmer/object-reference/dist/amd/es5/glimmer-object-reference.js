define('@glimmer/object-reference', ['exports', '@glimmer/util', '@glimmer/reference'], function (exports, _glimmer_util, _glimmer_reference) { 'use strict';

function EMPTY_CACHE() {}

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PathReference = function () {
    function PathReference(parent, property) {
        _classCallCheck$3(this, PathReference);

        this.cache = EMPTY_CACHE;
        this.inner = null;
        this.chains = null;
        this.lastParentValue = EMPTY_CACHE;
        this._guid = 0;
        this.tag = _glimmer_reference.VOLATILE_TAG;
        this.parent = parent;
        this.property = property;
    }

    PathReference.prototype.value = function value() {
        var lastParentValue = this.lastParentValue,
            property = this.property,
            inner = this.inner;

        var parentValue = this._parentValue();
        if (parentValue === null || parentValue === undefined) {
            return this.cache = undefined;
        }
        if (lastParentValue === parentValue) {
            inner = this.inner;
        } else {
            var ReferenceType = typeof parentValue === 'object' ? Meta.for(parentValue).referenceTypeFor(property) : PropertyReference;
            inner = this.inner = new ReferenceType(parentValue, property, this);
        }
        // if (typeof parentValue === 'object') {
        //   Meta.for(parentValue).addReference(property, this);
        // }
        return this.cache = inner.value();
    };

    PathReference.prototype.get = function get(prop) {
        var chains = this._getChains();
        if (prop in chains) return chains[prop];
        return chains[prop] = new PathReference(this, prop);
    };

    PathReference.prototype.label = function label() {
        return '[reference Direct]';
    };

    PathReference.prototype._getChains = function _getChains() {
        if (this.chains) return this.chains;
        return this.chains = _glimmer_util.dict();
    };

    PathReference.prototype._parentValue = function _parentValue() {
        var parent = this.parent.value();
        this.lastParentValue = parent;
        return parent;
    };

    return PathReference;
}();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RootReference = function () {
    function RootReference(object) {
        _classCallCheck$2(this, RootReference);

        this.chains = _glimmer_util.dict();
        this.tag = _glimmer_reference.VOLATILE_TAG;
        this.object = object;
    }

    RootReference.prototype.value = function value() {
        return this.object;
    };

    RootReference.prototype.update = function update(object) {
        this.object = object;
        // this.notify();
    };

    RootReference.prototype.get = function get(prop) {
        var chains = this.chains;
        if (prop in chains) return chains[prop];
        return chains[prop] = new PathReference(this, prop);
    };

    RootReference.prototype.chainFor = function chainFor(prop) {
        var chains = this.chains;
        if (prop in chains) return chains[prop];
        return null;
    };

    RootReference.prototype.path = function path(string) {
        return string.split('.').reduce(function (ref, part) {
            return ref.get(part);
        }, this);
    };

    RootReference.prototype.referenceFromParts = function referenceFromParts(parts) {
        return parts.reduce(function (ref, part) {
            return ref.get(part);
        }, this);
    };

    RootReference.prototype.label = function label() {
        return '[reference Root]';
    };

    return RootReference;
}();

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NOOP_DESTROY = {
    destroy: function () {}
};

var ConstPath = function () {
    function ConstPath(parent, _property) {
        _classCallCheck$1(this, ConstPath);

        this.tag = _glimmer_reference.VOLATILE_TAG;
        this.parent = parent;
    }

    ConstPath.prototype.chain = function chain() {
        return NOOP_DESTROY;
    };

    ConstPath.prototype.notify = function notify() {};

    ConstPath.prototype.value = function value() {
        return this.parent[this.property];
    };

    ConstPath.prototype.get = function get(prop) {
        return new ConstPath(this.parent[this.property], prop);
    };

    return ConstPath;
}();

var ConstRoot = function () {
    function ConstRoot(value) {
        _classCallCheck$1(this, ConstRoot);

        this.tag = _glimmer_reference.VOLATILE_TAG;
        this.inner = value;
    }

    ConstRoot.prototype.update = function update(inner) {
        this.inner = inner;
    };

    ConstRoot.prototype.chain = function chain() {
        return NOOP_DESTROY;
    };

    ConstRoot.prototype.notify = function notify() {};

    ConstRoot.prototype.value = function value() {
        return this.inner;
    };

    ConstRoot.prototype.referenceFromParts = function referenceFromParts(_parts) {
        throw new Error("Not implemented");
    };

    ConstRoot.prototype.chainFor = function chainFor(_prop) {
        throw new Error("Not implemented");
    };

    ConstRoot.prototype.get = function get(prop) {
        return new ConstPath(this.inner, prop);
    };

    return ConstRoot;
}();

var ConstMeta /*implements IMeta*/ = function () {
    function ConstMeta(object) {
        _classCallCheck$1(this, ConstMeta);

        this.object = object;
    }

    ConstMeta.prototype.root = function root() {
        return new ConstRoot(this.object);
    };

    return ConstMeta;
}();

var CLASS_META = "df8be4c8-4e89-44e2-a8f9-550c8dacdca7";
var hasOwnProperty = Object.hasOwnProperty;

var Meta = function () {
    function Meta(object, _ref) {
        var RootReferenceFactory = _ref.RootReferenceFactory,
            DefaultPathReferenceFactory = _ref.DefaultPathReferenceFactory;

        _classCallCheck$1(this, Meta);

        this.references = null;
        this.slots = null;
        this.referenceTypes = null;
        this.propertyMetadata = null;
        this.object = object;
        this.RootReferenceFactory = RootReferenceFactory || RootReference;
        this.DefaultPathReferenceFactory = DefaultPathReferenceFactory || PropertyReference;
    }

    Meta.for = function _for(obj) {
        if (obj === null || obj === undefined) return new Meta(obj, {});
        if (hasOwnProperty.call(obj, '_meta') && obj._meta) return obj._meta;
        if (!Object.isExtensible(obj)) return new ConstMeta(obj);
        var MetaToUse = Meta;
        if (obj.constructor && obj.constructor[CLASS_META]) {
            var classMeta = obj.constructor[CLASS_META];
            MetaToUse = classMeta.InstanceMetaConstructor;
        } else if (obj[CLASS_META]) {
            MetaToUse = obj[CLASS_META].InstanceMetaConstructor;
        }
        return obj._meta = new MetaToUse(obj, {});
    };

    Meta.exists = function exists(obj) {
        return typeof obj === 'object' && obj._meta;
    };

    Meta.metadataForProperty = function metadataForProperty(_key) {
        return null;
    };

    Meta.prototype.addReference = function addReference(property, reference) {
        var refs = this.references = this.references || _glimmer_util.dict();
        var set = refs[property] = refs[property] || new _glimmer_util.DictSet();
        set.add(reference);
    };

    Meta.prototype.addReferenceTypeFor = function addReferenceTypeFor(property, type) {
        this.referenceTypes = this.referenceTypes || _glimmer_util.dict();
        this.referenceTypes[property] = type;
    };

    Meta.prototype.referenceTypeFor = function referenceTypeFor(property) {
        if (!this.referenceTypes) return PropertyReference;
        return this.referenceTypes[property] || PropertyReference;
    };

    Meta.prototype.removeReference = function removeReference(property, reference) {
        if (!this.references) return;
        var set = this.references[property];
        set.delete(reference);
    };

    Meta.prototype.getReferenceTypes = function getReferenceTypes() {
        this.referenceTypes = this.referenceTypes || _glimmer_util.dict();
        return this.referenceTypes;
    };

    Meta.prototype.referencesFor = function referencesFor(property) {
        if (!this.references) return null;
        return this.references[property];
    };

    Meta.prototype.getSlots = function getSlots() {
        return this.slots = this.slots || _glimmer_util.dict();
    };

    Meta.prototype.root = function root() {
        return this.rootCache = this.rootCache || new this.RootReferenceFactory(this.object);
    };

    return Meta;
}();

function metaFor(obj) {
    return Meta.for(obj);
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PropertyReference = function () {
    function PropertyReference(object, property, _outer) {
        _classCallCheck(this, PropertyReference);

        this.tag = _glimmer_reference.VOLATILE_TAG;
        this.object = object;
        this.property = property;
    }

    PropertyReference.prototype.value = function value() {
        return this.object[this.property];
    };

    PropertyReference.prototype.label = function label() {
        return '[reference Property]';
    };

    return PropertyReference;
}();
function ComputedReferenceBlueprint(_property, dependencies) {
    return function () {
        function ComputedReference(object, property, outer) {
            _classCallCheck(this, ComputedReference);

            this.installed = false;
            this.tag = _glimmer_reference.VOLATILE_TAG;
            this.object = object;
            this.property = property;
            this.dependencies = dependencies;
            this.outer = outer;
        }

        ComputedReference.prototype.value = function value() {
            if (!this.installed) {
                var root = Meta.for(this.object).root();
                this.dependencies.forEach(function (dep) {
                    var ref = root.referenceFromParts(dep);
                    ref.value();
                });
                this.installed = true;
            }
            return this.object[this.property];
        };

        ComputedReference.prototype.label = function label() {
            return '[reference Computed]';
        };

        return ComputedReference;
    }();
}

// import { metaFor } from './meta';
// import { intern } from '@glimmer/util';
// import { metaFor } from './meta';
function setProperty(parent, property, val) {
    // let rootProp = metaFor(parent).root().chainFor(property));
    // let referencesToNotify = metaFor(parent).referencesFor(property));
    parent[property] = val;
    // if (referencesToNotify) {
    //   referencesToNotify.forEach(function(ref) { ref.notify(); });
    // }
    // if (rootProp) rootProp.notify();
}
function notifyProperty(_parent, _property) {
    // let rootProp = metaFor(parent).root().chainFor(property));
    // let referencesToNotify = metaFor(parent).referencesFor(property));
    // if (referencesToNotify) {
    //   referencesToNotify.forEach(function(ref) { ref.notify(); });
    // }
    // if (rootProp) rootProp.notify();
}

exports.ComputedReferenceBlueprint = ComputedReferenceBlueprint;
exports.PropertyReference = PropertyReference;
exports.CLASS_META = CLASS_META;
exports.Meta = Meta;
exports.metaFor = metaFor;
exports.setProperty = setProperty;
exports.notifyProperty = notifyProperty;
exports.ObjectReference = PathReference;
exports.UpdatableReference = RootReference;
exports.ConstReference = _glimmer_reference.ConstReference;
exports.isConst = _glimmer_reference.isConst;

Object.defineProperty(exports, '__esModule', { value: true });

});
