function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

import { LinkedList, ListNode, dict } from '@glimmer/util';
export var ListItem = function (_ListNode) {
    _inherits(ListItem, _ListNode);

    function ListItem(iterable, result) {
        _classCallCheck(this, ListItem);

        var _this = _possibleConstructorReturn(this, _ListNode.call(this, iterable.valueReferenceFor(result)));

        _this.retained = false;
        _this.seen = false;
        _this.key = result.key;
        _this.iterable = iterable;
        _this.memo = iterable.memoReferenceFor(result);
        return _this;
    }

    ListItem.prototype.update = function update(item) {
        this.retained = true;
        this.iterable.updateValueReference(this.value, item);
        this.iterable.updateMemoReference(this.memo, item);
    };

    ListItem.prototype.shouldRemove = function shouldRemove() {
        return !this.retained;
    };

    ListItem.prototype.reset = function reset() {
        this.retained = false;
        this.seen = false;
    };

    return ListItem;
}(ListNode);
export var IterationArtifacts = function () {
    function IterationArtifacts(iterable) {
        _classCallCheck(this, IterationArtifacts);

        this.map = dict();
        this.list = new LinkedList();
        this.tag = iterable.tag;
        this.iterable = iterable;
    }

    IterationArtifacts.prototype.isEmpty = function isEmpty() {
        var iterator = this.iterator = this.iterable.iterate();
        return iterator.isEmpty();
    };

    IterationArtifacts.prototype.iterate = function iterate() {
        var iterator = this.iterator || this.iterable.iterate();
        this.iterator = null;
        return iterator;
    };

    IterationArtifacts.prototype.has = function has(key) {
        return !!this.map[key];
    };

    IterationArtifacts.prototype.get = function get(key) {
        return this.map[key];
    };

    IterationArtifacts.prototype.wasSeen = function wasSeen(key) {
        var node = this.map[key];
        return node && node.seen;
    };

    IterationArtifacts.prototype.append = function append(item) {
        var map = this.map,
            list = this.list,
            iterable = this.iterable;

        var node = map[item.key] = new ListItem(iterable, item);
        list.append(node);
        return node;
    };

    IterationArtifacts.prototype.insertBefore = function insertBefore(item, reference) {
        var map = this.map,
            list = this.list,
            iterable = this.iterable;

        var node = map[item.key] = new ListItem(iterable, item);
        node.retained = true;
        list.insertBefore(node, reference);
        return node;
    };

    IterationArtifacts.prototype.move = function move(item, reference) {
        var list = this.list;

        item.retained = true;
        list.remove(item);
        list.insertBefore(item, reference);
    };

    IterationArtifacts.prototype.remove = function remove(item) {
        var list = this.list;

        list.remove(item);
        delete this.map[item.key];
    };

    IterationArtifacts.prototype.nextNode = function nextNode(item) {
        return this.list.nextNode(item);
    };

    IterationArtifacts.prototype.head = function head() {
        return this.list.head();
    };

    return IterationArtifacts;
}();
export var ReferenceIterator = function () {
    // if anyone needs to construct this object with something other than
    // an iterable, let @wycats know.
    function ReferenceIterator(iterable) {
        _classCallCheck(this, ReferenceIterator);

        this.iterator = null;
        var artifacts = new IterationArtifacts(iterable);
        this.artifacts = artifacts;
    }

    ReferenceIterator.prototype.next = function next() {
        var artifacts = this.artifacts;

        var iterator = this.iterator = this.iterator || artifacts.iterate();
        var item = iterator.next();
        if (!item) return null;
        return artifacts.append(item);
    };

    return ReferenceIterator;
}();
var Phase;
(function (Phase) {
    Phase[Phase["Append"] = 0] = "Append";
    Phase[Phase["Prune"] = 1] = "Prune";
    Phase[Phase["Done"] = 2] = "Done";
})(Phase || (Phase = {}));
export var IteratorSynchronizer = function () {
    function IteratorSynchronizer(_ref) {
        var target = _ref.target,
            artifacts = _ref.artifacts;

        _classCallCheck(this, IteratorSynchronizer);

        this.target = target;
        this.artifacts = artifacts;
        this.iterator = artifacts.iterate();
        this.current = artifacts.head();
    }

    IteratorSynchronizer.prototype.sync = function sync() {
        var phase = Phase.Append;
        while (true) {
            switch (phase) {
                case Phase.Append:
                    phase = this.nextAppend();
                    break;
                case Phase.Prune:
                    phase = this.nextPrune();
                    break;
                case Phase.Done:
                    this.nextDone();
                    return;
            }
        }
    };

    IteratorSynchronizer.prototype.advanceToKey = function advanceToKey(key) {
        var current = this.current,
            artifacts = this.artifacts;

        var seek = current;
        while (seek && seek.key !== key) {
            seek.seen = true;
            seek = artifacts.nextNode(seek);
        }
        this.current = seek && artifacts.nextNode(seek);
    };

    IteratorSynchronizer.prototype.nextAppend = function nextAppend() {
        var iterator = this.iterator,
            current = this.current,
            artifacts = this.artifacts;

        var item = iterator.next();
        if (item === null) {
            return this.startPrune();
        }
        var key = item.key;

        if (current && current.key === key) {
            this.nextRetain(item);
        } else if (artifacts.has(key)) {
            this.nextMove(item);
        } else {
            this.nextInsert(item);
        }
        return Phase.Append;
    };

    IteratorSynchronizer.prototype.nextRetain = function nextRetain(item) {
        var artifacts = this.artifacts,
            current = this.current;

        current = current;
        current.update(item);
        this.current = artifacts.nextNode(current);
        this.target.retain(item.key, current.value, current.memo);
    };

    IteratorSynchronizer.prototype.nextMove = function nextMove(item) {
        var current = this.current,
            artifacts = this.artifacts,
            target = this.target;
        var key = item.key;

        var found = artifacts.get(item.key);
        found.update(item);
        if (artifacts.wasSeen(item.key)) {
            artifacts.move(found, current);
            target.move(found.key, found.value, found.memo, current ? current.key : null);
        } else {
            this.advanceToKey(key);
        }
    };

    IteratorSynchronizer.prototype.nextInsert = function nextInsert(item) {
        var artifacts = this.artifacts,
            target = this.target,
            current = this.current;

        var node = artifacts.insertBefore(item, current);
        target.insert(node.key, node.value, node.memo, current ? current.key : null);
    };

    IteratorSynchronizer.prototype.startPrune = function startPrune() {
        this.current = this.artifacts.head();
        return Phase.Prune;
    };

    IteratorSynchronizer.prototype.nextPrune = function nextPrune() {
        var artifacts = this.artifacts,
            target = this.target,
            current = this.current;

        if (current === null) {
            return Phase.Done;
        }
        var node = current;
        this.current = artifacts.nextNode(node);
        if (node.shouldRemove()) {
            artifacts.remove(node);
            target.delete(node.key);
        } else {
            node.reset();
        }
        return Phase.Prune;
    };

    IteratorSynchronizer.prototype.nextDone = function nextDone() {
        this.target.done();
    };

    return IteratorSynchronizer;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9pdGVyYWJsZS5qcyJdLCJuYW1lcyI6WyJMaW5rZWRMaXN0IiwiTGlzdE5vZGUiLCJkaWN0IiwiTGlzdEl0ZW0iLCJpdGVyYWJsZSIsInJlc3VsdCIsInZhbHVlUmVmZXJlbmNlRm9yIiwicmV0YWluZWQiLCJzZWVuIiwia2V5IiwibWVtbyIsIm1lbW9SZWZlcmVuY2VGb3IiLCJ1cGRhdGUiLCJpdGVtIiwidXBkYXRlVmFsdWVSZWZlcmVuY2UiLCJ2YWx1ZSIsInVwZGF0ZU1lbW9SZWZlcmVuY2UiLCJzaG91bGRSZW1vdmUiLCJyZXNldCIsIkl0ZXJhdGlvbkFydGlmYWN0cyIsIm1hcCIsImxpc3QiLCJ0YWciLCJpc0VtcHR5IiwiaXRlcmF0b3IiLCJpdGVyYXRlIiwiaGFzIiwiZ2V0Iiwid2FzU2VlbiIsIm5vZGUiLCJhcHBlbmQiLCJpbnNlcnRCZWZvcmUiLCJyZWZlcmVuY2UiLCJtb3ZlIiwicmVtb3ZlIiwibmV4dE5vZGUiLCJoZWFkIiwiUmVmZXJlbmNlSXRlcmF0b3IiLCJhcnRpZmFjdHMiLCJuZXh0IiwiUGhhc2UiLCJJdGVyYXRvclN5bmNocm9uaXplciIsInRhcmdldCIsImN1cnJlbnQiLCJzeW5jIiwicGhhc2UiLCJBcHBlbmQiLCJuZXh0QXBwZW5kIiwiUHJ1bmUiLCJuZXh0UHJ1bmUiLCJEb25lIiwibmV4dERvbmUiLCJhZHZhbmNlVG9LZXkiLCJzZWVrIiwic3RhcnRQcnVuZSIsIm5leHRSZXRhaW4iLCJuZXh0TW92ZSIsIm5leHRJbnNlcnQiLCJyZXRhaW4iLCJmb3VuZCIsImluc2VydCIsImRlbGV0ZSIsImRvbmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsU0FBU0EsVUFBVCxFQUFxQkMsUUFBckIsRUFBK0JDLElBQS9CLFFBQW1ELGVBQW5EO0FBQ0EsV0FBYUMsUUFBYjtBQUFBOztBQUNJLHNCQUFZQyxRQUFaLEVBQXNCQyxNQUF0QixFQUE4QjtBQUFBOztBQUFBLHFEQUMxQixxQkFBTUQsU0FBU0UsaUJBQVQsQ0FBMkJE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LElBQWpCO0FBQ0FhLG1CQUFPbUIsTUFBUCxDQUFjaEMsS0FBS3BCLEdBQW5CO0FBQ0gsU0FIRCxNQUdPO0FBQ0hvQixpQkFBS1gsS0FBTDtBQUNIO0FBQ0QsZUFBT3NCLE1BQU1RLEtBQWI7QUFDSCxLQTFGTDs7QUFBQSxtQ0EyRklHLFFBM0ZKLHVCQTJGZTtBQUNQLGFBQUtULE1BQUwsQ0FBWW9CLElBQVo7QUFDSCxLQTdGTDs7QUFBQTtBQUFBIiwiZmlsZSI6ImxpYi9pdGVyYWJsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpbmtlZExpc3QsIExpc3ROb2RlLCBkaWN0LCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmV4cG9ydCBjbGFzcyBMaXN0SXRlbSBleHRlbmRzIExpc3ROb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyYWJsZSwgcmVzdWx0KSB7XG4gICAgICAgIHN1cGVyKGl0ZXJhYmxlLnZhbHVlUmVmZXJlbmNlRm9yKHJlc3VsdCkpO1xuICAgICAgICB0aGlzLnJldGFpbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmtleSA9IHJlc3VsdC5rZXk7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICAgICAgdGhpcy5tZW1vID0gaXRlcmFibGUubWVtb1JlZmVyZW5jZUZvcihyZXN1bHQpO1xuICAgIH1cbiAgICB1cGRhdGUoaXRlbSkge1xuICAgICAgICB0aGlzLnJldGFpbmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZS51cGRhdGVWYWx1ZVJlZmVyZW5jZSh0aGlzLnZhbHVlLCBpdGVtKTtcbiAgICAgICAgdGhpcy5pdGVyYWJsZS51cGRhdGVNZW1vUmVmZXJlbmNlKHRoaXMubWVtbywgaXRlbSk7XG4gICAgfVxuICAgIHNob3VsZFJlbW92ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnJldGFpbmVkO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5yZXRhaW5lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlZW4gPSBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSXRlcmF0aW9uQXJ0aWZhY3RzIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVyYWJsZSkge1xuICAgICAgICB0aGlzLm1hcCA9IGRpY3QoKTtcbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgdGhpcy50YWcgPSBpdGVyYWJsZS50YWc7XG4gICAgICAgIHRoaXMuaXRlcmFibGUgPSBpdGVyYWJsZTtcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvciA9IHRoaXMuaXRlcmFibGUuaXRlcmF0ZSgpO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3IuaXNFbXB0eSgpO1xuICAgIH1cbiAgICBpdGVyYXRlKCkge1xuICAgICAgICBsZXQgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yIHx8IHRoaXMuaXRlcmFibGUuaXRlcmF0ZSgpO1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMubWFwW2tleV07XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwW2tleV07XG4gICAgfVxuICAgIHdhc1NlZW4oa2V5KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5tYXBba2V5XTtcbiAgICAgICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5zZWVuO1xuICAgIH1cbiAgICBhcHBlbmQoaXRlbSkge1xuICAgICAgICBsZXQgeyBtYXAsIGxpc3QsIGl0ZXJhYmxlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbm9kZSA9IG1hcFtpdGVtLmtleV0gPSBuZXcgTGlzdEl0ZW0oaXRlcmFibGUsIGl0ZW0pO1xuICAgICAgICBsaXN0LmFwcGVuZChub2RlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGluc2VydEJlZm9yZShpdGVtLCByZWZlcmVuY2UpIHtcbiAgICAgICAgbGV0IHsgbWFwLCBsaXN0LCBpdGVyYWJsZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IG5vZGUgPSBtYXBbaXRlbS5rZXldID0gbmV3IExpc3RJdGVtKGl0ZXJhYmxlLCBpdGVtKTtcbiAgICAgICAgbm9kZS5yZXRhaW5lZCA9IHRydWU7XG4gICAgICAgIGxpc3QuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZmVyZW5jZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBtb3ZlKGl0ZW0sIHJlZmVyZW5jZSkge1xuICAgICAgICBsZXQgeyBsaXN0IH0gPSB0aGlzO1xuICAgICAgICBpdGVtLnJldGFpbmVkID0gdHJ1ZTtcbiAgICAgICAgbGlzdC5yZW1vdmUoaXRlbSk7XG4gICAgICAgIGxpc3QuaW5zZXJ0QmVmb3JlKGl0ZW0sIHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIHJlbW92ZShpdGVtKSB7XG4gICAgICAgIGxldCB7IGxpc3QgfSA9IHRoaXM7XG4gICAgICAgIGxpc3QucmVtb3ZlKGl0ZW0pO1xuICAgICAgICBkZWxldGUgdGhpcy5tYXBbaXRlbS5rZXldO1xuICAgIH1cbiAgICBuZXh0Tm9kZShpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QubmV4dE5vZGUoaXRlbSk7XG4gICAgfVxuICAgIGhlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3QuaGVhZCgpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZWZlcmVuY2VJdGVyYXRvciB7XG4gICAgLy8gaWYgYW55b25lIG5lZWRzIHRvIGNvbnN0cnVjdCB0aGlzIG9iamVjdCB3aXRoIHNvbWV0aGluZyBvdGhlciB0aGFuXG4gICAgLy8gYW4gaXRlcmFibGUsIGxldCBAd3ljYXRzIGtub3cuXG4gICAgY29uc3RydWN0b3IoaXRlcmFibGUpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IG51bGw7XG4gICAgICAgIGxldCBhcnRpZmFjdHMgPSBuZXcgSXRlcmF0aW9uQXJ0aWZhY3RzKGl0ZXJhYmxlKTtcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMgPSBhcnRpZmFjdHM7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCB7IGFydGlmYWN0cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IgfHwgYXJ0aWZhY3RzLml0ZXJhdGUoKTtcbiAgICAgICAgbGV0IGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBhcnRpZmFjdHMuYXBwZW5kKGl0ZW0pO1xuICAgIH1cbn1cbnZhciBQaGFzZTtcbihmdW5jdGlvbiAoUGhhc2UpIHtcbiAgICBQaGFzZVtQaGFzZVtcIkFwcGVuZFwiXSA9IDBdID0gXCJBcHBlbmRcIjtcbiAgICBQaGFzZVtQaGFzZVtcIlBydW5lXCJdID0gMV0gPSBcIlBydW5lXCI7XG4gICAgUGhhc2VbUGhhc2VbXCJEb25lXCJdID0gMl0gPSBcIkRvbmVcIjtcbn0pKFBoYXNlIHx8IChQaGFzZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgSXRlcmF0b3JTeW5jaHJvbml6ZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgdGFyZ2V0LCBhcnRpZmFjdHMgfSkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5hcnRpZmFjdHMgPSBhcnRpZmFjdHM7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBhcnRpZmFjdHMuaXRlcmF0ZSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBhcnRpZmFjdHMuaGVhZCgpO1xuICAgIH1cbiAgICBzeW5jKCkge1xuICAgICAgICBsZXQgcGhhc2UgPSBQaGFzZS5BcHBlbmQ7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBQaGFzZS5BcHBlbmQ6XG4gICAgICAgICAgICAgICAgICAgIHBoYXNlID0gdGhpcy5uZXh0QXBwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGhhc2UuUHJ1bmU6XG4gICAgICAgICAgICAgICAgICAgIHBoYXNlID0gdGhpcy5uZXh0UHJ1bmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBQaGFzZS5Eb25lOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHREb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZHZhbmNlVG9LZXkoa2V5KSB7XG4gICAgICAgIGxldCB7IGN1cnJlbnQsIGFydGlmYWN0cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlZWsgPSBjdXJyZW50O1xuICAgICAgICB3aGlsZSAoc2VlayAmJiBzZWVrLmtleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICBzZWVrLnNlZW4gPSB0cnVlO1xuICAgICAgICAgICAgc2VlayA9IGFydGlmYWN0cy5uZXh0Tm9kZShzZWVrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBzZWVrICYmIGFydGlmYWN0cy5uZXh0Tm9kZShzZWVrKTtcbiAgICB9XG4gICAgbmV4dEFwcGVuZCgpIHtcbiAgICAgICAgbGV0IHsgaXRlcmF0b3IsIGN1cnJlbnQsIGFydGlmYWN0cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFBydW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsga2V5IH0gPSBpdGVtO1xuICAgICAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICB0aGlzLm5leHRSZXRhaW4oaXRlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJ0aWZhY3RzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRNb3ZlKGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0SW5zZXJ0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQaGFzZS5BcHBlbmQ7XG4gICAgfVxuICAgIG5leHRSZXRhaW4oaXRlbSkge1xuICAgICAgICBsZXQgeyBhcnRpZmFjdHMsIGN1cnJlbnQgfSA9IHRoaXM7XG4gICAgICAgIGN1cnJlbnQgPSBleHBlY3QoY3VycmVudCwgJ0JVRzogY3VycmVudCBpcyBlbXB0eScpO1xuICAgICAgICBjdXJyZW50LnVwZGF0ZShpdGVtKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gYXJ0aWZhY3RzLm5leHROb2RlKGN1cnJlbnQpO1xuICAgICAgICB0aGlzLnRhcmdldC5yZXRhaW4oaXRlbS5rZXksIGN1cnJlbnQudmFsdWUsIGN1cnJlbnQubWVtbyk7XG4gICAgfVxuICAgIG5leHRNb3ZlKGl0ZW0pIHtcbiAgICAgICAgbGV0IHsgY3VycmVudCwgYXJ0aWZhY3RzLCB0YXJnZXQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGtleSB9ID0gaXRlbTtcbiAgICAgICAgbGV0IGZvdW5kID0gYXJ0aWZhY3RzLmdldChpdGVtLmtleSk7XG4gICAgICAgIGZvdW5kLnVwZGF0ZShpdGVtKTtcbiAgICAgICAgaWYgKGFydGlmYWN0cy53YXNTZWVuKGl0ZW0ua2V5KSkge1xuICAgICAgICAgICAgYXJ0aWZhY3RzLm1vdmUoZm91bmQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgdGFyZ2V0Lm1vdmUoZm91bmQua2V5LCBmb3VuZC52YWx1ZSwgZm91bmQubWVtbywgY3VycmVudCA/IGN1cnJlbnQua2V5IDogbnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFkdmFuY2VUb0tleShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5leHRJbnNlcnQoaXRlbSkge1xuICAgICAgICBsZXQgeyBhcnRpZmFjdHMsIHRhcmdldCwgY3VycmVudCB9ID0gdGhpcztcbiAgICAgICAgbGV0IG5vZGUgPSBhcnRpZmFjdHMuaW5zZXJ0QmVmb3JlKGl0ZW0sIGN1cnJlbnQpO1xuICAgICAgICB0YXJnZXQuaW5zZXJ0KG5vZGUua2V5LCBub2RlLnZhbHVlLCBub2RlLm1lbW8sIGN1cnJlbnQgPyBjdXJyZW50LmtleSA6IG51bGwpO1xuICAgIH1cbiAgICBzdGFydFBydW5lKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmFydGlmYWN0cy5oZWFkKCk7XG4gICAgICAgIHJldHVybiBQaGFzZS5QcnVuZTtcbiAgICB9XG4gICAgbmV4dFBydW5lKCkge1xuICAgICAgICBsZXQgeyBhcnRpZmFjdHMsIHRhcmdldCwgY3VycmVudCB9ID0gdGhpcztcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQaGFzZS5Eb25lO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gYXJ0aWZhY3RzLm5leHROb2RlKG5vZGUpO1xuICAgICAgICBpZiAobm9kZS5zaG91bGRSZW1vdmUoKSkge1xuICAgICAgICAgICAgYXJ0aWZhY3RzLnJlbW92ZShub2RlKTtcbiAgICAgICAgICAgIHRhcmdldC5kZWxldGUobm9kZS5rZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQaGFzZS5QcnVuZTtcbiAgICB9XG4gICAgbmV4dERvbmUoKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0LmRvbmUoKTtcbiAgICB9XG59Il19