import Reference, { PathReference } from './reference';
import { Opaque, Slice, LinkedListNode } from '@glimmer/util';
export interface EntityTag<T> extends Reference<T> {
    value(): T;
    validate(snapshot: T): boolean;
}
export interface EntityTagged<T> {
    tag: EntityTag<T>;
}
export interface Tagged {
    tag: Tag;
}
export declare type Revision = number;
export declare const CONSTANT: Revision;
export declare const INITIAL: Revision;
export declare const VOLATILE: Revision;
export declare abstract class RevisionTag implements EntityTag<Revision> {
    static id: number;
    abstract value(): Revision;
    validate(snapshot: Revision): boolean;
}
export declare class TagWrapper<T extends RevisionTag | null> {
    private type;
    inner: T;
    constructor(type: number, inner: T);
    value(): Revision;
    validate(snapshot: Revision): boolean;
}
export declare type Tag = TagWrapper<RevisionTag | null>;
export declare const CONSTANT_TAG: TagWrapper<any>;
export declare const VOLATILE_TAG: TagWrapper<any>;
export declare const CURRENT_TAG: TagWrapper<any>;
export declare class DirtyableTag extends RevisionTag {
    static create(revision?: number): TagWrapper<DirtyableTag>;
    private revision;
    constructor(revision?: number);
    value(): Revision;
    dirty(): void;
}
export declare function combineTagged(tagged: ReadonlyArray<{
    tag: Tag;
}>): Tag;
export declare function combineSlice(slice: Slice<{
    tag: Tag;
} & LinkedListNode>): Tag;
export declare function combine(tags: Tag[]): Tag;
export declare abstract class CachedTag extends RevisionTag {
    private lastChecked;
    private lastValue;
    value(): Revision;
    protected invalidate(): void;
    protected abstract compute(): Revision;
}
export declare class UpdatableTag extends CachedTag {
    static create(tag: Tag): TagWrapper<UpdatableTag>;
    private tag;
    private lastUpdated;
    private constructor(tag);
    protected compute(): Revision;
    update(tag: Tag): void;
}
export interface VersionedReference<T> extends Reference<T>, Tagged {
}
export interface VersionedPathReference<T> extends PathReference<T>, Tagged {
    get(property: string): VersionedPathReference<Opaque>;
}
export declare abstract class CachedReference<T> implements VersionedReference<T> {
    abstract tag: Tag;
    private lastRevision;
    private lastValue;
    value(): T;
    protected abstract compute(): T;
    protected invalidate(): void;
}
export declare type Mapper<T, U> = (value: T) => U;
export declare function map<T, U>(reference: VersionedReference<T>, mapper: Mapper<T, U>): VersionedReference<U>;
export declare class ReferenceCache<T> implements Tagged {
    tag: Tag;
    private reference;
    private lastValue;
    private lastRevision;
    private initialized;
    constructor(reference: VersionedReference<T>);
    peek(): T;
    revalidate(): Validation<T>;
    private initialize();
}
export declare type Validation<T> = T | NotModified;
export declare type NotModified = "adb3b78e-3d22-4e4b-877a-6317c2c5c145";
export declare function isModified<T>(value: Validation<T>): value is T;
