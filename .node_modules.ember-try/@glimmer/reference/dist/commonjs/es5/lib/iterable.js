"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IteratorSynchronizer = exports.ReferenceIterator = exports.IterationArtifacts = exports.ListItem = undefined;

var _util = require("@glimmer/util");

function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);for (var i = 0; i < keys.length; i++) {
        var key = keys[i];var value = Object.getOwnPropertyDescriptor(defaults, key);if (value && value.configurable && obj[key] === undefined) {
            Object.defineProperty(obj, key, value);
        }
    }return obj;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
}

var ListItem = exports.ListItem = function (_ListNode) {
    _inherits(ListItem, _ListNode);

    function ListItem(iterable, result) {
        _classCallCheck(this, ListItem);

        var _this = _possibleConstructorReturn(this, _ListNode.call(this, iterable.valueReferenceFor(result)));

        _this.retained = false;
        _this.seen = false;
        _this.key = result.key;
        _this.iterable = iterable;
        _this.memo = iterable.memoReferenceFor(result);
        return _this;
    }

    ListItem.prototype.update = function update(item) {
        this.retained = true;
        this.iterable.updateValueReference(this.value, item);
        this.iterable.updateMemoReference(this.memo, item);
    };

    ListItem.prototype.shouldRemove = function shouldRemove() {
        return !this.retained;
    };

    ListItem.prototype.reset = function reset() {
        this.retained = false;
        this.seen = false;
    };

    return ListItem;
}(_util.ListNode);
var IterationArtifacts = exports.IterationArtifacts = function () {
    function IterationArtifacts(iterable) {
        _classCallCheck(this, IterationArtifacts);

        this.map = (0, _util.dict)();
        this.list = new _util.LinkedList();
        this.tag = iterable.tag;
        this.iterable = iterable;
    }

    IterationArtifacts.prototype.isEmpty = function isEmpty() {
        var iterator = this.iterator = this.iterable.iterate();
        return iterator.isEmpty();
    };

    IterationArtifacts.prototype.iterate = function iterate() {
        var iterator = this.iterator || this.iterable.iterate();
        this.iterator = null;
        return iterator;
    };

    IterationArtifacts.prototype.has = function has(key) {
        return !!this.map[key];
    };

    IterationArtifacts.prototype.get = function get(key) {
        return this.map[key];
    };

    IterationArtifacts.prototype.wasSeen = function wasSeen(key) {
        var node = this.map[key];
        return node && node.seen;
    };

    IterationArtifacts.prototype.append = function append(item) {
        var map = this.map,
            list = this.list,
            iterable = this.iterable;

        var node = map[item.key] = new ListItem(iterable, item);
        list.append(node);
        return node;
    };

    IterationArtifacts.prototype.insertBefore = function insertBefore(item, reference) {
        var map = this.map,
            list = this.list,
            iterable = this.iterable;

        var node = map[item.key] = new ListItem(iterable, item);
        node.retained = true;
        list.insertBefore(node, reference);
        return node;
    };

    IterationArtifacts.prototype.move = function move(item, reference) {
        var list = this.list;

        item.retained = true;
        list.remove(item);
        list.insertBefore(item, reference);
    };

    IterationArtifacts.prototype.remove = function remove(item) {
        var list = this.list;

        list.remove(item);
        delete this.map[item.key];
    };

    IterationArtifacts.prototype.nextNode = function nextNode(item) {
        return this.list.nextNode(item);
    };

    IterationArtifacts.prototype.head = function head() {
        return this.list.head();
    };

    return IterationArtifacts;
}();
var ReferenceIterator = exports.ReferenceIterator = function () {
    // if anyone needs to construct this object with something other than
    // an iterable, let @wycats know.
    function ReferenceIterator(iterable) {
        _classCallCheck(this, ReferenceIterator);

        this.iterator = null;
        var artifacts = new IterationArtifacts(iterable);
        this.artifacts = artifacts;
    }

    ReferenceIterator.prototype.next = function next() {
        var artifacts = this.artifacts;

        var iterator = this.iterator = this.iterator || artifacts.iterate();
        var item = iterator.next();
        if (!item) return null;
        return artifacts.append(item);
    };

    return ReferenceIterator;
}();
var Phase;
(function (Phase) {
    Phase[Phase["Append"] = 0] = "Append";
    Phase[Phase["Prune"] = 1] = "Prune";
    Phase[Phase["Done"] = 2] = "Done";
})(Phase || (Phase = {}));
var IteratorSynchronizer = exports.IteratorSynchronizer = function () {
    function IteratorSynchronizer(_ref) {
        var target = _ref.target,
            artifacts = _ref.artifacts;

        _classCallCheck(this, IteratorSynchronizer);

        this.target = target;
        this.artifacts = artifacts;
        this.iterator = artifacts.iterate();
        this.current = artifacts.head();
    }

    IteratorSynchronizer.prototype.sync = function sync() {
        var phase = Phase.Append;
        while (true) {
            switch (phase) {
                case Phase.Append:
                    phase = this.nextAppend();
                    break;
                case Phase.Prune:
                    phase = this.nextPrune();
                    break;
                case Phase.Done:
                    this.nextDone();
                    return;
            }
        }
    };

    IteratorSynchronizer.prototype.advanceToKey = function advanceToKey(key) {
        var current = this.current,
            artifacts = this.artifacts;

        var seek = current;
        while (seek && seek.key !== key) {
            seek.seen = true;
            seek = artifacts.nextNode(seek);
        }
        this.current = seek && artifacts.nextNode(seek);
    };

    IteratorSynchronizer.prototype.nextAppend = function nextAppend() {
        var iterator = this.iterator,
            current = this.current,
            artifacts = this.artifacts;

        var item = iterator.next();
        if (item === null) {
            return this.startPrune();
        }
        var key = item.key;

        if (current && current.key === key) {
            this.nextRetain(item);
        } else if (artifacts.has(key)) {
            this.nextMove(item);
        } else {
            this.nextInsert(item);
        }
        return Phase.Append;
    };

    IteratorSynchronizer.prototype.nextRetain = function nextRetain(item) {
        var artifacts = this.artifacts,
            current = this.current;

        current = current;
        current.update(item);
        this.current = artifacts.nextNode(current);
        this.target.retain(item.key, current.value, current.memo);
    };

    IteratorSynchronizer.prototype.nextMove = function nextMove(item) {
        var current = this.current,
            artifacts = this.artifacts,
            target = this.target;
        var key = item.key;

        var found = artifacts.get(item.key);
        found.update(item);
        if (artifacts.wasSeen(item.key)) {
            artifacts.move(found, current);
            target.move(found.key, found.value, found.memo, current ? current.key : null);
        } else {
            this.advanceToKey(key);
        }
    };

    IteratorSynchronizer.prototype.nextInsert = function nextInsert(item) {
        var artifacts = this.artifacts,
            target = this.target,
            current = this.current;

        var node = artifacts.insertBefore(item, current);
        target.insert(node.key, node.value, node.memo, current ? current.key : null);
    };

    IteratorSynchronizer.prototype.startPrune = function startPrune() {
        this.current = this.artifacts.head();
        return Phase.Prune;
    };

    IteratorSynchronizer.prototype.nextPrune = function nextPrune() {
        var artifacts = this.artifacts,
            target = this.target,
            current = this.current;

        if (current === null) {
            return Phase.Done;
        }
        var node = current;
        this.current = artifacts.nextNode(node);
        if (node.shouldRemove()) {
            artifacts.remove(node);
            target.delete(node.key);
        } else {
            node.reset();
        }
        return Phase.Prune;
    };

    IteratorSynchronizer.prototype.nextDone = function nextDone() {
        this.target.done();
    };

    return IteratorSynchronizer;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9pdGVyYWJsZS5qcyJdLCJuYW1lcyI6WyJMaW5rZWRMaXN0IiwiTGlzdE5vZGUiLCJkaWN0IiwiTGlzdEl0ZW0iLCJpdGVyYWJsZSIsInJlc3VsdCIsInZhbHVlUmVmZXJlbmNlRm9yIiwicmV0YWluZWQiLCJzZWVuIiwia2V5IiwibWVtbyIsIm1lbW9SZWZlcmVuY2VGb3IiLCJ1cGRhdGUiLCJpdGVtIiwidXBkYXRlVmFsdWVSZWZlcmVuY2UiLCJ2YWx1ZSIsInVwZGF0ZU1lbW9SZWZlcmVuY2UiLCJzaG91bGRSZW1vdmUiLCJyZXNldCIsIkl0ZXJhdGlvbkFydGlmYWN0cyIsIm1hcCIsImxpc3QiLCJ0YWciLCJpc0VtcHR5IiwiaXRlcmF0b3IiLCJpdGVyYXRlIiwiaGFzIiwiZ2V0Iiwid2FzU2VlbiIsIm5vZGUiLCJhcHBlbmQiLCJpbnNlcnRCZWZvcmUiLCJyZWZlcmVuY2UiLCJtb3ZlIiwicmVtb3ZlIiwibmV4dE5vZGUiLCJoZWFkIiwiUmVmZXJlbmNlSXRlcmF0b3IiLCJhcnRpZmFjdHMiLCJuZXh0IiwiUGhhc2UiLCJJdGVyYXRvclN5bmNocm9uaXplciIsInRhcmdldCIsImN1cnJlbnQiLCJzeW5jIiwicGhhc2UiLCJBcHBlbmQiLCJuZXh0QXBwZW5kIiwiUHJ1bmUiLCJuZXh0UHJ1bmUiLCJEb25lIiwibmV4dERvbmUiLCJhZHZhbmNlVG9LZXkiLCJzZWVrIiwic3RhcnRQcnVuZSIsIm5leHRSZXRhaW4iLCJuZXh0TW92ZSIsIm5leHRJbnNlcnQiLCJyZXRhaW4iLCJmb3VuZCIsImluc2VydCIsImRlbGV0ZSIsImRvbmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxBQUFTLEFBQVksQUFBVSxBQUFvQixBQUNuRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUFBLEFBQWEsbURBQWI7d0JBQ0k7O3NCQUFBLEFBQVksVUFBWixBQUFzQixRQUFROzhCQUFBOztxREFDMUIscUJBQU0sU0FBQSxBQUFTLGtCQURXLEFBQzFCLEFBQU0s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T0FBSixBQUFXLEFBQ1g7YUFBQSxBQUFLLFVBQVUsVUFBQSxBQUFVLFNBQXpCLEFBQWUsQUFBbUIsQUFDbEM7WUFBSSxLQUFKLEFBQUksQUFBSyxnQkFBZ0IsQUFDckI7c0JBQUEsQUFBVSxPQUFWLEFBQWlCLEFBQ2pCO21CQUFBLEFBQU8sT0FBTyxLQUFkLEFBQW1CLEFBQ3RCO0FBSEQsZUFHTyxBQUNIO2lCQUFBLEFBQUssQUFDUjtBQUNEO2VBQU8sTUFBUCxBQUFhLEFBQ2hCO0FBMUZMOzttQ0FBQSxBQTJGSSwrQkFBVyxBQUNQO2FBQUEsQUFBSyxPQUFMLEFBQVksQUFDZjtBQTdGTDs7V0FBQSIsImZpbGUiOiJsaWIvaXRlcmFibGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMaW5rZWRMaXN0LCBMaXN0Tm9kZSwgZGljdCwgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5leHBvcnQgY2xhc3MgTGlzdEl0ZW0gZXh0ZW5kcyBMaXN0Tm9kZSB7XG4gICAgY29uc3RydWN0b3IoaXRlcmFibGUsIHJlc3VsdCkge1xuICAgICAgICBzdXBlcihpdGVyYWJsZS52YWx1ZVJlZmVyZW5jZUZvcihyZXN1bHQpKTtcbiAgICAgICAgdGhpcy5yZXRhaW5lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5rZXkgPSByZXN1bHQua2V5O1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgICAgIHRoaXMubWVtbyA9IGl0ZXJhYmxlLm1lbW9SZWZlcmVuY2VGb3IocmVzdWx0KTtcbiAgICB9XG4gICAgdXBkYXRlKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5yZXRhaW5lZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXRlcmFibGUudXBkYXRlVmFsdWVSZWZlcmVuY2UodGhpcy52YWx1ZSwgaXRlbSk7XG4gICAgICAgIHRoaXMuaXRlcmFibGUudXBkYXRlTWVtb1JlZmVyZW5jZSh0aGlzLm1lbW8sIGl0ZW0pO1xuICAgIH1cbiAgICBzaG91bGRSZW1vdmUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5yZXRhaW5lZDtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmV0YWluZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWVuID0gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEl0ZXJhdGlvbkFydGlmYWN0cyB7XG4gICAgY29uc3RydWN0b3IoaXRlcmFibGUpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBkaWN0KCk7XG4gICAgICAgIHRoaXMubGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgICAgIHRoaXMudGFnID0gaXRlcmFibGUudGFnO1xuICAgICAgICB0aGlzLml0ZXJhYmxlID0gaXRlcmFibGU7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGxldCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IgPSB0aGlzLml0ZXJhYmxlLml0ZXJhdGUoKTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLmlzRW1wdHkoKTtcbiAgICB9XG4gICAgaXRlcmF0ZSgpIHtcbiAgICAgICAgbGV0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvciB8fCB0aGlzLml0ZXJhYmxlLml0ZXJhdGUoKTtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IG51bGw7XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLm1hcFtrZXldO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcFtrZXldO1xuICAgIH1cbiAgICB3YXNTZWVuKGtleSkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMubWFwW2tleV07XG4gICAgICAgIHJldHVybiBub2RlICYmIG5vZGUuc2VlbjtcbiAgICB9XG4gICAgYXBwZW5kKGl0ZW0pIHtcbiAgICAgICAgbGV0IHsgbWFwLCBsaXN0LCBpdGVyYWJsZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IG5vZGUgPSBtYXBbaXRlbS5rZXldID0gbmV3IExpc3RJdGVtKGl0ZXJhYmxlLCBpdGVtKTtcbiAgICAgICAgbGlzdC5hcHBlbmQobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBpbnNlcnRCZWZvcmUoaXRlbSwgcmVmZXJlbmNlKSB7XG4gICAgICAgIGxldCB7IG1hcCwgbGlzdCwgaXRlcmFibGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBub2RlID0gbWFwW2l0ZW0ua2V5XSA9IG5ldyBMaXN0SXRlbShpdGVyYWJsZSwgaXRlbSk7XG4gICAgICAgIG5vZGUucmV0YWluZWQgPSB0cnVlO1xuICAgICAgICBsaXN0Lmluc2VydEJlZm9yZShub2RlLCByZWZlcmVuY2UpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbW92ZShpdGVtLCByZWZlcmVuY2UpIHtcbiAgICAgICAgbGV0IHsgbGlzdCB9ID0gdGhpcztcbiAgICAgICAgaXRlbS5yZXRhaW5lZCA9IHRydWU7XG4gICAgICAgIGxpc3QucmVtb3ZlKGl0ZW0pO1xuICAgICAgICBsaXN0Lmluc2VydEJlZm9yZShpdGVtLCByZWZlcmVuY2UpO1xuICAgIH1cbiAgICByZW1vdmUoaXRlbSkge1xuICAgICAgICBsZXQgeyBsaXN0IH0gPSB0aGlzO1xuICAgICAgICBsaXN0LnJlbW92ZShpdGVtKTtcbiAgICAgICAgZGVsZXRlIHRoaXMubWFwW2l0ZW0ua2V5XTtcbiAgICB9XG4gICAgbmV4dE5vZGUoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0Lm5leHROb2RlKGl0ZW0pO1xuICAgIH1cbiAgICBoZWFkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmhlYWQoKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVmZXJlbmNlSXRlcmF0b3Ige1xuICAgIC8vIGlmIGFueW9uZSBuZWVkcyB0byBjb25zdHJ1Y3QgdGhpcyBvYmplY3Qgd2l0aCBzb21ldGhpbmcgb3RoZXIgdGhhblxuICAgIC8vIGFuIGl0ZXJhYmxlLCBsZXQgQHd5Y2F0cyBrbm93LlxuICAgIGNvbnN0cnVjdG9yKGl0ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBudWxsO1xuICAgICAgICBsZXQgYXJ0aWZhY3RzID0gbmV3IEl0ZXJhdGlvbkFydGlmYWN0cyhpdGVyYWJsZSk7XG4gICAgICAgIHRoaXMuYXJ0aWZhY3RzID0gYXJ0aWZhY3RzO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICBsZXQgeyBhcnRpZmFjdHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yIHx8IGFydGlmYWN0cy5pdGVyYXRlKCk7XG4gICAgICAgIGxldCBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gYXJ0aWZhY3RzLmFwcGVuZChpdGVtKTtcbiAgICB9XG59XG52YXIgUGhhc2U7XG4oZnVuY3Rpb24gKFBoYXNlKSB7XG4gICAgUGhhc2VbUGhhc2VbXCJBcHBlbmRcIl0gPSAwXSA9IFwiQXBwZW5kXCI7XG4gICAgUGhhc2VbUGhhc2VbXCJQcnVuZVwiXSA9IDFdID0gXCJQcnVuZVwiO1xuICAgIFBoYXNlW1BoYXNlW1wiRG9uZVwiXSA9IDJdID0gXCJEb25lXCI7XG59KShQaGFzZSB8fCAoUGhhc2UgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIEl0ZXJhdG9yU3luY2hyb25pemVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHRhcmdldCwgYXJ0aWZhY3RzIH0pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuYXJ0aWZhY3RzID0gYXJ0aWZhY3RzO1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gYXJ0aWZhY3RzLml0ZXJhdGUoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gYXJ0aWZhY3RzLmhlYWQoKTtcbiAgICB9XG4gICAgc3luYygpIHtcbiAgICAgICAgbGV0IHBoYXNlID0gUGhhc2UuQXBwZW5kO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgc3dpdGNoIChwaGFzZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgUGhhc2UuQXBwZW5kOlxuICAgICAgICAgICAgICAgICAgICBwaGFzZSA9IHRoaXMubmV4dEFwcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFBoYXNlLlBydW5lOlxuICAgICAgICAgICAgICAgICAgICBwaGFzZSA9IHRoaXMubmV4dFBydW5lKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUGhhc2UuRG9uZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0RG9uZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWR2YW5jZVRvS2V5KGtleSkge1xuICAgICAgICBsZXQgeyBjdXJyZW50LCBhcnRpZmFjdHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWVrID0gY3VycmVudDtcbiAgICAgICAgd2hpbGUgKHNlZWsgJiYgc2Vlay5rZXkgIT09IGtleSkge1xuICAgICAgICAgICAgc2Vlay5zZWVuID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlZWsgPSBhcnRpZmFjdHMubmV4dE5vZGUoc2Vlayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gc2VlayAmJiBhcnRpZmFjdHMubmV4dE5vZGUoc2Vlayk7XG4gICAgfVxuICAgIG5leHRBcHBlbmQoKSB7XG4gICAgICAgIGxldCB7IGl0ZXJhdG9yLCBjdXJyZW50LCBhcnRpZmFjdHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoaXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQcnVuZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGtleSB9ID0gaXRlbTtcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0UmV0YWluKGl0ZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGFydGlmYWN0cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0TW92ZShpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dEluc2VydChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGhhc2UuQXBwZW5kO1xuICAgIH1cbiAgICBuZXh0UmV0YWluKGl0ZW0pIHtcbiAgICAgICAgbGV0IHsgYXJ0aWZhY3RzLCBjdXJyZW50IH0gPSB0aGlzO1xuICAgICAgICBjdXJyZW50ID0gZXhwZWN0KGN1cnJlbnQsICdCVUc6IGN1cnJlbnQgaXMgZW1wdHknKTtcbiAgICAgICAgY3VycmVudC51cGRhdGUoaXRlbSk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGFydGlmYWN0cy5uZXh0Tm9kZShjdXJyZW50KTtcbiAgICAgICAgdGhpcy50YXJnZXQucmV0YWluKGl0ZW0ua2V5LCBjdXJyZW50LnZhbHVlLCBjdXJyZW50Lm1lbW8pO1xuICAgIH1cbiAgICBuZXh0TW92ZShpdGVtKSB7XG4gICAgICAgIGxldCB7IGN1cnJlbnQsIGFydGlmYWN0cywgdGFyZ2V0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBrZXkgfSA9IGl0ZW07XG4gICAgICAgIGxldCBmb3VuZCA9IGFydGlmYWN0cy5nZXQoaXRlbS5rZXkpO1xuICAgICAgICBmb3VuZC51cGRhdGUoaXRlbSk7XG4gICAgICAgIGlmIChhcnRpZmFjdHMud2FzU2VlbihpdGVtLmtleSkpIHtcbiAgICAgICAgICAgIGFydGlmYWN0cy5tb3ZlKGZvdW5kLCBjdXJyZW50KTtcbiAgICAgICAgICAgIHRhcmdldC5tb3ZlKGZvdW5kLmtleSwgZm91bmQudmFsdWUsIGZvdW5kLm1lbW8sIGN1cnJlbnQgPyBjdXJyZW50LmtleSA6IG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZHZhbmNlVG9LZXkoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZXh0SW5zZXJ0KGl0ZW0pIHtcbiAgICAgICAgbGV0IHsgYXJ0aWZhY3RzLCB0YXJnZXQsIGN1cnJlbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBub2RlID0gYXJ0aWZhY3RzLmluc2VydEJlZm9yZShpdGVtLCBjdXJyZW50KTtcbiAgICAgICAgdGFyZ2V0Lmluc2VydChub2RlLmtleSwgbm9kZS52YWx1ZSwgbm9kZS5tZW1vLCBjdXJyZW50ID8gY3VycmVudC5rZXkgOiBudWxsKTtcbiAgICB9XG4gICAgc3RhcnRQcnVuZSgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5hcnRpZmFjdHMuaGVhZCgpO1xuICAgICAgICByZXR1cm4gUGhhc2UuUHJ1bmU7XG4gICAgfVxuICAgIG5leHRQcnVuZSgpIHtcbiAgICAgICAgbGV0IHsgYXJ0aWZhY3RzLCB0YXJnZXQsIGN1cnJlbnQgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUGhhc2UuRG9uZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGFydGlmYWN0cy5uZXh0Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKG5vZGUuc2hvdWxkUmVtb3ZlKCkpIHtcbiAgICAgICAgICAgIGFydGlmYWN0cy5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICB0YXJnZXQuZGVsZXRlKG5vZGUua2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGhhc2UuUHJ1bmU7XG4gICAgfVxuICAgIG5leHREb25lKCkge1xuICAgICAgICB0aGlzLnRhcmdldC5kb25lKCk7XG4gICAgfVxufSJdfQ==