import { VersionedPathReference } from '@glimmer/reference';
import { Blocks, Inlines } from './syntax/functions';
import { Constants } from './environment/constants';
import * as Simple from './dom/interfaces';
import { DOMChanges, DOMTreeConstruction } from './dom/helper';
import { Reference, OpaqueIterable } from '@glimmer/reference';
import { AttributeManager } from './dom/attribute-managers';
import { PartialDefinition } from './partial';
import { ComponentManager, ComponentDefinition } from './component/interfaces';
import { ModifierManager } from './modifier/interfaces';
import { Dict, Option, Destroyable, Opaque, HasGuid } from '@glimmer/util';
import { TemplateMeta } from '@glimmer/wire-format';
import { Block } from './syntax/interfaces';
import { PublicVM } from './vm/append';
import { IArguments } from './vm/arguments';
export declare type ScopeSlot = VersionedPathReference<Opaque> | Option<Block>;
export interface DynamicScope {
    get(key: string): VersionedPathReference<Opaque>;
    set(key: string, reference: VersionedPathReference<Opaque>): VersionedPathReference<Opaque>;
    child(): DynamicScope;
}
export declare class Scope {
    private slots;
    private callerScope;
    private evalScope;
    private partialMap;
    static root(self: VersionedPathReference<Opaque>, size?: number): Scope;
    static sized(size?: number): Scope;
    constructor(slots: ScopeSlot[], callerScope: Option<Scope>, evalScope: Option<Dict<ScopeSlot>>, partialMap: Option<Dict<VersionedPathReference<Opaque>>>);
    init({self}: {
        self: VersionedPathReference<Opaque>;
    }): this;
    getSelf(): VersionedPathReference<Opaque>;
    getSymbol(symbol: number): VersionedPathReference<Opaque>;
    getBlock(symbol: number): Block;
    getEvalScope(): Option<Dict<ScopeSlot>>;
    getPartialMap(): Option<Dict<VersionedPathReference<Opaque>>>;
    bind(symbol: number, value: ScopeSlot): void;
    bindSelf(self: VersionedPathReference<Opaque>): void;
    bindSymbol(symbol: number, value: VersionedPathReference<Opaque>): void;
    bindBlock(symbol: number, value: Option<Block>): void;
    bindEvalScope(map: Option<Dict<ScopeSlot>>): void;
    bindPartialMap(map: Dict<VersionedPathReference<Opaque>>): void;
    bindCallerScope(scope: Option<Scope>): void;
    getCallerScope(): Option<Scope>;
    child(): Scope;
    private get<T>(index);
    private set<T>(index, value);
}
export declare class Opcode {
    private heap;
    offset: number;
    constructor(heap: Heap);
    readonly type: number;
    readonly op1: number;
    readonly op2: number;
    readonly op3: number;
}
export interface Handle {
    "[is-handle]": true;
}
export declare class Heap {
    private heap;
    private offset;
    private handle;
    /**
     * layout:
     *
     * - pointer into heap
     * - size
     * - freed (0 or 1)
     */
    private table;
    push(item: number): void;
    getbyaddr(address: number): number;
    setbyaddr(address: number, value: number): void;
    malloc(): Handle;
    finishMalloc(handle: Handle): void;
    size(): number;
    getaddr(handle: Handle): number;
    gethandle(address: number): Handle;
    sizeof(handle: Handle): number;
    free(handle: Handle): void;
    compact(): void;
}
export declare class Program {
    [key: number]: never;
    private _opcode;
    constants: Constants;
    heap: Heap;
    constructor();
    opcode(offset: number): Opcode;
}
export declare abstract class Environment {
    protected updateOperations: DOMChanges;
    protected appendOperations: DOMTreeConstruction;
    private _macros;
    private _transaction;
    program: Program;
    constructor({appendOperations, updateOperations}: {
        appendOperations: DOMTreeConstruction;
        updateOperations: DOMChanges;
    });
    toConditionalReference(reference: Reference<Opaque>): Reference<boolean>;
    abstract iterableFor(reference: Reference<Opaque>, key: string): OpaqueIterable;
    abstract protocolForURL(s: string): string;
    getAppendOperations(): DOMTreeConstruction;
    getDOM(): DOMChanges;
    getIdentity(object: HasGuid): string;
    begin(): void;
    private readonly transaction;
    didCreate<T>(component: T, manager: ComponentManager<T>): void;
    didUpdate<T>(component: T, manager: ComponentManager<T>): void;
    scheduleInstallModifier<T>(modifier: T, manager: ModifierManager<T>): void;
    scheduleUpdateModifier<T>(modifier: T, manager: ModifierManager<T>): void;
    didDestroy(d: Destroyable): void;
    commit(): void;
    attributeFor(element: Simple.Element, attr: string, isTrusting: boolean, namespace?: string): AttributeManager;
    macros(): {
        blocks: Blocks;
        inlines: Inlines;
    };
    populateBuiltins(): {
        blocks: Blocks;
        inlines: Inlines;
    };
    abstract hasHelper(helperName: string, meta: TemplateMeta): boolean;
    abstract lookupHelper(helperName: string, meta: TemplateMeta): Helper;
    abstract hasModifier(modifierName: string, meta: TemplateMeta): boolean;
    abstract lookupModifier(modifierName: string, meta: TemplateMeta): ModifierManager<Opaque>;
    abstract hasComponentDefinition(tagName: string, meta: TemplateMeta): boolean;
    abstract getComponentDefinition(tagName: string, meta: TemplateMeta): ComponentDefinition<Opaque>;
    abstract hasPartial(partialName: string, meta: TemplateMeta): boolean;
    abstract lookupPartial(PartialName: string, meta: TemplateMeta): PartialDefinition<TemplateMeta>;
}
export default Environment;
export interface Helper {
    (vm: PublicVM, args: IArguments): VersionedPathReference<Opaque>;
}
