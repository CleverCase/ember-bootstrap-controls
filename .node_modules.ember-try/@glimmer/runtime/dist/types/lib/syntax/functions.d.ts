import { CompilationMeta, Option, ProgramSymbolTable } from '@glimmer/interfaces';
import * as WireFormat from '@glimmer/wire-format';
import { CompiledDynamicProgram } from '../compiled/blocks';
import OpcodeBuilder from '../compiled/opcodes/builder';
import { DynamicInvoker } from '../compiled/opcodes/vm';
import Environment, { Handle } from '../environment';
import { VM } from '../vm';
import { Block } from './interfaces';
export declare type TupleSyntax = WireFormat.Statement | WireFormat.TupleExpression;
export declare type CompilerFunction<T extends TupleSyntax> = ((sexp: T, builder: OpcodeBuilder) => void);
export declare const ATTRS_BLOCK = "&attrs";
import S = WireFormat.Statements;
export declare class InvokeDynamicLayout implements DynamicInvoker<ProgramSymbolTable> {
    private attrs;
    constructor(attrs: Option<Block>);
    invoke(vm: VM, layout: Option<CompiledDynamicProgram>): void;
    toJSON(): {
        GlimmerDebug: string;
    };
}
export declare class PartialInvoker implements DynamicInvoker<ProgramSymbolTable> {
    private outerSymbols;
    private evalInfo;
    constructor(outerSymbols: string[], evalInfo: WireFormat.Core.EvalInfo);
    invoke(vm: VM, _partial: Option<CompiledDynamicProgram>): void;
}
import C = WireFormat.Core;
export declare function expr(expression: WireFormat.Expression, builder: OpcodeBuilder): void;
export declare function compileList(params: Option<WireFormat.Expression[]>, builder: OpcodeBuilder): number;
export declare type BlockMacro = (params: C.Params, hash: C.Hash, template: Option<Block>, inverse: Option<Block>, builder: OpcodeBuilder) => void;
export declare type MissingBlockMacro = (name: string, params: C.Params, hash: C.Hash, template: Option<Block>, inverse: Option<Block>, builder: OpcodeBuilder) => void;
export declare class Blocks {
    private names;
    private funcs;
    private missing;
    add(name: string, func: BlockMacro): void;
    addMissing(func: MissingBlockMacro): void;
    compile(name: string, params: C.Params, hash: C.Hash, template: Option<Block>, inverse: Option<Block>, builder: OpcodeBuilder): void;
}
export declare const BLOCKS: Blocks;
export declare type AppendSyntax = S.Append;
export declare type AppendMacro = (name: string, params: Option<C.Params>, hash: Option<C.Hash>, builder: OpcodeBuilder) => ['expr', WireFormat.Expression] | true | false;
export declare class Inlines {
    private names;
    private funcs;
    private missing;
    add(name: string, func: AppendMacro): void;
    addMissing(func: AppendMacro): void;
    compile(sexp: AppendSyntax, builder: OpcodeBuilder): ['expr', WireFormat.Expression] | true;
}
export declare const INLINES: Inlines;
export declare function populateBuiltins(blocks?: Blocks, inlines?: Inlines): {
    blocks: Blocks;
    inlines: Inlines;
};
export declare function compileStatement(statement: WireFormat.Statement, builder: OpcodeBuilder): void;
export declare function compileStatements(statements: WireFormat.Statement[], meta: CompilationMeta, env: Environment): {
    start: Handle;
    finalize(): Handle;
};
