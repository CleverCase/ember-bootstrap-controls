import { EvaluationStack } from './append';
import { Dict, Opaque } from '@glimmer/interfaces';
import { Tag, VersionedPathReference } from '@glimmer/reference';
export interface IArguments {
    tag: Tag;
    length: number;
    positional: IPositionalArguments;
    named: INamedArguments;
    at<T extends VersionedPathReference<Opaque>>(pos: number): T;
    get<T extends VersionedPathReference<Opaque>>(name: string): T;
    capture(): ICapturedArguments;
}
export interface ICapturedArguments {
    tag: Tag;
    length: number;
    positional: ICapturedPositionalArguments;
    named: ICapturedNamedArguments;
}
export interface IPositionalArguments {
    tag: Tag;
    length: number;
    at<T extends VersionedPathReference<Opaque>>(position: number): T;
    capture(): ICapturedPositionalArguments;
}
export interface ICapturedPositionalArguments extends VersionedPathReference<Opaque[]> {
    tag: Tag;
    length: number;
    references: VersionedPathReference<Opaque>[];
    at<T extends VersionedPathReference<Opaque>>(position: number): T;
    value(): Opaque[];
}
export interface INamedArguments {
    tag: Tag;
    names: string[];
    length: number;
    has(name: string): boolean;
    get<T extends VersionedPathReference<Opaque>>(name: string): T;
    capture(): ICapturedNamedArguments;
}
export interface ICapturedNamedArguments extends VersionedPathReference<Dict<Opaque>> {
    tag: Tag;
    map: Dict<VersionedPathReference<Opaque>>;
    names: string[];
    length: number;
    references: VersionedPathReference<Opaque>[];
    has(name: string): boolean;
    get<T extends VersionedPathReference<Opaque>>(name: string): T;
    value(): Dict<Opaque>;
}
export declare class Arguments implements IArguments {
    private stack;
    positional: IPositionalArguments;
    named: INamedArguments;
    empty(): this;
    setup(stack: EvaluationStack, synthetic: boolean): void;
    readonly tag: Tag;
    readonly length: number;
    at<T extends VersionedPathReference<Opaque>>(pos: number): T;
    get<T extends VersionedPathReference<Opaque>>(name: string): T;
    capture(): ICapturedArguments;
    clear(): void;
}
declare var _default: Arguments;
export default _default;
