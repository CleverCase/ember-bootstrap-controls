import { Register } from '../opcodes';
import { Scope, DynamicScope, Environment, Opcode, Handle, Heap } from '../environment';
import { ElementStack } from '../builder';
import { Destroyable, LinkedList, Opaque } from '@glimmer/util';
import { PathReference, VersionedPathReference } from '@glimmer/reference';
import { CompiledDynamicProgram } from '../compiled/blocks';
import { VMState, ListBlockOpcode, TryOpcode } from './update';
import RenderResult from './render-result';
import { UpdatingOpcode } from '../opcodes';
import { Constants, ConstantString } from '../environment/constants';
export interface PublicVM {
    env: Environment;
    dynamicScope(): DynamicScope;
    getSelf(): PathReference<Opaque>;
    newDestroyable(d: Destroyable): void;
}
export declare type CapturedStack = Opaque[];
export declare class EvaluationStack {
    private stack;
    fp: number;
    sp: number;
    static empty(): EvaluationStack;
    static restore(snapshot: CapturedStack): EvaluationStack;
    constructor(stack: Opaque[], fp: number, sp: number);
    isEmpty(): boolean;
    push(value: Opaque): void;
    dup(position?: number): void;
    pop<T>(n?: number): T;
    peek<T>(): T;
    fromBase<T>(offset: number): T;
    fromTop<T>(offset: number): T;
    capture(items: number): CapturedStack;
    reset(): void;
    toArray(): any[];
}
export declare type IteratorResult<T> = {
    done: false;
    value: null;
} | {
    done: true;
    value: T;
};
export default class VM implements PublicVM {
    env: Environment;
    private elementStack;
    private dynamicScopeStack;
    private scopeStack;
    updatingOpcodeStack: any;
    cacheGroups: any;
    listBlockStack: any;
    constants: Constants;
    heap: Heap;
    stack: EvaluationStack;
    private pc;
    private ra;
    private fp;
    private sp;
    s0: any;
    s1: any;
    t0: any;
    t1: any;
    fetch(register: Register): void;
    load(register: Register): void;
    fetchValue<T>(register: Register): T;
    loadValue<T>(register: Register, value: T): void;
    pushFrame(): void;
    popFrame(): void;
    goto(offset: number): void;
    call(handle: Handle): void;
    returnTo(offset: number): void;
    return(): void;
    static initial(env: Environment, self: PathReference<Opaque>, dynamicScope: DynamicScope, elementStack: ElementStack, program: CompiledDynamicProgram): VM;
    constructor(env: Environment, scope: Scope, dynamicScope: DynamicScope, elementStack: ElementStack);
    capture(args: number): VMState;
    beginCacheGroup(): void;
    commitCacheGroup(): void;
    enter(args: number): void;
    iterate(memo: VersionedPathReference<Opaque>, value: VersionedPathReference<Opaque>): TryOpcode;
    enterItem(key: string, opcode: TryOpcode): void;
    enterList(relativeStart: number): void;
    private didEnter(opcode);
    exit(): void;
    exitList(): void;
    updateWith(opcode: UpdatingOpcode): void;
    listBlock(): ListBlockOpcode;
    updating(): LinkedList<UpdatingOpcode>;
    elements(): ElementStack;
    scope(): Scope;
    dynamicScope(): DynamicScope;
    pushChildScope(): void;
    pushCallerScope(childScope?: boolean): void;
    pushDynamicScope(): DynamicScope;
    pushRootScope(size: number, bindCaller: boolean): Scope;
    popScope(): void;
    popDynamicScope(): void;
    newDestroyable(d: Destroyable): void;
    getSelf(): PathReference<any>;
    referenceForSymbol(symbol: number): PathReference<any>;
    execute(start: Handle, initialize?: (vm: VM) => void): RenderResult;
    next(): IteratorResult<RenderResult>;
    private nextStatement(env);
    evaluateOpcode(opcode: Opcode): void;
    bindDynamicScope(names: ConstantString[]): void;
}
