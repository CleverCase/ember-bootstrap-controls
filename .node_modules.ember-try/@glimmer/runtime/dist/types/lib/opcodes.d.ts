import { Option, Dict, Slice as ListSlice } from '@glimmer/util';
import { Tag } from '@glimmer/reference';
import { VM, UpdatingVM } from './vm';
import { Opcode, Environment } from './environment';
export interface OpcodeJSON {
    type: number | string;
    guid?: Option<number>;
    deopted?: boolean;
    args?: string[];
    details?: Dict<Option<string>>;
    children?: OpcodeJSON[];
}
/**
 * Registers
 *
 * For the most part, these follows MIPS naming conventions, however the
 * register numbers are different.
 */
export declare enum Register {
    'pc' = 0,
    'ra' = 1,
    'fp' = 2,
    'sp' = 3,
    's0' = 4,
    's1' = 5,
    't0' = 6,
    't1' = 7,
}
export declare const enum Op {
    /**
     * This opcode should never be reached.
     */
    Bug = 0,
    /**
     * Operation: Evaluate a Helper.
     * Format:
     *   (Helper helper:#Function)
     * Operand Stack:
     *   ..., Arguments →
     *   ..., VersionedPathReference
     */
    Helper = 1,
    /**
     * Operation: Push function onto the stack.
     * Format:
     *   (Function function:#Function)
     * Operand Stack:
     *   ... →
     *   ..., #Function
     */
    Function = 2,
    /**
     * Operation:
     *   Bind a variable represented by a symbol from
     *   a caller supplied argument.
     * Format:
     *   (SetVariable symbol:u32 offsetFromBase:u32)
     * Operand Stack:
     *   ... →
     *   ...
     */
    BindVariable = 3,
    /**
     * Operation:
     *   Bind the variable represented by a symbol from
     *   the value at the top of the stack.
     * Format:
     *   (SetVariable symbol:u32)
     * Operand Stack:
     *   ..., VersionedPathReference →
     *   ...
     */
    SetVariable = 4,
    /**
     * Operation:
     *   Push the contents of the variable represented by
     *   a symbol (a positional or named argument) onto
     *   the stack.
     * Format:
     *   (PushSymbol symbol:u32)
     * Operand Stack:
     *   ... →
     *   ..., VersionedPathReference
     */
    GetVariable = 5,
    /**
     * Operation:
     *   Pop a VersionedPathReference from the top of the
     *   stack, and push a VersionedPathReference constructed
     *   by `.get(property)`.
     * Format:
     *   (GetProperty property:#string)
     * Operand Stack:
     *   ..., VersionedPathReference →
     *   ..., VersionedPathReference
     */
    GetProperty = 6,
    /**
     * Operation: Push the specified constant block onto the stack.
     * Format:
     *   (PushBlock block:Option<#InlineBlock>)
     * Operand Stack:
     *   ... →
     *   ..., Option<InlineBlock>
     */
    PushBlock = 7,
    /**
     * Operation: Push the specified bound block onto the stack.
     * Format:
     *   (GetBlock block:u32)
     * Operand Stack:
     *   ... →
     *   ..., InlineBlock
     */
    GetBlock = 8,
    /**
     * Operation:
     *   Push TRUE onto the stack if the specified block
     *   is bound and FALSE if it is not.
     * Format:
     *   (HasBlock block:u32)
     * Operand Stack:
     *   ... →
     *   ..., boolean
     */
    HasBlock = 9,
    /**
     * Operation:
     *   Push TRUE onto the stack if the specified block
     *   is bound *and* has at least one specified formal
     *   parameter, and FALSE otherwise.
     * Format:
     *   (HasBlockParams block:u32)
     * Operand Stack:
     *   ... →
     *   ..., VersionedPathReference (boolean)
     */
    HasBlockParams = 10,
    /**
     * Operation:
     *   Pop count `VersionedPathReference`s off the stack and
     *   construct a new ConcatReference from them (in reverse
     *   order).
     * Format:
     *   (Concat count:u32)
     * Operand Stack:
     *   ..., VersionedPathReference, [VersionedPathReference ...] →
     *   ..., ConcatReference
     */
    Concat = 11,
    /**
     * Operation:
     *   Push a number onto the stack.
     * Format:
     *   (Immediate number:u32)
     * Operand Stack:
     *   ... →
     *   ..., number
     */
    Immediate = 12,
    /**
     * Operation:
     *   Push an Object constant onto the stack that is not
     *   a JavaScript primitive.
     * Format:
     *   (PushConstant constant:#Object)
     * Operand Stack:
     *   ... →
     *   ..., Opaque
     */
    Constant = 13,
    /**
     * Operation:
     *   Wrap a JavaScript primitive in a reference and push it
     *   onto the stack.
     * Format:
     *   (PushPrimitive constant:#Primitive)
     * Operand Stack:
     *   ... →
     *   ..., Primitive
     * Description:
     *   The two high bits of the constant reference describe
     *   the kind of primitive:
     *
     *   00: number
     *   01: string
     *   10: true | false | null | undefined
     */
    PrimitiveReference = 14,
    /**
     * Operation: Duplicate and push item from an offset in the stack.
     * Format:
     *   (Dup register:u32, offset:u32)
     * Operand Stack:
     *   ..., Opaque →
     *   ..., Opaque, Opaque
     */
    Dup = 15,
    /**
     * Operation: Pop N items off the stack and throw away the value.
     * Format:
     *   (Pop)
     * Operand Stack:
     *   ..., Opaque, ..., Opaque →
     *   ...
     */
    Pop = 16,
    /**
     * Operation: Load a value into a register
     * Format:
     *   (Load register:u32)
     * Operand Stack:
     *   ..., Opaque →
     *   ...
     */
    Load = 17,
    /**
     * Operation: Fetch a value from a register
     * Format:
     *   (Fetch register:u32)
     * Operand Stack:
     *   ... →
     *   ..., Opaque
     */
    Fetch = 18,
    /**
     * Operation: Push a new root scope onto the scope stack.
     *
     * Format:
     *   (RootScope symbols:u32 bindCallerScope:bool)
     * Operand Stack:
     *   ... →
     *   ...
     * Description:
     *   A root scope has no parent scope, and therefore inherits no lexical
     *   variables. If `bindCallerScope` is `true`, the current scope remembers
     *   the caller scope (for yielding blocks).
     */
    RootScope = 19,
    /**
     * Operation: Push a new child scope onto the scope stack.
     *
     * Format:
     *   (ChildScope)
     * Operand Stack:
     *   ... →
     *   ...
     * Description:
     *   A child scope inherits from the current parent scope, and therefore
     *   shares its lexical variables.
     */
    ChildScope = 20,
    /**
     * Operation: Pop the current scope from the scope stack.
     * Format:
     *   (PopScope)
     * Operand Stack:
     *   ... →
     *   ...
     */
    PopScope = 21,
    /**
     * Operation: Return to the previous frame.
     * Format:
     *   (Return)
     * Operand Stack:
     *   ..., address:number →
     *   ...
     */
    Return = 22,
    /**
     * Operation: Return to a place in the program given an offset
     * Format:
     *  (ReturnTo offset:i32)
     * Operand Stack:
     *    ... →
     */
    ReturnTo = 23,
    /**
     * Operation: Append a Text node with value `contents`
     * Format:
     *   (Text contents:#string)
     * Operand Stack:
     *   ... →
     *   ...
     */
    Text = 24,
    /**
     * Operation: Append a Comment node with value `contents`
     * Format:
     *   (Comment contents:#string)
     * Operand Stack:
     *   ... →
     *   ...
     */
    Comment = 25,
    /**
     * Operation: Append a Dynamic node based on .
     * Format:
     *   (DynamicContent contents:#DynamicContent)
     * Operand Stack:
     *   ..., VersionedPathReference →
     *   ...
     * Description:
     *   Dynamic content can produce any kind of Node or an
     *   fragment of HTML. If the VersionedPathReference
     *   changes to a different kind of content, the original
     *   node(s) are cleared and replaced with the value of
     *   the new content.
     *
     *   The dynamic content can also produce a component
     *   definition, which requires more fancy footwork.
     */
    DynamicContent = 26,
    /**
     * Operation: Open a new Element named `tag`.
     * Format:
     *   (OpenElement tag:#string)
     * Operand Stack:
     *   ... →
     *   ...
     */
    OpenElement = 27,
    /**
     * Operation:
     *   Open a new Element named `tag` with special operations provided
     *   on the stack.
     * Format:
     *   (OpenElementWithOperations tag:#string)
     * Operand Stack:
     *   ..., ElementOperations →
     *   ...
     */
    OpenElementWithOperations = 28,
    /**
     * Operation:
     *   Open a new Element with a name on the stack and with special
     *   operations provided on the stack.
     * Format:
     *   (OpenDynamicElement)
     * Operand Stack:
     *   ..., string, ElementOperations →
     *   ...
     */
    OpenDynamicElement = 29,
    /**
     * Operation: Add an attribute to the current Element.
     * Format:
     *   (StaticAttr name:#string value:#string namespace:Option<#string>)
     * Operand Stack:
     *   ... →
     *   ...
     */
    StaticAttr = 30,
    /**
     * Operation:
     *   Add an attribute to the current element using the value
     *   at the top of the stack.
     *
     * Format:
     *   (DynamicAttr name:#string trusting:boolean)
     * Operand Stack:
     *   ..., VersionedPathReference →
     *   ...
     * Description:
     *   If `trusting` is false, the host may sanitize the attribute
     *   based upon known risks.
     */
    DynamicAttr = 31,
    /**
     * Operation:
     *   Add an attribute to the current element using the value
     *   at the top of the stack.
     *
     * Format:
     *   (DynamicAttrNS name:#string namespace:#string trusting:boolean)
     * Operand Stack:
     *   ..., VersionedPathReference →
     *   ...
     * Description:
     *   If `trusting` is false, the host may sanitize the attribute
     *   based upon known risks.
     */
    DynamicAttrNS = 32,
    /**
     * Operation: Finish setting attributes on the current element.
     *
     * Format:
     *   (FlushElement)
     * Operand Stack:
     *   ... →
     *   ...
     */
    FlushElement = 33,
    /**
     * Operation: Close the current element.
     *
     * Format:
     *   (CloseElement)
     * Operand Stack:
     *   ... →
     *   ...
     */
    CloseElement = 34,
    Modifier = 35,
    PushRemoteElement = 36,
    PopRemoteElement = 37,
    /**
     * Operation: Bind stack values as dynamic variables.
     * Format:
     *   (BindDynamicScope names:#Array<#string>)
     * Operand Stack:
     *   ..., VersionedPathReference, [VersionedPathReference ...] →
     *   ...
     * Description:
     *   This is used to expose `-with-dynamic-vars`, and is a
     *   niche feature.
     */
    BindDynamicScope = 38,
    PushDynamicScope = 39,
    PopDynamicScope = 40,
    /**
     * Operation: Compile the InlineBlock at the top of the stack.
     * Format:
     *   (CompileDynamicBlock)
     * Operand Stack:
     *   ..., InlineBlock →
     *   ..., CompiledDynamicBlock
     */
    CompileDynamicBlock = 41,
    /**
     * Operation: Evaluate the specified block.
     * Format:
     *   (InvokeStatic block:#InlineBlock)
     * Operand Stack:
     *   ... →
     *   ...
     */
    InvokeStatic = 42,
    /**
     * Operation: Evaluate the block at the top of the stack.
     * Format:
     *   (InvokeDynamic invoker:#FunctionInvoker)
     * Operand Stack:
     *   ..., InlineBlock, [ VersionedPathReference... ], VersionedPathReference →
     *   ...
     */
    InvokeDynamic = 43,
    /**
     * Operation: Jump to the specified offset.
     *
     * Format:
     *   (Jump to:u32)
     * Operand Stack:
     *   ... →
     *   ...
     */
    Jump = 44,
    /**
     * Operation:
     *   Jump to the specified offset if the value at
     *   the top of the stack is true.
     *
     * Format:
     *   (JumpIf to:u32)
     * Operand Stack:
     *   ..., VersionedPathReference →
     *   ...
     */
    JumpIf = 45,
    /**
     * Operation:
     *   Jump to the specified offset if the value at
     *   the top of the stack is false.
     *
     * Format:
     *   (JumpUnless to:u32)
     * Operand Stack:
     *   ..., VersionedPathReference →
     *   ...
     */
    JumpUnless = 46,
    /**
     * Operation: Push a stack frame
     *
     * Format:
     *   (PushFrame)
     * Operand Stack:
     *   ... →
     *   $ra, $fp
     */
    PushFrame = 47,
    /**
     * Operation: Pop a stack frame
     *
     * Format:
     *   (PushFrame)
     * Operand Stack:
     *   $ra, $fp →
     *   ...
     */
    PopFrame = 48,
    /**
     * Operation:
     *   Start tracking a new output block that could change
     *   if one of its inputs changes.
     *
     * Format:
     *   (Enter args:u32)
     * Operand Stack:
     *   ... →
     *   ...
     * Description:
     *   Soon after this opcode, one of Jump, JumpIf,
     *   or JumpUnless will produce an updating assertion.
     *   If that assertion fails, the appending VM will
     *   be re-entered, and the instructions from `from`
     *   to `to` will be executed.
     *
     *   TODO: Save and restore.
     */
    Enter = 49,
    /**
     * Operation:
     *   Finish tracking the current block.
     *
     * Format:
     *   (Exit)
     * Operand Stack:
     *   ... →
     *   ...
     * Description:
     *   This finalizes the validators that the updating
     *   block must check to determine whether it's safe to
     *   skip running the contents.
     */
    Exit = 50,
    /**
     * Operation: Convert the top of the stack into a boolean reference.
     *
     * Format:
     *   (Test test:#function)
     * Operand Stack:
     *   ..., VersionedPathReference<Opaque> →
     *   ..., VersionedPathReference<bool>
     * Description:
     *   TODO: ToBoolean should be global in the env
     */
    Test = 51,
    /**
     * Operation: Enter a list.
     *
     * Format:
     *   (EnterList address:u32)
     * Operand Stack:
     *   ..., Iterator →
     *   ...
     */
    EnterList = 52,
    /**
     * Operation: Exit the current list.
     *
     * Format:
     *   (ExitList)
     * Operand Stack:
     *   ... →
     *   ...
     */
    ExitList = 53,
    /**
     * Operation:
     *   Convert an operand and key into an iterator and
     *   presence reference.
     *
     * Format:
     *   (PutIterator)
     * Operand Stack:
     *   ..., key:string, list:VersionedPathReference →
     *   ..., iterator:ReferenceIterator, present:PresenceReference
     */
    PutIterator = 54,
    /**
     * Operation:
     *   Set up the stack for iterating for a given key,
     *   or jump to `end` if there is nothing left to
     *   iterate.
     *
     * Format:
     *   (Iterate end:u32)
     * Operand Stack:
     *   Form 1: (something to iterate)
     *   ... →
     *   ..., VersionedPathReference, VersionedPathReference, string
     *   Form 2: (nothing left to iterate)
     *   ... →
     *   ...
     * Description:
     *   In Form 1, the stack will have (in reverse order):
     *
     *   - the key, as a string
     *   - the current iterated value
     *   - the memoized iterated value
     */
    Iterate = 55,
    /**
     * Operation: Push an appropriate component manager onto the stack.
     *
     * Format:
     *   (PushComponentManager #ComponentDefinition)
     * Operand Stack:
     *   ... →
     *   ..., { ComponentDefinition, ComponentManager }
     */
    PushComponentManager = 56,
    /**
     * Operation:
     *   Push an appropriate component manager onto the stack from
     *   a runtime-resolved component definition.
     *
     * Format:
     *   (PushDynamicComponentManager)
     * Operand Stack:
     *   ... Reference<ComponentDefinition> →
     *   ..., ComponentDefinition, ComponentManager
     */
    PushDynamicComponentManager = 57,
    /**
     * Operation: Push a user representation of args onto the stack.
     *
     * Format:
     *   (PushArgs synthetic:boolean)
     *
     * Operand Stack:
     *   ..., [VersionedPathReference ...], number, [VersionedPathReference ...], #Array<string> →
     *   ..., [VersionedPathReference ...], number, [VersionedPathReference ...], #Array<string>, Arguments
     *
     * Description:
     *   This arguments object is only necessary when calling into
     *   user-specified hooks. It is meant to be implemented as a
     *   transient proxy that reads into the stack as needed.
     *   Holding onto the Arguments after the call has completed is
     *   illegal.
     */
    PushArgs = 58,
    /**
     * Operation: ...
     * Format:
     *   (PrepareArgs state:u32)
     * Operand Stack:
     *   ... →
     *   ...
     */
    PrepareArgs = 59,
    /**
     * Operation: Create the component and push it onto the stack.
     * Format:
     *   (CreateComponent flags:u32 state:u32)
     *   ... →
     *   ...
     * Description:
     * Operand Stack:
     *   Flags:
     *
     *   * 0b001: Has a default block
     *   * 0b010: Has an inverse block
     */
    CreateComponent = 60,
    /**
     * Operation: Register a destructor for the current component
     *
     * Format:
     *   (RegisterComponentDestructor state:u32)
     * Operand Stack:
     *   ... →
     *   ...
     */
    RegisterComponentDestructor = 61,
    /**
     * Operation: Push a new ElementOperations for the current component.
     *
     * Format:
     *   (PushComponentOperations)
     * Operand Stack:
     *   ... →
     *   ...
     */
    PushComponentOperations = 62,
    /**
     * Operation: Push the component's `self` onto the stack.
     *
     * Format:
     *   (GetComponentSelf state:u32)
     * Operand Stack:
     *   ... →
     *   ..., VersionedPathReference
     */
    GetComponentSelf = 63,
    /**
     * Operation: Get a slice of opcodes to invoke.
     *
     * Format:
     *   (GetComponentLayout state:u32)
     * Operand Stack:
     *   ... →
     *   ..., Layout
     */
    GetComponentLayout = 64,
    /**
     * Operation: Begin a new cache group
     *
     * Format:
     *   (BeginComponentTransaction)
     * Operand Stack:
     *   ..., ComponentManager<T>, T →
     *   ..., ComponentManager<T>, T
     */
    BeginComponentTransaction = 65,
    /**
     * Operation: Commit the current cache group
     *
     * Format:
     *   (CommitComponentTransaction)
     * Operand Stack:
     *   ... →
     *   ...
     */
    CommitComponentTransaction = 66,
    /**
     * Operation: Invoke didCreateElement on the current component manager
     *
     * Format:
     *   (DidCreateElement state:u32)
     * Operand Stack:
     *   ... →
     *   ...
     */
    DidCreateElement = 67,
    /**
     * Operation: Invoke didRenderLayout on the current component manager
     *
     * Format:
     *   (DidRenderLayout state:u32)
     * Operand Stack:
     *   ..., →
     *   ...
     */
    DidRenderLayout = 68,
    /**
     * Operation: Extract the template from a partial definition
     *
     * Format:
     *   (GetPartialTemplate)
     * Operand Stack:
     *   ..., PartialDefinition →
     *   ..., Program
     */
    GetPartialTemplate = 69,
    /**
     * Operation:
     *   Resolve {{foo}} inside a partial, which could be either a self-lookup
     *   or a local variable that is in-scope for the caller.
     *
     * Format:
     *   (ResolveMaybeLocal local:#string)
     * Operand Stack:
     *   ... →
     *   ..., VersionedPathReference
     */
    ResolveMaybeLocal = 70,
    /**
     * Operation: Activate the debugger
     *
     * Format:
     *   (Debugger symbols:#Array<string> evalInfo:#Array<number>)
     * Operand Stack:
     *   ... →
     *   ...
     */
    Debugger = 71,
    /** The size of the opcode list */
    Size = 72,
}
export declare function debugSlice(env: Environment, start: number, end: number): void;
export declare type Operand1 = number;
export declare type Operand2 = number;
export declare type Operand3 = number;
export declare type EvaluateOpcode = (vm: VM, opcode: Opcode) => void;
export declare class AppendOpcodes {
    private evaluateOpcode;
    add<Name extends Op>(name: Name, evaluate: EvaluateOpcode): void;
    evaluate(vm: VM, opcode: Opcode, type: number): void;
}
export declare const APPEND_OPCODES: AppendOpcodes;
export declare abstract class AbstractOpcode {
    type: string;
    _guid: number;
    constructor();
    toJSON(): OpcodeJSON;
}
export declare abstract class UpdatingOpcode extends AbstractOpcode {
    tag: Tag;
    next: Option<UpdatingOpcode>;
    prev: Option<UpdatingOpcode>;
    abstract evaluate(vm: UpdatingVM): void;
}
export declare type UpdatingOpSeq = ListSlice<UpdatingOpcode>;
export declare function inspect(opcodes: ReadonlyArray<AbstractOpcode>): string;
