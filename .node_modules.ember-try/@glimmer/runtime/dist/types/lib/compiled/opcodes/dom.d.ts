import { PathReference, Reference, Tag } from '@glimmer/reference';
import { Dict, Opaque, Option } from '@glimmer/util';
import { ElementOperations } from '../../builder';
import { AttributeManager } from '../../dom/attribute-managers';
import * as Simple from '../../dom/interfaces';
import { Environment } from '../../environment';
import { ModifierManager } from '../../modifier/interfaces';
import { OpcodeJSON, UpdatingOpcode } from '../../opcodes';
import { UpdatingVM, VM } from '../../vm';
export declare class SimpleElementOperations implements ElementOperations {
    private env;
    private opcodes;
    private classList;
    constructor(env: Environment);
    addStaticAttribute(element: Simple.Element, name: string, value: string): void;
    addStaticAttributeNS(element: Simple.Element, namespace: string, name: string, value: string): void;
    addDynamicAttribute(element: Simple.Element, name: string, reference: Reference<string>, isTrusting: boolean): void;
    addDynamicAttributeNS(element: Simple.Element, namespace: Simple.Namespace, name: string, reference: PathReference<string>, isTrusting: boolean): void;
    flush(element: Simple.Element, vm: VM): void;
    private addClass(reference);
    private addAttribute(attribute);
}
export declare class ComponentElementOperations implements ElementOperations {
    private env;
    private attributeNames;
    private attributes;
    private classList;
    constructor(env: Environment);
    addStaticAttribute(element: Simple.Element, name: string, value: string): void;
    addStaticAttributeNS(element: Simple.Element, namespace: string, name: string, value: string): void;
    addDynamicAttribute(element: Simple.Element, name: string, reference: PathReference<string>, isTrusting: boolean): void;
    addDynamicAttributeNS(element: Simple.Element, namespace: Simple.Namespace, name: string, reference: PathReference<string>, isTrusting: boolean): void;
    flush(element: Simple.Element, vm: VM): void;
    private shouldAddAttribute(name);
    private addClass(reference);
    private addAttribute(name, attribute);
}
export declare class UpdateModifierOpcode extends UpdatingOpcode {
    tag: Tag;
    private manager;
    private modifier;
    type: string;
    private lastUpdated;
    constructor(tag: Tag, manager: ModifierManager<Opaque>, modifier: Opaque);
    evaluate(vm: UpdatingVM): void;
    toJSON(): OpcodeJSON;
}
export interface Attribute {
    name: string;
    flush(env: Environment): Option<UpdatingOpcode>;
}
export declare class StaticAttribute implements Attribute {
    private element;
    name: string;
    private value;
    private namespace;
    constructor(element: Simple.Element, name: string, value: string, namespace?: string);
    flush(env: Environment): Option<UpdatingOpcode>;
}
export declare class DynamicAttribute implements Attribute {
    private element;
    private attributeManager;
    name: string;
    private reference;
    private namespace;
    tag: Tag;
    private cache;
    constructor(element: Simple.Element, attributeManager: AttributeManager, name: string, reference: Reference<Opaque>, namespace?: Simple.Namespace);
    patch(env: Environment): void;
    flush(env: Environment): Option<UpdatingOpcode>;
    toJSON(): Dict<Option<string>>;
}
export declare class PatchElementOpcode extends UpdatingOpcode {
    type: string;
    private operation;
    constructor(operation: DynamicAttribute);
    evaluate(vm: UpdatingVM): void;
    toJSON(): OpcodeJSON;
}
