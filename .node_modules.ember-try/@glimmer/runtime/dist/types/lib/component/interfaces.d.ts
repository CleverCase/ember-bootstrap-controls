import { Dict, Opaque, Option } from '@glimmer/interfaces';
import { Tag, VersionedPathReference } from '@glimmer/reference';
import { Destroyable } from '@glimmer/util';
import { TemplateMeta } from '@glimmer/wire-format';
import Bounds from '../bounds';
import { ElementOperations } from '../builder';
import { CompiledDynamicProgram } from '../compiled/blocks';
import * as Simple from '../dom/interfaces';
import Environment, { DynamicScope } from '../environment';
import { Template } from '../template';
import { IArguments } from '../vm/arguments';
export declare type Component = Opaque;
export declare type ComponentClass = any;
export interface PreparedArguments {
    positional: Array<VersionedPathReference<Opaque>>;
    named: Dict<VersionedPathReference<Opaque>>;
}
export interface ComponentManager<T extends Component> {
    prepareArgs(definition: ComponentDefinition<T>, args: IArguments): Option<PreparedArguments>;
    create(env: Environment, definition: ComponentDefinition<T>, args: IArguments, dynamicScope: DynamicScope, caller: VersionedPathReference<Opaque>, hasDefaultBlock: boolean): T;
    layoutFor(definition: ComponentDefinition<T>, component: T, env: Environment): CompiledDynamicProgram;
    getSelf(component: T): VersionedPathReference<Opaque>;
    didCreateElement(component: T, element: Simple.Element, operations: ElementOperations): void;
    didRenderLayout(component: T, bounds: Bounds): void;
    didCreate(component: T): void;
    getTag(component: T): Option<Tag>;
    update(component: T, dynamicScope: DynamicScope): void;
    didUpdateLayout(component: T, bounds: Bounds): void;
    didUpdate(component: T): void;
    getDestructor(component: T): Option<Destroyable>;
}
export interface ComponentLayoutBuilder {
    env: Environment;
    tag: ComponentTagBuilder;
    attrs: ComponentAttrsBuilder;
    wrapLayout(layout: Template<TemplateMeta>): void;
    fromLayout(componentName: string, layout: Template<TemplateMeta>): void;
}
export interface ComponentTagBuilder {
    static(tagName: string): void;
}
export interface ComponentAttrsBuilder {
    static(name: string, value: string): void;
}
export declare function isComponentDefinition(obj: Opaque): obj is ComponentDefinition<Opaque>;
export declare abstract class ComponentDefinition<T> {
    name: string;
    manager: ComponentManager<T>;
    ComponentClass: ComponentClass;
    constructor(name: string, manager: ComponentManager<T>, ComponentClass: ComponentClass);
}
