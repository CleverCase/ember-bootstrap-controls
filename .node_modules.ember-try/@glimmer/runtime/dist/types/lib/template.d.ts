import { Opaque } from '@glimmer/interfaces';
import { PathReference } from '@glimmer/reference';
import { SerializedTemplateWithLazyBlock, Statements, TemplateMeta } from '@glimmer/wire-format';
import * as Simple from './dom/interfaces';
import { DynamicScope, Environment } from './environment';
import { Block, Program } from './syntax/interfaces';
import { IteratorResult, RenderResult, VM } from './vm';
/**
 * Environment specific template.
 */
export interface Template<T> {
    /**
     * Template identifier, if precompiled will be the id of the
     * precompiled template.
     */
    id: string;
    /**
     * Template meta (both compile time and environment specific).
     */
    meta: T;
    hasEval: boolean;
    /**
     * Symbols computed at compile time.
     */
    symbols: string[];
    /**
     * Helper to render template as root entry point.
     */
    render(self: PathReference<Opaque>, appendTo: Simple.Element, dynamicScope: DynamicScope): TemplateIterator;
    asEntryPoint(): Program;
    asLayout(componentName: string, attrs?: Statements.Attribute[]): Program;
    asPartial(): Program;
    asBlock(): Block;
}
export interface TemplateFactory<T, U> {
    /**
     * Template identifier, if precompiled will be the id of the
     * precompiled template.
     */
    id: string;
    /**
     * Compile time meta.
     */
    meta: T;
    /**
     * Used to create an environment specific singleton instance
     * of the template.
     *
     * @param {Environment} env glimmer Environment
     */
    create(env: Environment): Template<T>;
    /**
     * Used to create an environment specific singleton instance
     * of the template.
     *
     * @param {Environment} env glimmer Environment
     * @param {Object} meta environment specific injections into meta
     */
    create(env: Environment, meta: U): Template<T & U>;
}
export declare class TemplateIterator {
    private vm;
    constructor(vm: VM);
    next(): IteratorResult<RenderResult>;
}
/**
 * Wraps a template js in a template module to change it into a factory
 * that handles lazy parsing the template and to create per env singletons
 * of the template.
 */
export default function templateFactory<T extends TemplateMeta>(serializedTemplate: SerializedTemplateWithLazyBlock<T>): TemplateFactory<T, T>;
export default function templateFactory<T extends TemplateMeta, U>(serializedTemplate: SerializedTemplateWithLazyBlock<T>): TemplateFactory<T, U>;
