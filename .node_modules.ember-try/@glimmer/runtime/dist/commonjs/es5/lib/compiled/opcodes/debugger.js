'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setDebuggerCallback = setDebuggerCallback;
exports.resetDebuggerCallback = resetDebuggerCallback;

var _util = require('@glimmer/util');

var _opcodes = require('../../opcodes');

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

/* tslint:disable */
function debugCallback(context, get) {
    console.info('Use `context`, and `get(<path>)` to debug this template.');
    // for example...
    context === get('this');
    debugger;
}
/* tslint:enable */
var callback = debugCallback;
// For testing purposes
function setDebuggerCallback(cb) {
    callback = cb;
}
function resetDebuggerCallback() {
    callback = debugCallback;
}

var ScopeInspector = function () {
    function ScopeInspector(scope, symbols, evalInfo) {
        _classCallCheck(this, ScopeInspector);

        this.scope = scope;
        this.locals = (0, _util.dict)();
        for (var i = 0; i < evalInfo.length; i++) {
            var slot = evalInfo[i];
            var name = symbols[slot - 1];
            var ref = scope.getSymbol(slot);
            this.locals[name] = ref;
        }
    }

    ScopeInspector.prototype.get = function get(path) {
        var scope = this.scope,
            locals = this.locals;

        var parts = path.split('.');

        var _path$split = path.split('.'),
            head = _path$split[0],
            tail = _path$split.slice(1);

        var evalScope = scope.getEvalScope();
        var ref = void 0;
        if (head === 'this') {
            ref = scope.getSelf();
        } else if (locals[head]) {
            ref = locals[head];
        } else if (head.indexOf('@') === 0 && evalScope[head]) {
            ref = evalScope[head];
        } else {
            ref = this.scope.getSelf();
            tail = parts;
        }
        return tail.reduce(function (r, part) {
            return r.get(part);
        }, ref);
    };

    return ScopeInspector;
}();

_opcodes.APPEND_OPCODES.add(71 /* Debugger */, function (vm, _ref) {
    var _symbols = _ref.op1,
        _evalInfo = _ref.op2;

    var symbols = vm.constants.getOther(_symbols);
    var evalInfo = vm.constants.getArray(_evalInfo);
    var inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
    callback(vm.getSelf().value(), function (path) {
        return inspector.get(path).value();
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21waWxlZC9vcGNvZGVzL2RlYnVnZ2VyLmpzIl0sIm5hbWVzIjpbImRpY3QiLCJBUFBFTkRfT1BDT0RFUyIsImRlYnVnQ2FsbGJhY2siLCJjb250ZXh0IiwiZ2V0IiwiY29uc29sZSIsImluZm8iLCJjYWxsYmFjayIsInNldERlYnVnZ2VyQ2FsbGJhY2siLCJjYiIsInJlc2V0RGVidWdnZXJDYWxsYmFjayIsIlNjb3BlSW5zcGVjdG9yIiwic2NvcGUiLCJzeW1ib2xzIiwiZXZhbEluZm8iLCJsb2NhbHMiLCJpIiwibGVuZ3RoIiwic2xvdCIsIm5hbWUiLCJyZWYiLCJnZXRTeW1ib2wiLCJwYXRoIiwicGFydHMiLCJzcGxpdCIsImhlYWQiLCJ0YWlsIiwiZXZhbFNjb3BlIiwiZ2V0RXZhbFNjb3BlIiwiZ2V0U2VsZiIsImluZGV4T2YiLCJyZWR1Y2UiLCJyIiwicGFydCIsImFkZCIsInZtIiwiX3N5bWJvbHMiLCJvcDEiLCJfZXZhbEluZm8iLCJvcDIiLCJjb25zdGFudHMiLCJnZXRPdGhlciIsImdldEFycmF5IiwiaW5zcGVjdG9yIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7Ozs7O1FBWU8sQUFBUztRQUdULEFBQVM7O0FBZmhCLEFBQVMsQUFBWTs7QUFDckIsQUFBUyxBQUFzQjs7Ozs7Ozs7QUFDL0I7QUFDQSxTQUFBLEFBQVMsY0FBVCxBQUF1QixTQUF2QixBQUFnQyxLQUFLLEFBQ2pDO1lBQUEsQUFBUSxLQUFSLEFBQWEsQUFDYjtBQUNBO2dCQUFZLElBQVosQUFBWSxBQUFJLEFBQ2hCO0FBQ0g7O0FBQ0Q7QUFDQSxJQUFJLFdBQUosQUFBZTtBQUNmLEFBQ0E7QUFBTyw2QkFBQSxBQUE2QixJQUFJLEFBQ3BDO2VBQUEsQUFBVyxBQUNkO0FBQ0Q7QUFBTyxpQ0FBaUMsQUFDcEM7ZUFBQSxBQUFXLEFBQ2Q7OztJLEFBQ0ssNkJBQ0Y7NEJBQUEsQUFBWSxPQUFaLEFBQW1CLFNBQW5CLEFBQTRCLFVBQVU7OEJBQ2xDOzthQUFBLEFBQUssUUFBTCxBQUFhLEFBQ2I7YUFBQSxBQUFLLFNBQUwsQUFBYyxBQUNkO2FBQUssSUFBSSxJQUFULEFBQWEsR0FBRyxJQUFJLFNBQXBCLEFBQTZCLFFBQTdCLEFBQXFDLEtBQUssQUFDdEM7Z0JBQUksT0FBTyxTQUFYLEFBQVcsQUFBUyxBQUNwQjtnQkFBSSxPQUFPLFFBQVEsT0FBbkIsQUFBVyxBQUFlLEFBQzFCO2dCQUFJLE1BQU0sTUFBQSxBQUFNLFVBQWhCLEFBQVUsQUFBZ0IsQUFDMUI7aUJBQUEsQUFBSyxPQUFMLEFBQVksUUFBWixBQUFvQixBQUN2QjtBQUNKOzs7NkJBQ0QsQSxtQkFBSSxBLE1BQU07WUFBQSxBQUNBLFFBREEsQUFDa0IsS0FEbEIsQUFDQTtZQURBLEFBQ08sU0FEUCxBQUNrQixLQURsQixBQUNPLEFBQ2I7O1lBQUksUUFBUSxLQUFBLEFBQUssTUFGWCxBQUVOLEFBQVksQUFBVzs7MEJBQ0QsS0FBQSxBQUFLLE1BSHJCLEFBR2dCLEFBQVc7WUFIM0IsQUFHRCxtQkFIQztZQUFBLEFBR1EseUJBQ2Q7O1lBQUksWUFBWSxNQUFoQixBQUFnQixBQUFNLEFBQ3RCO1lBQUksV0FBSixBQUNBO1lBQUksU0FBSixBQUFhLFFBQVEsQUFDakI7a0JBQU0sTUFBTixBQUFNLEFBQU0sQUFDZjtBQUZELG1CQUVXLE9BQUosQUFBSSxBQUFPLE9BQU8sQUFDckI7a0JBQU0sT0FBTixBQUFNLEFBQU8sQUFDaEI7QUFGTSxTQUFBLFVBRUksS0FBQSxBQUFLLFFBQUwsQUFBYSxTQUFiLEFBQXNCLEtBQUssVUFBL0IsQUFBK0IsQUFBVSxPQUFPLEFBQ25EO2tCQUFNLFVBQU4sQUFBTSxBQUFVLEFBQ25CO0FBRk0sU0FBQSxNQUVBLEFBQ0g7a0JBQU0sS0FBQSxBQUFLLE1BQVgsQUFBTSxBQUFXLEFBQ2pCO21CQUFBLEFBQU8sQUFDVjtBQUNEO29CQUFPLEFBQUssT0FBTyxVQUFBLEFBQUMsR0FBRCxBQUFJLE1BQUo7bUJBQWEsRUFBQSxBQUFFLElBQWYsQUFBYSxBQUFNO0FBQS9CLFNBQUEsRUFBUCxBQUFPLEFBQXNDLEFBQ2hEO0E7Ozs7O0FBRUwsd0JBQUEsQUFBZSxJQUFmLEFBQW1CLEdBQW5CLEFBQXNCLGdCQUFnQixVQUFBLEFBQUMsVUFBMEM7UUFBL0IsQUFBK0IsZ0JBQXBDLEFBQW9DO1FBQWhCLEFBQWdCLGlCQUFyQixBQUFxQixBQUM3RTs7UUFBSSxVQUFVLEdBQUEsQUFBRyxVQUFILEFBQWEsU0FBM0IsQUFBYyxBQUFzQixBQUNwQztRQUFJLFdBQVcsR0FBQSxBQUFHLFVBQUgsQUFBYSxTQUE1QixBQUFlLEFBQXNCLEFBQ3JDO1FBQUksWUFBWSxJQUFBLEFBQUksZUFBZSxHQUFuQixBQUFtQixBQUFHLFNBQXRCLEFBQStCLFNBQS9DLEFBQWdCLEFBQXdDLEFBQ3hEO2FBQVMsR0FBQSxBQUFHLFVBQVosQUFBUyxBQUFhLFNBQVMsZ0JBQUE7ZUFBUSxVQUFBLEFBQVUsSUFBVixBQUFjLE1BQXRCLEFBQVEsQUFBb0I7QUFBM0QsQUFDSDtBQUxEIiwiZmlsZSI6ImxpYi9jb21waWxlZC9vcGNvZGVzL2RlYnVnZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGljdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVBQRU5EX09QQ09ERVMgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbi8qIHRzbGludDpkaXNhYmxlICovXG5mdW5jdGlvbiBkZWJ1Z0NhbGxiYWNrKGNvbnRleHQsIGdldCkge1xuICAgIGNvbnNvbGUuaW5mbygnVXNlIGBjb250ZXh0YCwgYW5kIGBnZXQoPHBhdGg+KWAgdG8gZGVidWcgdGhpcyB0ZW1wbGF0ZS4nKTtcbiAgICAvLyBmb3IgZXhhbXBsZS4uLlxuICAgIGNvbnRleHQgPT09IGdldCgndGhpcycpO1xuICAgIGRlYnVnZ2VyO1xufVxuLyogdHNsaW50OmVuYWJsZSAqL1xubGV0IGNhbGxiYWNrID0gZGVidWdDYWxsYmFjaztcbi8vIEZvciB0ZXN0aW5nIHB1cnBvc2VzXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVidWdnZXJDYWxsYmFjayhjYikge1xuICAgIGNhbGxiYWNrID0gY2I7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzZXREZWJ1Z2dlckNhbGxiYWNrKCkge1xuICAgIGNhbGxiYWNrID0gZGVidWdDYWxsYmFjaztcbn1cbmNsYXNzIFNjb3BlSW5zcGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZSwgc3ltYm9scywgZXZhbEluZm8pIHtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLmxvY2FscyA9IGRpY3QoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmFsSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNsb3QgPSBldmFsSW5mb1tpXTtcbiAgICAgICAgICAgIGxldCBuYW1lID0gc3ltYm9sc1tzbG90IC0gMV07XG4gICAgICAgICAgICBsZXQgcmVmID0gc2NvcGUuZ2V0U3ltYm9sKHNsb3QpO1xuICAgICAgICAgICAgdGhpcy5sb2NhbHNbbmFtZV0gPSByZWY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KHBhdGgpIHtcbiAgICAgICAgbGV0IHsgc2NvcGUsIGxvY2FscyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICBsZXQgW2hlYWQsIC4uLnRhaWxdID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgICBsZXQgZXZhbFNjb3BlID0gc2NvcGUuZ2V0RXZhbFNjb3BlKCk7XG4gICAgICAgIGxldCByZWY7XG4gICAgICAgIGlmIChoZWFkID09PSAndGhpcycpIHtcbiAgICAgICAgICAgIHJlZiA9IHNjb3BlLmdldFNlbGYoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbHNbaGVhZF0pIHtcbiAgICAgICAgICAgIHJlZiA9IGxvY2Fsc1toZWFkXTtcbiAgICAgICAgfSBlbHNlIGlmIChoZWFkLmluZGV4T2YoJ0AnKSA9PT0gMCAmJiBldmFsU2NvcGVbaGVhZF0pIHtcbiAgICAgICAgICAgIHJlZiA9IGV2YWxTY29wZVtoZWFkXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMuc2NvcGUuZ2V0U2VsZigpO1xuICAgICAgICAgICAgdGFpbCA9IHBhcnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWlsLnJlZHVjZSgociwgcGFydCkgPT4gci5nZXQocGFydCksIHJlZik7XG4gICAgfVxufVxuQVBQRU5EX09QQ09ERVMuYWRkKDcxIC8qIERlYnVnZ2VyICovLCAodm0sIHsgb3AxOiBfc3ltYm9scywgb3AyOiBfZXZhbEluZm8gfSkgPT4ge1xuICAgIGxldCBzeW1ib2xzID0gdm0uY29uc3RhbnRzLmdldE90aGVyKF9zeW1ib2xzKTtcbiAgICBsZXQgZXZhbEluZm8gPSB2bS5jb25zdGFudHMuZ2V0QXJyYXkoX2V2YWxJbmZvKTtcbiAgICBsZXQgaW5zcGVjdG9yID0gbmV3IFNjb3BlSW5zcGVjdG9yKHZtLnNjb3BlKCksIHN5bWJvbHMsIGV2YWxJbmZvKTtcbiAgICBjYWxsYmFjayh2bS5nZXRTZWxmKCkudmFsdWUoKSwgcGF0aCA9PiBpbnNwZWN0b3IuZ2V0KHBhdGgpLnZhbHVlKCkpO1xufSk7Il19