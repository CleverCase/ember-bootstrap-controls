'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SVG_NAMESPACE = undefined;
exports.domChanges = domChanges;
exports.treeConstruction = treeConstruction;

var _bounds = require('../bounds');

var _helper = require('../dom/helper');

var _util = require('@glimmer/util');

const SVG_NAMESPACE = exports.SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
// Patch:    insertAdjacentHTML on SVG Fix
// Browsers: Safari, IE, Edge, Firefox ~33-34
// Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is
//           present but throws an exception on IE and Edge. Old versions of
//           Firefox create nodes in the incorrect namespace.
// Fix:      Since IE and Edge silently fail to create SVG nodes using
//           innerHTML, and because Firefox may create nodes in the incorrect
//           namespace using innerHTML on SVG elements, an HTML-string wrapping
//           approach is used. A pre/post SVG tag is added to the string, then
//           that whole string is added to a div. The created nodes are plucked
//           out and applied to the target location on DOM.
function domChanges(document, DOMChangesClass, svgNamespace) {
    if (!document) return DOMChangesClass;
    if (!shouldApplyFix(document, svgNamespace)) {
        return DOMChangesClass;
    }
    let div = document.createElement('div');
    return class DOMChangesWithSVGInnerHTMLFix extends DOMChangesClass {
        insertHTMLBefore(parent, nextSibling, html) {
            if (html === null || html === '') {
                return super.insertHTMLBefore(parent, nextSibling, html);
            }
            if (parent.namespaceURI !== svgNamespace) {
                return super.insertHTMLBefore(parent, nextSibling, html);
            }
            return fixSVG(parent, div, html, nextSibling);
        }
    };
}
function treeConstruction(document, TreeConstructionClass, svgNamespace) {
    if (!document) return TreeConstructionClass;
    if (!shouldApplyFix(document, svgNamespace)) {
        return TreeConstructionClass;
    }
    let div = document.createElement('div');
    return class TreeConstructionWithSVGInnerHTMLFix extends TreeConstructionClass {
        insertHTMLBefore(parent, reference, html) {
            if (html === null || html === '') {
                return super.insertHTMLBefore(parent, reference, html);
            }
            if (parent.namespaceURI !== svgNamespace) {
                return super.insertHTMLBefore(parent, reference, html);
            }
            return fixSVG(parent, div, html, reference);
        }
    };
}
function fixSVG(parent, div, html, reference) {
    // IE, Edge: also do not correctly support using `innerHTML` on SVG
    // namespaced elements. So here a wrapper is used.
    let wrappedHtml = '<svg>' + html + '</svg>';
    div.innerHTML = wrappedHtml;
    let [first, last] = (0, _helper.moveNodesBefore)(div.firstChild, parent, reference);
    return new _bounds.ConcreteBounds(parent, first, last);
}
function shouldApplyFix(document, svgNamespace) {
    let svg = document.createElementNS(svgNamespace, 'svg');
    try {
        svg['insertAdjacentHTML']('beforeend', '<circle></circle>');
    } catch (e) {
        // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG
        // Safari: Will throw, insertAdjacentHTML is not present on SVG
    } finally {
        // FF: Old versions will create a node in the wrong namespace
        if (svg.childNodes.length === 1 && (0, _util.unwrap)(svg.firstChild).namespaceURI === SVG_NAMESPACE) {
            // The test worked as expected, no fix required
            return false;
        }
        return true;
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21wYXQvc3ZnLWlubmVyLWh0bWwtZml4LmpzIl0sIm5hbWVzIjpbImRvbUNoYW5nZXMiLCJ0cmVlQ29uc3RydWN0aW9uIiwiU1ZHX05BTUVTUEFDRSIsImRvY3VtZW50IiwiRE9NQ2hhbmdlc0NsYXNzIiwic3ZnTmFtZXNwYWNlIiwic2hvdWxkQXBwbHlGaXgiLCJkaXYiLCJjcmVhdGVFbGVtZW50IiwiRE9NQ2hhbmdlc1dpdGhTVkdJbm5lckhUTUxGaXgiLCJpbnNlcnRIVE1MQmVmb3JlIiwicGFyZW50IiwibmV4dFNpYmxpbmciLCJodG1sIiwibmFtZXNwYWNlVVJJIiwiZml4U1ZHIiwiVHJlZUNvbnN0cnVjdGlvbkNsYXNzIiwiVHJlZUNvbnN0cnVjdGlvbldpdGhTVkdJbm5lckhUTUxGaXgiLCJyZWZlcmVuY2UiLCJ3cmFwcGVkSHRtbCIsImlubmVySFRNTCIsImZpcnN0IiwibGFzdCIsImZpcnN0Q2hpbGQiLCJzdmciLCJjcmVhdGVFbGVtZW50TlMiLCJlIiwiY2hpbGROb2RlcyIsImxlbmd0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O1FBZWdCQSxVLEdBQUFBLFU7UUFrQkFDLGdCLEdBQUFBLGdCOztBQWpDaEI7O0FBQ0E7O0FBQ0E7O0FBQ08sTUFBTUMsd0NBQWdCLDRCQUF0QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTRixVQUFULENBQW9CRyxRQUFwQixFQUE4QkMsZUFBOUIsRUFBK0NDLFlBQS9DLEVBQTZEO0FBQ2hFLFFBQUksQ0FBQ0YsUUFBTCxFQUFlLE9BQU9DLGVBQVA7QUFDZixRQUFJLENBQUNFLGVBQWVILFFBQWYsRUFBeUJFLFlBQXpCLENBQUwsRUFBNkM7QUFDekMsZUFBT0QsZUFBUDtBQUNIO0FBQ0QsUUFBSUcsTUFBTUosU0FBU0ssYUFBVCxDQUF1QixLQUF2QixDQUFWO0FBQ0EsV0FBTyxNQUFNQyw2QkFBTixTQUE0Q0wsZUFBNUMsQ0FBNEQ7QUFDL0RNLHlCQUFpQkMsTUFBakIsRUFBeUJDLFdBQXpCLEVBQXNDQyxJQUF0QyxFQUE0QztBQUN4QyxnQkFBSUEsU0FBUyxJQUFULElBQWlCQSxTQUFTLEVBQTlCLEVBQWtDO0FBQzlCLHVCQUFPLE1BQU1ILGdCQUFOLENBQXVCQyxNQUF2QixFQUErQkMsV0FBL0IsRUFBNENDLElBQTVDLENBQVA7QUFDSDtBQUNELGdCQUFJRixPQUFPRyxZQUFQLEtBQXdCVCxZQUE1QixFQUEwQztBQUN0Qyx1QkFBTyxNQUFNSyxnQkFBTixDQUF1QkMsTUFBdkIsRUFBK0JDLFdBQS9CLEVBQTRDQyxJQUE1QyxDQUFQO0FBQ0g7QUFDRCxtQkFBT0UsT0FBT0osTUFBUCxFQUFlSixHQUFmLEVBQW9CTSxJQUFwQixFQUEwQkQsV0FBMUIsQ0FBUDtBQUNIO0FBVDhELEtBQW5FO0FBV0g7QUFDTSxTQUFTWCxnQkFBVCxDQUEwQkUsUUFBMUIsRUFBb0NhLHFCQUFwQyxFQUEyRFgsWUFBM0QsRUFBeUU7QUFDNUUsUUFBSSxDQUFDRixRQUFMLEVBQWUsT0FBT2EscUJBQVA7QUFDZixRQUFJLENBQUNWLGVBQWVILFFBQWYsRUFBeUJFLFlBQXpCLENBQUwsRUFBNkM7QUFDekMsZUFBT1cscUJBQVA7QUFDSDtBQUNELFFBQUlULE1BQU1KLFNBQVNLLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVjtBQUNBLFdBQU8sTUFBTVMsbUNBQU4sU0FBa0RELHFCQUFsRCxDQUF3RTtBQUMzRU4seUJBQWlCQyxNQUFqQixFQUF5Qk8sU0FBekIsRUFBb0NMLElBQXBDLEVBQTBDO0FBQ3RDLGdCQUFJQSxTQUFTLElBQVQsSUFBaUJBLFNBQVMsRUFBOUIsRUFBa0M7QUFDOUIsdUJBQU8sTUFBTUgsZ0JBQU4sQ0FBdUJDLE1BQXZCLEVBQStCTyxTQUEvQixFQUEwQ0wsSUFBMUMsQ0FBUDtBQUNIO0FBQ0QsZ0JBQUlGLE9BQU9HLFlBQVAsS0FBd0JULFlBQTVCLEVBQTBDO0FBQ3RDLHVCQUFPLE1BQU1LLGdCQUFOLENBQXVCQyxNQUF2QixFQUErQk8sU0FBL0IsRUFBMENMLElBQTFDLENBQVA7QUFDSDtBQUNELG1CQUFPRSxPQUFPSixNQUFQLEVBQWVKLEdBQWYsRUFBb0JNLElBQXBCLEVBQTBCSyxTQUExQixDQUFQO0FBQ0g7QUFUMEUsS0FBL0U7QUFXSDtBQUNELFNBQVNILE1BQVQsQ0FBZ0JKLE1BQWhCLEVBQXdCSixHQUF4QixFQUE2Qk0sSUFBN0IsRUFBbUNLLFNBQW5DLEVBQThDO0FBQzFDO0FBQ0E7QUFDQSxRQUFJQyxjQUFjLFVBQVVOLElBQVYsR0FBaUIsUUFBbkM7QUFDQU4sUUFBSWEsU0FBSixHQUFnQkQsV0FBaEI7QUFDQSxRQUFJLENBQUNFLEtBQUQsRUFBUUMsSUFBUixJQUFnQiw2QkFBZ0JmLElBQUlnQixVQUFwQixFQUFnQ1osTUFBaEMsRUFBd0NPLFNBQXhDLENBQXBCO0FBQ0EsV0FBTywyQkFBbUJQLE1BQW5CLEVBQTJCVSxLQUEzQixFQUFrQ0MsSUFBbEMsQ0FBUDtBQUNIO0FBQ0QsU0FBU2hCLGNBQVQsQ0FBd0JILFFBQXhCLEVBQWtDRSxZQUFsQyxFQUFnRDtBQUM1QyxRQUFJbUIsTUFBTXJCLFNBQVNzQixlQUFULENBQXlCcEIsWUFBekIsRUFBdUMsS0FBdkMsQ0FBVjtBQUNBLFFBQUk7QUFDQW1CLFlBQUksb0JBQUosRUFBMEIsV0FBMUIsRUFBdUMsbUJBQXZDO0FBQ0gsS0FGRCxDQUVFLE9BQU9FLENBQVAsRUFBVTtBQUNSO0FBQ0E7QUFDSCxLQUxELFNBS1U7QUFDTjtBQUNBLFlBQUlGLElBQUlHLFVBQUosQ0FBZUMsTUFBZixLQUEwQixDQUExQixJQUErQixrQkFBT0osSUFBSUQsVUFBWCxFQUF1QlQsWUFBdkIsS0FBd0NaLGFBQTNFLEVBQTBGO0FBQ3RGO0FBQ0EsbUJBQU8sS0FBUDtBQUNIO0FBQ0QsZUFBTyxJQUFQO0FBQ0g7QUFDSiIsImZpbGUiOiJsaWIvY29tcGF0L3N2Zy1pbm5lci1odG1sLWZpeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbmNyZXRlQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzJztcbmltcG9ydCB7IG1vdmVOb2Rlc0JlZm9yZSB9IGZyb20gJy4uL2RvbS9oZWxwZXInO1xuaW1wb3J0IHsgdW53cmFwIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5leHBvcnQgY29uc3QgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4vLyBQYXRjaDogICAgaW5zZXJ0QWRqYWNlbnRIVE1MIG9uIFNWRyBGaXhcbi8vIEJyb3dzZXJzOiBTYWZhcmksIElFLCBFZGdlLCBGaXJlZm94IH4zMy0zNFxuLy8gUmVhc29uOiAgIGluc2VydEFkamFjZW50SFRNTCBkb2VzIG5vdCBleGlzdCBvbiBTVkcgZWxlbWVudHMgaW4gU2FmYXJpLiBJdCBpc1xuLy8gICAgICAgICAgIHByZXNlbnQgYnV0IHRocm93cyBhbiBleGNlcHRpb24gb24gSUUgYW5kIEVkZ2UuIE9sZCB2ZXJzaW9ucyBvZlxuLy8gICAgICAgICAgIEZpcmVmb3ggY3JlYXRlIG5vZGVzIGluIHRoZSBpbmNvcnJlY3QgbmFtZXNwYWNlLlxuLy8gRml4OiAgICAgIFNpbmNlIElFIGFuZCBFZGdlIHNpbGVudGx5IGZhaWwgdG8gY3JlYXRlIFNWRyBub2RlcyB1c2luZ1xuLy8gICAgICAgICAgIGlubmVySFRNTCwgYW5kIGJlY2F1c2UgRmlyZWZveCBtYXkgY3JlYXRlIG5vZGVzIGluIHRoZSBpbmNvcnJlY3Rcbi8vICAgICAgICAgICBuYW1lc3BhY2UgdXNpbmcgaW5uZXJIVE1MIG9uIFNWRyBlbGVtZW50cywgYW4gSFRNTC1zdHJpbmcgd3JhcHBpbmdcbi8vICAgICAgICAgICBhcHByb2FjaCBpcyB1c2VkLiBBIHByZS9wb3N0IFNWRyB0YWcgaXMgYWRkZWQgdG8gdGhlIHN0cmluZywgdGhlblxuLy8gICAgICAgICAgIHRoYXQgd2hvbGUgc3RyaW5nIGlzIGFkZGVkIHRvIGEgZGl2LiBUaGUgY3JlYXRlZCBub2RlcyBhcmUgcGx1Y2tlZFxuLy8gICAgICAgICAgIG91dCBhbmQgYXBwbGllZCB0byB0aGUgdGFyZ2V0IGxvY2F0aW9uIG9uIERPTS5cbmV4cG9ydCBmdW5jdGlvbiBkb21DaGFuZ2VzKGRvY3VtZW50LCBET01DaGFuZ2VzQ2xhc3MsIHN2Z05hbWVzcGFjZSkge1xuICAgIGlmICghZG9jdW1lbnQpIHJldHVybiBET01DaGFuZ2VzQ2xhc3M7XG4gICAgaWYgKCFzaG91bGRBcHBseUZpeChkb2N1bWVudCwgc3ZnTmFtZXNwYWNlKSkge1xuICAgICAgICByZXR1cm4gRE9NQ2hhbmdlc0NsYXNzO1xuICAgIH1cbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV0dXJuIGNsYXNzIERPTUNoYW5nZXNXaXRoU1ZHSW5uZXJIVE1MRml4IGV4dGVuZHMgRE9NQ2hhbmdlc0NsYXNzIHtcbiAgICAgICAgaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQsIG5leHRTaWJsaW5nLCBodG1sKSB7XG4gICAgICAgICAgICBpZiAoaHRtbCA9PT0gbnVsbCB8fCBodG1sID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5pbnNlcnRIVE1MQmVmb3JlKHBhcmVudCwgbmV4dFNpYmxpbmcsIGh0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgIT09IHN2Z05hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5pbnNlcnRIVE1MQmVmb3JlKHBhcmVudCwgbmV4dFNpYmxpbmcsIGh0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpeFNWRyhwYXJlbnQsIGRpdiwgaHRtbCwgbmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmVlQ29uc3RydWN0aW9uKGRvY3VtZW50LCBUcmVlQ29uc3RydWN0aW9uQ2xhc3MsIHN2Z05hbWVzcGFjZSkge1xuICAgIGlmICghZG9jdW1lbnQpIHJldHVybiBUcmVlQ29uc3RydWN0aW9uQ2xhc3M7XG4gICAgaWYgKCFzaG91bGRBcHBseUZpeChkb2N1bWVudCwgc3ZnTmFtZXNwYWNlKSkge1xuICAgICAgICByZXR1cm4gVHJlZUNvbnN0cnVjdGlvbkNsYXNzO1xuICAgIH1cbiAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV0dXJuIGNsYXNzIFRyZWVDb25zdHJ1Y3Rpb25XaXRoU1ZHSW5uZXJIVE1MRml4IGV4dGVuZHMgVHJlZUNvbnN0cnVjdGlvbkNsYXNzIHtcbiAgICAgICAgaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQsIHJlZmVyZW5jZSwgaHRtbCkge1xuICAgICAgICAgICAgaWYgKGh0bWwgPT09IG51bGwgfHwgaHRtbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQsIHJlZmVyZW5jZSwgaHRtbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSAhPT0gc3ZnTmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCByZWZlcmVuY2UsIGh0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpeFNWRyhwYXJlbnQsIGRpdiwgaHRtbCwgcmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBmaXhTVkcocGFyZW50LCBkaXYsIGh0bWwsIHJlZmVyZW5jZSkge1xuICAgIC8vIElFLCBFZGdlOiBhbHNvIGRvIG5vdCBjb3JyZWN0bHkgc3VwcG9ydCB1c2luZyBgaW5uZXJIVE1MYCBvbiBTVkdcbiAgICAvLyBuYW1lc3BhY2VkIGVsZW1lbnRzLiBTbyBoZXJlIGEgd3JhcHBlciBpcyB1c2VkLlxuICAgIGxldCB3cmFwcGVkSHRtbCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgZGl2LmlubmVySFRNTCA9IHdyYXBwZWRIdG1sO1xuICAgIGxldCBbZmlyc3QsIGxhc3RdID0gbW92ZU5vZGVzQmVmb3JlKGRpdi5maXJzdENoaWxkLCBwYXJlbnQsIHJlZmVyZW5jZSk7XG4gICAgcmV0dXJuIG5ldyBDb25jcmV0ZUJvdW5kcyhwYXJlbnQsIGZpcnN0LCBsYXN0KTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFwcGx5Rml4KGRvY3VtZW50LCBzdmdOYW1lc3BhY2UpIHtcbiAgICBsZXQgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05hbWVzcGFjZSwgJ3N2ZycpO1xuICAgIHRyeSB7XG4gICAgICAgIHN2Z1snaW5zZXJ0QWRqYWNlbnRIVE1MJ10oJ2JlZm9yZWVuZCcsICc8Y2lyY2xlPjwvY2lyY2xlPicpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSUUsIEVkZ2U6IFdpbGwgdGhyb3csIGluc2VydEFkamFjZW50SFRNTCBpcyB1bnN1cHBvcnRlZCBvbiBTVkdcbiAgICAgICAgLy8gU2FmYXJpOiBXaWxsIHRocm93LCBpbnNlcnRBZGphY2VudEhUTUwgaXMgbm90IHByZXNlbnQgb24gU1ZHXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gRkY6IE9sZCB2ZXJzaW9ucyB3aWxsIGNyZWF0ZSBhIG5vZGUgaW4gdGhlIHdyb25nIG5hbWVzcGFjZVxuICAgICAgICBpZiAoc3ZnLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmIHVud3JhcChzdmcuZmlyc3RDaGlsZCkubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAvLyBUaGUgdGVzdCB3b3JrZWQgYXMgZXhwZWN0ZWQsIG5vIGZpeCByZXF1aXJlZFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0iXX0=