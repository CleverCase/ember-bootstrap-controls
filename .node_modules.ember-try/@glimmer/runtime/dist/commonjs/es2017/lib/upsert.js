'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isSafeString = isSafeString;
exports.isNode = isNode;
exports.isString = isString;
exports.cautiousInsert = cautiousInsert;
exports.trustingInsert = trustingInsert;

var _util = require('@glimmer/util');

var _bounds = require('./bounds');

function isSafeString(value) {
    return typeof value === 'object' && value !== null && typeof value.toHTML === 'function';
}
function isNode(value) {
    return typeof value === 'object' && value !== null && typeof value.nodeType === 'number';
}
function isString(value) {
    return typeof value === 'string';
}
class Upsert {
    constructor(bounds) {
        this.bounds = bounds;
    }
}
exports.default = Upsert;
function cautiousInsert(dom, cursor, value) {
    if (isString(value)) {
        return TextUpsert.insert(dom, cursor, value);
    }
    if (isSafeString(value)) {
        return SafeStringUpsert.insert(dom, cursor, value);
    }
    if (isNode(value)) {
        return NodeUpsert.insert(dom, cursor, value);
    }
    throw (0, _util.unreachable)();
}
function trustingInsert(dom, cursor, value) {
    if (isString(value)) {
        return HTMLUpsert.insert(dom, cursor, value);
    }
    if (isNode(value)) {
        return NodeUpsert.insert(dom, cursor, value);
    }
    throw (0, _util.unreachable)();
}
class TextUpsert extends Upsert {
    static insert(dom, cursor, value) {
        let textNode = dom.createTextNode(value);
        dom.insertBefore(cursor.element, textNode, cursor.nextSibling);
        let bounds = new _bounds.SingleNodeBounds(cursor.element, textNode);
        return new TextUpsert(bounds, textNode);
    }
    constructor(bounds, textNode) {
        super(bounds);
        this.textNode = textNode;
    }
    update(_dom, value) {
        if (isString(value)) {
            let { textNode } = this;
            textNode.nodeValue = value;
            return true;
        } else {
            return false;
        }
    }
}
class HTMLUpsert extends Upsert {
    static insert(dom, cursor, value) {
        let bounds = dom.insertHTMLBefore(cursor.element, cursor.nextSibling, value);
        return new HTMLUpsert(bounds);
    }
    update(dom, value) {
        if (isString(value)) {
            let { bounds } = this;
            let parentElement = bounds.parentElement();
            let nextSibling = (0, _bounds.clear)(bounds);
            this.bounds = dom.insertHTMLBefore(parentElement, nextSibling, value);
            return true;
        } else {
            return false;
        }
    }
}
class SafeStringUpsert extends Upsert {
    constructor(bounds, lastStringValue) {
        super(bounds);
        this.lastStringValue = lastStringValue;
    }
    static insert(dom, cursor, value) {
        let stringValue = value.toHTML();
        let bounds = dom.insertHTMLBefore(cursor.element, cursor.nextSibling, stringValue);
        return new SafeStringUpsert(bounds, stringValue);
    }
    update(dom, value) {
        if (isSafeString(value)) {
            let stringValue = value.toHTML();
            if (stringValue !== this.lastStringValue) {
                let { bounds } = this;
                let parentElement = bounds.parentElement();
                let nextSibling = (0, _bounds.clear)(bounds);
                this.bounds = dom.insertHTMLBefore(parentElement, nextSibling, stringValue);
                this.lastStringValue = stringValue;
            }
            return true;
        } else {
            return false;
        }
    }
}
class NodeUpsert extends Upsert {
    static insert(dom, cursor, node) {
        dom.insertBefore(cursor.element, node, cursor.nextSibling);
        return new NodeUpsert((0, _bounds.single)(cursor.element, node));
    }
    update(dom, value) {
        if (isNode(value)) {
            let { bounds } = this;
            let parentElement = bounds.parentElement();
            let nextSibling = (0, _bounds.clear)(bounds);
            this.bounds = dom.insertNodeBefore(parentElement, value, nextSibling);
            return true;
        } else {
            return false;
        }
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91cHNlcnQuanMiXSwibmFtZXMiOlsiaXNTYWZlU3RyaW5nIiwiaXNOb2RlIiwiaXNTdHJpbmciLCJjYXV0aW91c0luc2VydCIsInRydXN0aW5nSW5zZXJ0IiwidmFsdWUiLCJ0b0hUTUwiLCJub2RlVHlwZSIsIlVwc2VydCIsImNvbnN0cnVjdG9yIiwiYm91bmRzIiwiZG9tIiwiY3Vyc29yIiwiVGV4dFVwc2VydCIsImluc2VydCIsIlNhZmVTdHJpbmdVcHNlcnQiLCJOb2RlVXBzZXJ0IiwiSFRNTFVwc2VydCIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJlbGVtZW50IiwibmV4dFNpYmxpbmciLCJ1cGRhdGUiLCJfZG9tIiwibm9kZVZhbHVlIiwiaW5zZXJ0SFRNTEJlZm9yZSIsInBhcmVudEVsZW1lbnQiLCJsYXN0U3RyaW5nVmFsdWUiLCJzdHJpbmdWYWx1ZSIsIm5vZGUiLCJpbnNlcnROb2RlQmVmb3JlIl0sIm1hcHBpbmdzIjoiOzs7OztRQUVnQkEsWSxHQUFBQSxZO1FBR0FDLE0sR0FBQUEsTTtRQUdBQyxRLEdBQUFBLFE7UUFTQUMsYyxHQUFBQSxjO1FBWUFDLGMsR0FBQUEsYzs7QUE3QmhCOztBQUNBOztBQUNPLFNBQVNKLFlBQVQsQ0FBc0JLLEtBQXRCLEVBQTZCO0FBQ2hDLFdBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsVUFBVSxJQUF2QyxJQUErQyxPQUFPQSxNQUFNQyxNQUFiLEtBQXdCLFVBQTlFO0FBQ0g7QUFDTSxTQUFTTCxNQUFULENBQWdCSSxLQUFoQixFQUF1QjtBQUMxQixXQUFPLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLFVBQVUsSUFBdkMsSUFBK0MsT0FBT0EsTUFBTUUsUUFBYixLQUEwQixRQUFoRjtBQUNIO0FBQ00sU0FBU0wsUUFBVCxDQUFrQkcsS0FBbEIsRUFBeUI7QUFDNUIsV0FBTyxPQUFPQSxLQUFQLEtBQWlCLFFBQXhCO0FBQ0g7QUFDRCxNQUFN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QkFBTyxLQUFQO0FBQ0g7QUFDSjtBQXhCaUM7QUEwQnRDLE1BQU1iLFVBQU4sU0FBeUJSLE1BQXpCLENBQWdDO0FBQzVCLFdBQU9NLE1BQVAsQ0FBY0gsR0FBZCxFQUFtQkMsTUFBbkIsRUFBMkJrQixJQUEzQixFQUFpQztBQUM3Qm5CLFlBQUlTLFlBQUosQ0FBaUJSLE9BQU9TLE9BQXhCLEVBQWlDUyxJQUFqQyxFQUF1Q2xCLE9BQU9VLFdBQTlDO0FBQ0EsZUFBTyxJQUFJTixVQUFKLENBQWUsb0JBQU9KLE9BQU9TLE9BQWQsRUFBdUJTLElBQXZCLENBQWYsQ0FBUDtBQUNIO0FBQ0RQLFdBQU9aLEdBQVAsRUFBWU4sS0FBWixFQUFtQjtBQUNmLFlBQUlKLE9BQU9JLEtBQVAsQ0FBSixFQUFtQjtBQUNmLGdCQUFJLEVBQUVLLE1BQUYsS0FBYSxJQUFqQjtBQUNBLGdCQUFJaUIsZ0JBQWdCakIsT0FBT2lCLGFBQVAsRUFBcEI7QUFDQSxnQkFBSUwsY0FBYyxtQkFBTVosTUFBTixDQUFsQjtBQUNBLGlCQUFLQSxNQUFMLEdBQWNDLElBQUlvQixnQkFBSixDQUFxQkosYUFBckIsRUFBb0N0QixLQUFwQyxFQUEyQ2lCLFdBQTNDLENBQWQ7QUFDQSxtQkFBTyxJQUFQO0FBQ0gsU0FORCxNQU1PO0FBQ0gsbUJBQU8sS0FBUDtBQUNIO0FBQ0o7QUFmMkIiLCJmaWxlIjoibGliL3Vwc2VydC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVucmVhY2hhYmxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBjbGVhciwgc2luZ2xlLCBTaW5nbGVOb2RlQm91bmRzIH0gZnJvbSAnLi9ib3VuZHMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmZVN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b0hUTUwgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLm5vZGVUeXBlID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuY2xhc3MgVXBzZXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihib3VuZHMpIHtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBib3VuZHM7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVXBzZXJ0O1xuZXhwb3J0IGZ1bmN0aW9uIGNhdXRpb3VzSW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFRleHRVcHNlcnQuaW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc1NhZmVTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBTYWZlU3RyaW5nVXBzZXJ0Lmluc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTm9kZVVwc2VydC5pbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgICB9XG4gICAgdGhyb3cgdW5yZWFjaGFibGUoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cnVzdGluZ0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpIHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBIVE1MVXBzZXJ0Lmluc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTm9kZVVwc2VydC5pbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgICB9XG4gICAgdGhyb3cgdW5yZWFjaGFibGUoKTtcbn1cbmNsYXNzIFRleHRVcHNlcnQgZXh0ZW5kcyBVcHNlcnQge1xuICAgIHN0YXRpYyBpbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IGRvbS5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgICAgIGRvbS5pbnNlcnRCZWZvcmUoY3Vyc29yLmVsZW1lbnQsIHRleHROb2RlLCBjdXJzb3IubmV4dFNpYmxpbmcpO1xuICAgICAgICBsZXQgYm91bmRzID0gbmV3IFNpbmdsZU5vZGVCb3VuZHMoY3Vyc29yLmVsZW1lbnQsIHRleHROb2RlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0VXBzZXJ0KGJvdW5kcywgdGV4dE5vZGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihib3VuZHMsIHRleHROb2RlKSB7XG4gICAgICAgIHN1cGVyKGJvdW5kcyk7XG4gICAgICAgIHRoaXMudGV4dE5vZGUgPSB0ZXh0Tm9kZTtcbiAgICB9XG4gICAgdXBkYXRlKF9kb20sIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCB7IHRleHROb2RlIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGV4dE5vZGUubm9kZVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEhUTUxVcHNlcnQgZXh0ZW5kcyBVcHNlcnQge1xuICAgIHN0YXRpYyBpbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIGxldCBib3VuZHMgPSBkb20uaW5zZXJ0SFRNTEJlZm9yZShjdXJzb3IuZWxlbWVudCwgY3Vyc29yLm5leHRTaWJsaW5nLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgSFRNTFVwc2VydChib3VuZHMpO1xuICAgIH1cbiAgICB1cGRhdGUoZG9tLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgeyBib3VuZHMgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgcGFyZW50RWxlbWVudCA9IGJvdW5kcy5wYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICBsZXQgbmV4dFNpYmxpbmcgPSBjbGVhcihib3VuZHMpO1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMgPSBkb20uaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnRFbGVtZW50LCBuZXh0U2libGluZywgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTYWZlU3RyaW5nVXBzZXJ0IGV4dGVuZHMgVXBzZXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcihib3VuZHMsIGxhc3RTdHJpbmdWYWx1ZSkge1xuICAgICAgICBzdXBlcihib3VuZHMpO1xuICAgICAgICB0aGlzLmxhc3RTdHJpbmdWYWx1ZSA9IGxhc3RTdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGluc2VydChkb20sIGN1cnNvciwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHN0cmluZ1ZhbHVlID0gdmFsdWUudG9IVE1MKCk7XG4gICAgICAgIGxldCBib3VuZHMgPSBkb20uaW5zZXJ0SFRNTEJlZm9yZShjdXJzb3IuZWxlbWVudCwgY3Vyc29yLm5leHRTaWJsaW5nLCBzdHJpbmdWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgU2FmZVN0cmluZ1Vwc2VydChib3VuZHMsIHN0cmluZ1ZhbHVlKTtcbiAgICB9XG4gICAgdXBkYXRlKGRvbSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzU2FmZVN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBzdHJpbmdWYWx1ZSA9IHZhbHVlLnRvSFRNTCgpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ1ZhbHVlICE9PSB0aGlzLmxhc3RTdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCB7IGJvdW5kcyB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50RWxlbWVudCA9IGJvdW5kcy5wYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gY2xlYXIoYm91bmRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kcyA9IGRvbS5pbnNlcnRIVE1MQmVmb3JlKHBhcmVudEVsZW1lbnQsIG5leHRTaWJsaW5nLCBzdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0U3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgTm9kZVVwc2VydCBleHRlbmRzIFVwc2VydCB7XG4gICAgc3RhdGljIGluc2VydChkb20sIGN1cnNvciwgbm9kZSkge1xuICAgICAgICBkb20uaW5zZXJ0QmVmb3JlKGN1cnNvci5lbGVtZW50LCBub2RlLCBjdXJzb3IubmV4dFNpYmxpbmcpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVVcHNlcnQoc2luZ2xlKGN1cnNvci5lbGVtZW50LCBub2RlKSk7XG4gICAgfVxuICAgIHVwZGF0ZShkb20sIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc05vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgeyBib3VuZHMgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgcGFyZW50RWxlbWVudCA9IGJvdW5kcy5wYXJlbnRFbGVtZW50KCk7XG4gICAgICAgICAgICBsZXQgbmV4dFNpYmxpbmcgPSBjbGVhcihib3VuZHMpO1xuICAgICAgICAgICAgdGhpcy5ib3VuZHMgPSBkb20uaW5zZXJ0Tm9kZUJlZm9yZShwYXJlbnRFbGVtZW50LCB2YWx1ZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59Il19