'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.setDebuggerCallback = setDebuggerCallback;
exports.resetDebuggerCallback = resetDebuggerCallback;

var _util = require('@glimmer/util');

var _opcodes = require('../../opcodes');

/* tslint:disable */
function debugCallback(context, get) {
    console.info('Use `context`, and `get(<path>)` to debug this template.');
    // for example...
    context === get('this');
    debugger;
}
/* tslint:enable */
let callback = debugCallback;
// For testing purposes
function setDebuggerCallback(cb) {
    callback = cb;
}
function resetDebuggerCallback() {
    callback = debugCallback;
}
class ScopeInspector {
    constructor(scope, symbols, evalInfo) {
        this.scope = scope;
        this.locals = (0, _util.dict)();
        for (let i = 0; i < evalInfo.length; i++) {
            let slot = evalInfo[i];
            let name = symbols[slot - 1];
            let ref = scope.getSymbol(slot);
            this.locals[name] = ref;
        }
    }
    get(path) {
        let { scope, locals } = this;
        let parts = path.split('.');
        let [head, ...tail] = path.split('.');
        let evalScope = scope.getEvalScope();
        let ref;
        if (head === 'this') {
            ref = scope.getSelf();
        } else if (locals[head]) {
            ref = locals[head];
        } else if (head.indexOf('@') === 0 && evalScope[head]) {
            ref = evalScope[head];
        } else {
            ref = this.scope.getSelf();
            tail = parts;
        }
        return tail.reduce((r, part) => r.get(part), ref);
    }
}
_opcodes.APPEND_OPCODES.add(71 /* Debugger */, (vm, { op1: _symbols, op2: _evalInfo }) => {
    let symbols = vm.constants.getOther(_symbols);
    let evalInfo = vm.constants.getArray(_evalInfo);
    let inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
    callback(vm.getSelf().value(), path => inspector.get(path).value());
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21waWxlZC9vcGNvZGVzL2RlYnVnZ2VyLmpzIl0sIm5hbWVzIjpbInNldERlYnVnZ2VyQ2FsbGJhY2siLCJyZXNldERlYnVnZ2VyQ2FsbGJhY2siLCJkZWJ1Z0NhbGxiYWNrIiwiY29udGV4dCIsImdldCIsImNvbnNvbGUiLCJpbmZvIiwiY2FsbGJhY2siLCJjYiIsIlNjb3BlSW5zcGVjdG9yIiwiY29uc3RydWN0b3IiLCJzY29wZSIsInN5bWJvbHMiLCJldmFsSW5mbyIsImxvY2FscyIsImkiLCJsZW5ndGgiLCJzbG90IiwibmFtZSIsInJlZiIsImdldFN5bWJvbCIsInBhdGgiLCJwYXJ0cyIsInNwbGl0IiwiaGVhZCIsInRhaWwiLCJldmFsU2NvcGUiLCJnZXRFdmFsU2NvcGUiLCJnZXRTZWxmIiwiaW5kZXhPZiIsInJlZHVjZSIsInIiLCJwYXJ0IiwiYWRkIiwidm0iLCJvcDEiLCJfc3ltYm9scyIsIm9wMiIsIl9ldmFsSW5mbyIsImNvbnN0YW50cyIsImdldE90aGVyIiwiZ2V0QXJyYXkiLCJpbnNwZWN0b3IiLCJ2YWx1ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUFZZ0JBLG1CLEdBQUFBLG1CO1FBR0FDLHFCLEdBQUFBLHFCOztBQWZoQjs7QUFDQTs7QUFDQTtBQUNBLFNBQVNDLGFBQVQsQ0FBdUJDLE9BQXZCLEVBQWdDQyxHQUFoQyxFQUFxQztBQUNqQ0MsWUFBUUMsSUFBUixDQUFhLDBEQUFiO0FBQ0E7QUFDQUgsZ0JBQVlDLElBQUksTUFBSixDQUFaO0FBQ0E7QUFDSDtBQUNEO0FBQ0EsSUFBSUcsV0FBV0wsYUFBZjtBQUNBO0FBQ08sU0FBU0YsbUJBQVQsQ0FBNkJRLEVBQTdCLEVBQWlDO0FBQ3BDRCxlQUFXQyxFQUFYO0FBQ0g7QUFDTSxTQUFTUCxxQkFBVCxHQUFpQztBQUNwQ00sZUFBV0wsYUFBWDtBQUNIO0FBQ0QsTUFBTU8sY0FBTixDQUFxQjtBQUNqQkMsZ0JBQVlDLEtBQVosRUFBbUJDLE9BQW5CLEVBQTRCQyxRQUE1QixFQUFzQztBQUNsQyxhQUFLRixLQUFMLEdBQWFBLEtBQWI7QUFDQSxhQUFLRyxNQUFMLEdBQWMsaUJBQWQ7QUFDQSxhQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsU0FBU0csTUFBN0IsRUFBcUNELEdBQXJDLEVBQTBDO0FBQ3RDLGdCQUFJRSxPQUFPSixTQUFTRSxDQUFULENBQVg7QUFDQSxnQkFBSUcsT0FBT04sUUFBUUssT0FBTyxDQUFmLENBQVg7QUFDQSxnQkFBSUUsTUFBTVIsTUFBTVMsU0FBTixDQUFnQkgsSUFBaEIsQ0FBVjtBQUNBLGlCQUFLSCxNQUFMLENBQVlJLElBQVosSUFBb0JDLEdBQXBCO0FBQ0g7QUFDSjtBQUNEZixRQUFJaUIsSUFBSixFQUFVO0FBQ04sWUFBSSxFQUFFVixLQUFGLEVBQVNHLE1BQVQsS0FBb0IsSUFBeEI7QUFDQSxZQUFJUSxRQUFRRCxLQUFLRSxLQUFMLENBQVcsR0FBWCxDQUFaO0FBQ0EsWUFBSSxDQUFDQyxJQUFELEVBQU8sR0FBR0MsSUFBVixJQUFrQkosS0FBS0UsS0FBTCxDQUFXLEdBQVgsQ0FBdEI7QUFDQSxZQUFJRyxZQUFZZixNQUFNZ0IsWUFBTixFQUFoQjtBQUNBLFlBQUlSLEdBQUo7QUFDQSxZQUFJSyxTQUFTLE1BQWIsRUFBcUI7QUFDakJMLGtCQUFNUixNQUFNaUIsT0FBTixFQUFOO0FBQ0gsU0FGRCxNQUVPLElBQUlkLE9BQU9VLElBQVAsQ0FBSixFQUFrQjtBQUNyQkwsa0JBQU1MLE9BQU9VLElBQVAsQ0FBTjtBQUNILFNBRk0sTUFFQSxJQUFJQSxLQUFLSyxPQUFMLENBQWEsR0FBYixNQUFzQixDQUF0QixJQUEyQkgsVUFBVUYsSUFBVixDQUEvQixFQUFnRDtBQUNuREwsa0JBQU1PLFVBQVVGLElBQVYsQ0FBTjtBQUNILFNBRk0sTUFFQTtBQUNITCxrQkFBTSxLQUFLUixLQUFMLENBQVdpQixPQUFYLEVBQU47QUFDQUgsbUJBQU9ILEtBQVA7QUFDSDtBQUNELGVBQU9HLEtBQUtLLE1BQUwsQ0FBWSxDQUFDQyxDQUFELEVBQUlDLElBQUosS0FBYUQsRUFBRTNCLEdBQUYsQ0FBTTRCLElBQU4sQ0FBekIsRUFBc0NiLEdBQXRDLENBQVA7QUFDSDtBQTVCZ0I7QUE4QnJCLHdCQUFlYyxHQUFmLENBQW1CLEVBQW5CLENBQXNCLGNBQXRCLEVBQXNDLENBQUNDLEVBQUQsRUFBSyxFQUFFQyxLQUFLQyxRQUFQLEVBQWlCQyxLQUFLQyxTQUF0QixFQUFMLEtBQTJDO0FBQzdFLFFBQUkxQixVQUFVc0IsR0FBR0ssU0FBSCxDQUFhQyxRQUFiLENBQXNCSixRQUF0QixDQUFkO0FBQ0EsUUFBSXZCLFdBQVdxQixHQUFHSyxTQUFILENBQWFFLFFBQWIsQ0FBc0JILFNBQXRCLENBQWY7QUFDQSxRQUFJSSxZQUFZLElBQUlqQyxjQUFKLENBQW1CeUIsR0FBR3ZCLEtBQUgsRUFBbkIsRUFBK0JDLE9BQS9CLEVBQXdDQyxRQUF4QyxDQUFoQjtBQUNBTixhQUFTMkIsR0FBR04sT0FBSCxHQUFhZSxLQUFiLEVBQVQsRUFBK0J0QixRQUFRcUIsVUFBVXRDLEdBQVYsQ0FBY2lCLElBQWQsRUFBb0JzQixLQUFwQixFQUF2QztBQUNILENBTEQiLCJmaWxlIjoibGliL2NvbXBpbGVkL29wY29kZXMvZGVidWdnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkaWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUyB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbmZ1bmN0aW9uIGRlYnVnQ2FsbGJhY2soY29udGV4dCwgZ2V0KSB7XG4gICAgY29uc29sZS5pbmZvKCdVc2UgYGNvbnRleHRgLCBhbmQgYGdldCg8cGF0aD4pYCB0byBkZWJ1ZyB0aGlzIHRlbXBsYXRlLicpO1xuICAgIC8vIGZvciBleGFtcGxlLi4uXG4gICAgY29udGV4dCA9PT0gZ2V0KCd0aGlzJyk7XG4gICAgZGVidWdnZXI7XG59XG4vKiB0c2xpbnQ6ZW5hYmxlICovXG5sZXQgY2FsbGJhY2sgPSBkZWJ1Z0NhbGxiYWNrO1xuLy8gRm9yIHRlc3RpbmcgcHVycG9zZXNcbmV4cG9ydCBmdW5jdGlvbiBzZXREZWJ1Z2dlckNhbGxiYWNrKGNiKSB7XG4gICAgY2FsbGJhY2sgPSBjYjtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNldERlYnVnZ2VyQ2FsbGJhY2soKSB7XG4gICAgY2FsbGJhY2sgPSBkZWJ1Z0NhbGxiYWNrO1xufVxuY2xhc3MgU2NvcGVJbnNwZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlLCBzeW1ib2xzLCBldmFsSW5mbykge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMubG9jYWxzID0gZGljdCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2YWxJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc2xvdCA9IGV2YWxJbmZvW2ldO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBzeW1ib2xzW3Nsb3QgLSAxXTtcbiAgICAgICAgICAgIGxldCByZWYgPSBzY29wZS5nZXRTeW1ib2woc2xvdCk7XG4gICAgICAgICAgICB0aGlzLmxvY2Fsc1tuYW1lXSA9IHJlZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQocGF0aCkge1xuICAgICAgICBsZXQgeyBzY29wZSwgbG9jYWxzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBbaGVhZCwgLi4udGFpbF0gPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBldmFsU2NvcGUgPSBzY29wZS5nZXRFdmFsU2NvcGUoKTtcbiAgICAgICAgbGV0IHJlZjtcbiAgICAgICAgaWYgKGhlYWQgPT09ICd0aGlzJykge1xuICAgICAgICAgICAgcmVmID0gc2NvcGUuZ2V0U2VsZigpO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2Fsc1toZWFkXSkge1xuICAgICAgICAgICAgcmVmID0gbG9jYWxzW2hlYWRdO1xuICAgICAgICB9IGVsc2UgaWYgKGhlYWQuaW5kZXhPZignQCcpID09PSAwICYmIGV2YWxTY29wZVtoZWFkXSkge1xuICAgICAgICAgICAgcmVmID0gZXZhbFNjb3BlW2hlYWRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmID0gdGhpcy5zY29wZS5nZXRTZWxmKCk7XG4gICAgICAgICAgICB0YWlsID0gcGFydHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhaWwucmVkdWNlKChyLCBwYXJ0KSA9PiByLmdldChwYXJ0KSwgcmVmKTtcbiAgICB9XG59XG5BUFBFTkRfT1BDT0RFUy5hZGQoNzEgLyogRGVidWdnZXIgKi8sICh2bSwgeyBvcDE6IF9zeW1ib2xzLCBvcDI6IF9ldmFsSW5mbyB9KSA9PiB7XG4gICAgbGV0IHN5bWJvbHMgPSB2bS5jb25zdGFudHMuZ2V0T3RoZXIoX3N5bWJvbHMpO1xuICAgIGxldCBldmFsSW5mbyA9IHZtLmNvbnN0YW50cy5nZXRBcnJheShfZXZhbEluZm8pO1xuICAgIGxldCBpbnNwZWN0b3IgPSBuZXcgU2NvcGVJbnNwZWN0b3Iodm0uc2NvcGUoKSwgc3ltYm9scywgZXZhbEluZm8pO1xuICAgIGNhbGxiYWNrKHZtLmdldFNlbGYoKS52YWx1ZSgpLCBwYXRoID0+IGluc3BlY3Rvci5nZXQocGF0aCkudmFsdWUoKSk7XG59KTsiXX0=