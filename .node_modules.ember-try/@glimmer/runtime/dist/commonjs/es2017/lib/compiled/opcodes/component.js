'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DidUpdateLayoutOpcode = exports.UpdateComponentOpcode = undefined;

var _reference = require('@glimmer/reference');

var _opcodes = require('../../opcodes');

var _arguments = require('../../vm/arguments');

var _arguments2 = _interopRequireDefault(_arguments);

var _dom = require('./dom');

var _vm2 = require('./vm');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_opcodes.APPEND_OPCODES.add(56 /* PushComponentManager */, (vm, { op1: _definition }) => {
    let definition = vm.constants.getOther(_definition);
    let stack = vm.stack;
    stack.push({ definition, manager: definition.manager, component: null });
});
_opcodes.APPEND_OPCODES.add(57 /* PushDynamicComponentManager */, vm => {
    let stack = vm.stack;
    let reference = stack.pop();
    let cache = (0, _reference.isConst)(reference) ? undefined : new _reference.ReferenceCache(reference);
    let definition = cache ? cache.peek() : reference.value();
    stack.push({ definition, manager: definition.manager, component: null });
    if (cache) {
        vm.updateWith(new _vm2.Assert(cache));
    }
});
_opcodes.APPEND_OPCODES.add(58 /* PushArgs */, (vm, { op1: synthetic }) => {
    let stack = vm.stack;
    _arguments2.default.setup(stack, !!synthetic);
    stack.push(_arguments2.default);
});
_opcodes.APPEND_OPCODES.add(59 /* PrepareArgs */, (vm, { op1: _state }) => {
    let stack = vm.stack;
    let { definition, manager } = vm.fetchValue(_state);
    let args = stack.pop();
    let preparedArgs = manager.prepareArgs(definition, args);
    if (preparedArgs) {
        args.clear();
        let { positional, named } = preparedArgs;
        let positionalCount = positional.length;
        for (let i = 0; i < positionalCount; i++) {
            stack.push(positional[i]);
        }
        stack.push(positionalCount);
        let names = Object.keys(named);
        let namedCount = names.length;
        let atNames = [];
        for (let i = 0; i < namedCount; i++) {
            let value = named[names[i]];
            let atName = `@${names[i]}`;
            stack.push(value);
            atNames.push(atName);
        }
        stack.push(atNames);
        args.setup(stack, false);
    }
    stack.push(args);
});
_opcodes.APPEND_OPCODES.add(60 /* CreateComponent */, (vm, { op1: flags, op2: _state }) => {
    let definition;
    let manager;
    let args = vm.stack.pop();
    let dynamicScope = vm.dynamicScope();
    let state = ({ definition, manager } = vm.fetchValue(_state));
    let hasDefaultBlock = flags & 1;
    let component = manager.create(vm.env, definition, args, dynamicScope, vm.getSelf(), !!hasDefaultBlock);
    state.component = component;
    vm.updateWith(new UpdateComponentOpcode(args.tag, definition.name, component, manager, dynamicScope));
});
_opcodes.APPEND_OPCODES.add(61 /* RegisterComponentDestructor */, (vm, { op1: _state }) => {
    let { manager, component } = vm.fetchValue(_state);
    let destructor = manager.getDestructor(component);
    if (destructor) vm.newDestroyable(destructor);
});
_opcodes.APPEND_OPCODES.add(65 /* BeginComponentTransaction */, vm => {
    vm.beginCacheGroup();
    vm.elements().pushSimpleBlock();
});
_opcodes.APPEND_OPCODES.add(62 /* PushComponentOperations */, vm => {
    vm.stack.push(new _dom.ComponentElementOperations(vm.env));
});
_opcodes.APPEND_OPCODES.add(67 /* DidCreateElement */, (vm, { op1: _state }) => {
    let { manager, component } = vm.fetchValue(_state);
    let action = 'DidCreateElementOpcode#evaluate';
    manager.didCreateElement(component, vm.elements().expectConstructing(action), vm.elements().expectOperations(action));
});
_opcodes.APPEND_OPCODES.add(63 /* GetComponentSelf */, (vm, { op1: _state }) => {
    let state = vm.fetchValue(_state);
    vm.stack.push(state.manager.getSelf(state.component));
});
_opcodes.APPEND_OPCODES.add(64 /* GetComponentLayout */, (vm, { op1: _state }) => {
    let { manager, definition, component } = vm.fetchValue(_state);
    vm.stack.push(manager.layoutFor(definition, component, vm.env));
});
_opcodes.APPEND_OPCODES.add(68 /* DidRenderLayout */, (vm, { op1: _state }) => {
    let { manager, component } = vm.fetchValue(_state);
    let bounds = vm.elements().popBlock();
    manager.didRenderLayout(component, bounds);
    vm.env.didCreate(component, manager);
    vm.updateWith(new DidUpdateLayoutOpcode(manager, component, bounds));
});
_opcodes.APPEND_OPCODES.add(66 /* CommitComponentTransaction */, vm => vm.commitCacheGroup());
class UpdateComponentOpcode extends _opcodes.UpdatingOpcode {
    constructor(tag, name, component, manager, dynamicScope) {
        super();
        this.name = name;
        this.component = component;
        this.manager = manager;
        this.dynamicScope = dynamicScope;
        this.type = 'update-component';
        let componentTag = manager.getTag(component);
        if (componentTag) {
            this.tag = (0, _reference.combine)([tag, componentTag]);
        } else {
            this.tag = tag;
        }
    }
    evaluate(_vm) {
        let { component, manager, dynamicScope } = this;
        manager.update(component, dynamicScope);
    }
    toJSON() {
        return {
            args: [JSON.stringify(this.name)],
            guid: this._guid,
            type: this.type
        };
    }
}
exports.UpdateComponentOpcode = UpdateComponentOpcode;
class DidUpdateLayoutOpcode extends _opcodes.UpdatingOpcode {
    constructor(manager, component, bounds) {
        super();
        this.manager = manager;
        this.component = component;
        this.bounds = bounds;
        this.type = 'did-update-layout';
        this.tag = _reference.CONSTANT_TAG;
    }
    evaluate(vm) {
        let { manager, component, bounds } = this;
        manager.didUpdateLayout(component, bounds);
        vm.env.didUpdate(component, manager);
    }
}
exports.DidUpdateLayoutOpcode = DidUpdateLayoutOpcode;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21waWxlZC9vcGNvZGVzL2NvbXBvbmVudC5qcyJdLCJuYW1lcyI6WyJhZGQiLCJ2bSIsIm9wMSIsIl9kZWZpbml0aW9uIiwiZGVmaW5pdGlvbiIsImNvbnN0YW50cyIsImdldE90aGVyIiwic3RhY2siLCJwdXNoIiwibWFuYWdlciIsImNvbXBvbmVudCIsInJlZmVyZW5jZSIsInBvcCIsImNhY2hlIiwidW5kZWZpbmVkIiwicGVlayIsInZhbHVlIiwidXBkYXRlV2l0aCIsInN5bnRoZXRpYyIsInNldHVwIiwiX3N0YXRlIiwiZmV0Y2hWYWx1ZSIsImFyZ3MiLCJwcmVwYXJlZEFyZ3MiLCJwcmVwYXJlQXJncyIsImNsZWFyIiwicG9zaXRpb25hbCIsIm5hbWVkIiwicG9zaXRpb25hbENvdW50IiwibGVuZ3RoIiwiaSIsIm5hbWVzIiwiT2JqZWN0Iiwia2V5cyIsIm5hbWVkQ291bnQiLCJhdE5hbWVzIiwiYXROYW1lIiwiZmxhZ3MiLCJvcDIiLCJkeW5hbWljU2NvcGUiLCJzdGF0ZSIsImhhc0RlZmF1bHRCbG9jayIsImNyZWF0ZSIsImVudiIsImdldFNlbGYiLCJVcGRhdGVDb21wb25lbnRPcGNvZGUiLCJ0YWciLCJuYW1lIiwiZGVzdHJ1Y3RvciIsImdldERlc3RydWN0b3IiLCJuZXdEZXN0cm95YWJsZSIsImJlZ2luQ2FjaGVHcm91cCIsImVsZW1lbnRzIiwicHVzaFNpbXBsZUJsb2NrIiwiYWN0aW9uIiwiZGlkQ3JlYXRlRWxlbWVudCIsImV4cGVjdENvbnN0cnVjdGluZyIsImV4cGVjdE9wZXJhdGlvbnMiLCJsYXlvdXRGb3IiLCJib3VuZHMiLCJwb3BCbG9jayIsImRpZFJlbmRlckxheW91dCIsImRpZENyZWF0ZSIsIkRpZFVwZGF0ZUxheW91dE9wY29kZSIsImNvbW1pdENhY2hlR3JvdXAiLCJjb25zdHJ1Y3RvciIsInR5cGUiLCJjb21wb25lbnRUYWciLCJnZXRUYWciLCJldmFsdWF0ZSIsIl92bSIsInVwZGF0ZSIsInRvSlNPTiIsIkpTT04iLCJzdHJpbmdpZnkiLCJndWlkIiwiX2d1aWQiLCJkaWRVcGRhdGVMYXlvdXQiLCJkaWRVcGRhdGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0Esd0JBQWVBLEdBQWYsQ0FBbUIsRUFBbkIsQ0FBc0IsMEJBQXRCLEVBQWtELENBQUNDLEVBQUQsRUFBSyxFQUFFQyxLQUFLQyxXQUFQLEVBQUwsS0FBOEI7QUFDNUUsUUFBSUMsYUFBYUgsR0FBR0ksU0FBSCxDQUFhQyxRQUFiLENBQXNCSCxXQUF0QixDQUFqQjtBQUNBLFFBQUlJLFFBQVFOLEdBQUdNLEtBQWY7QUFDQUEsVUFBTUMsSUFBTixDQUFXLEVBQUVKLFVBQUYsRUFBY0ssU0FBU0wsV0FBV0ssT0FBbEMsRUFBMkNDLFdBQVcsSUFBdEQsRUFBWDtBQUNILENBSkQ7QUFLQSx3QkFBZVYsR0FBZixDQUFtQixFQUFuQixDQUFzQixpQ0FBdEIsRUFBeURDLE1BQU07QUFDM0QsUUFBSU0sUUFBUU4sR0FBR00sS0FBZjtBQUNBLFFBQUlJLFlBQVlKLE1BQU1LLEdBQU4sRUFBaEI7QUFDQSxRQUFJQyxRQUFRLHdCQUFRRixTQUFSLElBQXFCRyxTQUFyQixHQUFpQyw4QkFBbUJILFNBQW5CLENBQTdDO0FBQ0EsUUFBSVAsYUFBYVMsUUFBUUEsTUFBTUUsSUFBTixFQUFSLEdBQXVCSixVQUFVSyxLQUFWLEVBQXhDO0FBQ0FULFVBQU1DLElBQU4sQ0FBVyxFQUFFSixVQUFGLEVBQWNLLFNBQVNMLFdBQVdLLE9BQWxDLEVBQTJDQyxXQUFXLElBQXRELEVBQVg7QUFDQSxRQUFJRyxLQUFKLEVBQVc7QUFDUFosV0FBR2dCLFVBQUgsQ0FBYyxnQkFBV0osS0FBWCxDQUFkO0FBQ0g7QUFDSixDQVREO0FBVUEsd0JBQWViLEdBQWYsQ0FBbUIsRUFBbkIsQ0FBc0IsY0FBdEIsRUFBc0MsQ0FBQ0MsRUFBRCxFQUFLLEVBQUVDLEtBQUtnQixTQUFQLEVBQUwsS0FBNEI7QUFDOUQsUUFBSVgsUUFBUU4sR0FBR00sS0FBZjtBQUNBLHdCQUFLWSxLQUFMLENBQVdaLEtBQVgsRUFBa0IsQ0FBQyxDQUFDVyxTQUFwQjtBQUNBWCxVQUFNQyxJQUFOO0FBQ0gsQ0FKRDtBQUtBLHdCQUFlUixHQUFmLENBQW1CLEVBQW5CLENBQXNCLGlCQUF0QixFQUF5QyxDQUFDQyxFQUFELEVBQUssRUFBRUMsS0FBS2tCLE1BQVAsRUFBTCxLQUF5QjtBQUM5RCxRQUFJYixRQUFRTixHQUFHTSxLQUFmO0FBQ0EsUUFBSSxFQUFFSCxVQUFGLEVBQWNLLE9BQWQsS0FBMEJSLEdBQUdvQixVQUFILENBQWNELE1BQWQsQ0FBOUI7QUFDQSxRQUFJRSxPQUFPZixNQUFNSyxHQUFOLEVBQVg7QUFDQSxRQUFJVyxlQUFlZCxRQUFRZSxXQUFSLENBQW9CcEIsVUFBcEIsRUFBZ0NrQixJQUFoQyxDQUFuQjtBQUNBLFFBQUlDLFlBQUosRUFBa0I7QUFDZEQsYUFBS0csS0FBTDtBQUNBLFlBQUksRUFBRUMsVUFBRixFQUFjQyxLQUFkLEtBQXdCSixZQUE1QjtBQUNBLFlBQUlLLGtCQUFrQkYsV0FBV0csTUFBakM7QUFDQSxhQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsZUFBcEIsRUFBcUNFLEdBQXJDLEVBQTBDO0FBQ3RDdkIsa0JBQU1DLElBQU4sQ0FBV2tCLFdBQVdJLENBQVgsQ0FBWDtBQUNIO0FBQ0R2QixjQUFNQyxJQUFOLENBQVdvQixlQUFYO0FBQ0EsWUFBSUcsUUFBUUMsT0FBT0MsSUFBUCxDQUFZTixLQUFaLENBQVo7QUFDQSxZQUFJTyxhQUFhSCxNQUFNRixNQUF2QjtBQUNBLFlBQUlNLFVBQVUsRUFBZDtBQUNBLGFBQUssSUFBSUwsSUFBSSxDQUFiLEVBQWdCQSxJQUFJSSxVQUFwQixFQUFnQ0osR0FBaEMsRUFBcUM7QUFDakMsZ0JBQUlkLFFBQVFXLE1BQU1JLE1BQU1ELENBQU4sQ0FBTixDQUFaO0FBQ0EsZ0JBQUlNLFNBQVUsSUFBR0wsTUFBTUQsQ0FBTixDQUFTLEVBQTFCO0FBQ0F2QixrQkFBTUMsSUFBTixDQUFXUSxLQUFYO0FBQ0FtQixvQkFBUTNCLElBQVIsQ0FBYTRCLE1BQWI7QUFDSDtBQUNEN0IsY0FBTUMsSUFBTixDQUFXMkIsT0FBWDtBQUNBYixhQUFLSCxLQUFMLENBQVdaLEtBQVgsRUFBa0IsS0FBbEI7QUFDSDtBQUNEQSxVQUFNQyxJQUFOLENBQVdjLElBQVg7QUFDSCxDQTFCRDtBQTJCQSx3QkFBZXRCLEdBQWYsQ0FBbUIsRUFBbkIsQ0FBc0IscUJBQXRCLEVBQTZDLENBQUNDLEVBQUQsRUFBSyxFQUFFQyxLQUFLbUMsS0FBUCxFQUFjQyxLQUFLbEIsTUFBbkIsRUFBTCxLQUFxQztBQUM5RSxRQUFJaEIsVUFBSjtBQUNBLFFBQUlLLE9BQUo7QUFDQSxRQUFJYSxPQUFPckIsR0FBR00sS0FBSCxDQUFTSyxHQUFULEVBQVg7QUFDQSxRQUFJMkIsZUFBZXRDLEdBQUdzQyxZQUFILEVBQW5CO0FBQ0EsUUFBSUMsU0FBUyxFQUFFcEMsVUFBRixFQUFjSyxPQUFkLEtBQTBCUixHQUFHb0IsVUFBSCxDQUFjRCxNQUFkLENBQW5DLENBQUo7QUFDQSxRQUFJcUIsa0JBQWtCSixRQUFRLENBQTlCO0FBQ0EsUUFBSTNCLFlBQVlELFFBQVFpQyxNQUFSLENBQWV6QyxHQUFHMEMsR0FBbEIsRUFBdUJ2QyxVQUF2QixFQUFtQ2tCLElBQW5DLEVBQXlDaUIsWUFBekMsRUFBdUR0QyxHQUFHMkMsT0FBSCxFQUF2RCxFQUFxRSxDQUFDLENBQUNILGVBQXZFLENBQWhCO0FBQ0FELFVBQU05QixTQUFOLEdBQWtCQSxTQUFsQjtBQUNBVCxPQUFHZ0IsVUFBSCxDQUFjLElBQUk0QixxQkFBSixDQUEwQnZCLEtBQUt3QixHQUEvQixFQUFvQzFDLFdBQVcyQyxJQUEvQyxFQUFxRHJDLFNBQXJELEVBQWdFRCxPQUFoRSxFQUF5RThCLFlBQXpFLENBQWQ7QUFDSCxDQVZEO0FBV0Esd0JBQWV2QyxHQUFmLENBQW1CLEVBQW5CLENBQXNCLGlDQUF0QixFQUF5RCxDQUFDQyxFQUFELEVBQUssRUFBRUMsS0FBS2tCLE1BQVAsRUFBTCxLQUF5QjtBQUM5RSxRQUFJLEVBQUVYLE9BQUYsRUFBV0MsU0FBWCxLQUF5QlQsR0FBR29CLFVBQUgsQ0FBY0QsTUFBZCxDQUE3QjtBQUNBLFFBQUk0QixhQUFhdkMsUUFBUXdDLGFBQVIsQ0FBc0J2QyxTQUF0QixDQUFqQjtBQUNBLFFBQUlzQyxVQUFKLEVBQWdCL0MsR0FBR2lELGNBQUgsQ0FBa0JGLFVBQWxCO0FBQ25CLENBSkQ7QUFLQSx3QkFBZWhELEdBQWYsQ0FBbUIsRUFBbkIsQ0FBc0IsK0JBQXRCLEVBQXVEQyxNQUFNO0FBQ3pEQSxPQUFHa0QsZUFBSDtBQUNBbEQsT0FBR21ELFFBQUgsR0FBY0MsZUFBZDtBQUNILENBSEQ7QUFJQSx3QkFBZXJELEdBQWYsQ0FBbUIsRUFBbkIsQ0FBc0IsNkJBQXRCLEVBQXFEQyxNQUFNO0FBQ3ZEQSxPQUFHTSxLQUFILENBQVNDLElBQVQsQ0FBYyxvQ0FBK0JQLEdBQUcwQyxHQUFsQyxDQUFkO0FBQ0gsQ0FGRDtBQUdBLHdCQUFlM0MsR0FBZixDQUFtQixFQUFuQixDQUFzQixzQkFBdEIsRUFBOEMsQ0FBQ0MsRUFBRCxFQUFLLEVBQUVDLEtBQUtrQixNQUFQLEVBQUwsS0FBeUI7QUFDbkUsUUFBSSxFQUFFWCxPQUFGLEVBQVdDLFNBQVgsS0FBeUJULEdBQUdvQixVQUFILENBQWNELE1BQWQsQ0FBN0I7QUFDQSxRQUFJa0MsU0FBUyxpQ0FBYjtBQUNBN0MsWUFBUThDLGdCQUFSLENBQXlCN0MsU0FBekIsRUFBb0NULEdBQUdtRCxRQUFILEdBQWNJLGtCQUFkLENBQWlDRixNQUFqQyxDQUFwQyxFQUE4RXJELEdBQUdtRCxRQUFILEdBQWNLLGdCQUFkLENBQStCSCxNQUEvQixDQUE5RTtBQUNILENBSkQ7QUFLQSx3QkFBZXRELEdBQWYsQ0FBbUIsRUFBbkIsQ0FBc0Isc0JBQXRCLEVBQThDLENBQUNDLEVBQUQsRUFBSyxFQUFFQyxLQUFLa0IsTUFBUCxFQUFMLEtBQXlCO0FBQ25FLFFBQUlvQixRQUFRdkMsR0FBR29CLFVBQUgsQ0FBY0QsTUFBZCxDQUFaO0FBQ0FuQixPQUFHTSxLQUFILENBQVNDLElBQVQsQ0FBY2dDLE1BQU0vQixPQUFOLENBQWNtQyxPQUFkLENBQXNCSixNQUFNOUIsU0FBNUIsQ0FBZDtBQUNILENBSEQ7QUFJQSx3QkFBZVYsR0FBZixDQUFtQixFQUFuQixDQUFzQix3QkFBdEIsRUFBZ0QsQ0FBQ0MsRUFBRCxFQUFLLEVBQUVDLEtBQUtrQixNQUFQLEVBQUwsS0FBeUI7QUFDckUsUUFBSSxFQUFFWCxPQUFGLEVBQVdMLFVBQVgsRUFBdUJNLFNBQXZCLEtBQXFDVCxHQUFHb0IsVUFBSCxDQUFjRCxNQUFkLENBQXpDO0FBQ0FuQixPQUFHTSxLQUFILENBQVNDLElBQVQsQ0FBY0MsUUFBUWlELFNBQVIsQ0FBa0J0RCxVQUFsQixFQUE4Qk0sU0FBOUIsRUFBeUNULEdBQUcwQyxHQUE1QyxDQUFkO0FBQ0gsQ0FIRDtBQUlBLHdCQUFlM0MsR0FBZixDQUFtQixFQUFuQixDQUFzQixxQkFBdEIsRUFBNkMsQ0FBQ0MsRUFBRCxFQUFLLEVBQUVDLEtBQUtrQixNQUFQLEVBQUwsS0FBeUI7QUFDbEUsUUFBSSxFQUFFWCxPQUFGLEVBQVdDLFNBQVgsS0FBeUJULEdBQUdvQixVQUFILENBQWNELE1BQWQsQ0FBN0I7QUFDQSxRQUFJdUMsU0FBUzFELEdBQUdtRCxRQUFILEdBQWNRLFFBQWQsRUFBYjtBQUNBbkQsWUFBUW9ELGVBQVIsQ0FBd0JuRCxTQUF4QixFQUFtQ2lELE1BQW5DO0FBQ0ExRCxPQUFHMEMsR0FBSCxDQUFPbUIsU0FBUCxDQUFpQnBELFNBQWpCLEVBQTRCRCxPQUE1QjtBQUNBUixPQUFHZ0IsVUFBSCxDQUFjLElBQUk4QyxxQkFBSixDQUEwQnRELE9BQTFCLEVBQW1DQyxTQUFuQyxFQUE4Q2lELE1BQTlDLENBQWQ7QUFDSCxDQU5EO0FBT0Esd0JBQWUzRCxHQUFmLENBQW1CLEVBQW5CLENBQXNCLGdDQUF0QixFQUF3REMsTUFBTUEsR0FBRytELGdCQUFILEVBQTlEO0FBQ08sTUFBTW5CLHFCQUFOLGlDQUFtRDtBQUN0RG9CLGdCQUFZbkIsR0FBWixFQUFpQkMsSUFBakIsRUFBdUJyQyxTQUF2QixFQUFrQ0QsT0FBbEMsRUFBMkM4QixZQUEzQyxFQUF5RDtBQUNyRDtBQUNBLGFBQUtRLElBQUwsR0FBWUEsSUFBWjtBQUNBLGFBQUtyQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLGFBQUtELE9BQUwsR0FBZUEsT0FBZjtBQUNBLGFBQUs4QixZQUFMLEdBQW9CQSxZQUFwQjtBQUNBLGFBQUsyQixJQUFMLEdBQVksa0JBQVo7QUFDQSxZQUFJQyxlQUFlMUQsUUFBUTJELE1BQVIsQ0FBZTFELFNBQWYsQ0FBbkI7QUFDQSxZQUFJeUQsWUFBSixFQUFrQjtBQUNkLGlCQUFLckIsR0FBTCxHQUFXLHdCQUFRLENBQUNBLEdBQUQsRUFBTXFCLFlBQU4sQ0FBUixDQUFYO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsaUJBQUtyQixHQUFMLEdBQVdBLEdBQVg7QUFDSDtBQUNKO0FBQ0R1QixhQUFTQyxHQUFULEVBQWM7QUFDVixZQUFJLEVBQUU1RCxTQUFGLEVBQWFELE9BQWIsRUFBc0I4QixZQUF0QixLQUF1QyxJQUEzQztBQUNBOUIsZ0JBQVE4RCxNQUFSLENBQWU3RCxTQUFmLEVBQTBCNkIsWUFBMUI7QUFDSDtBQUNEaUMsYUFBUztBQUNMLGVBQU87QUFDSGxELGtCQUFNLENBQUNtRCxLQUFLQyxTQUFMLENBQWUsS0FBSzNCLElBQXBCLENBQUQsQ0FESDtBQUVINEIsa0JBQU0sS0FBS0MsS0FGUjtBQUdIVixrQkFBTSxLQUFLQTtBQUhSLFNBQVA7QUFLSDtBQXpCcUQ7UUFBN0NyQixxQixHQUFBQSxxQjtBQTJCTixNQUFNa0IscUJBQU4saUNBQW1EO0FBQ3RERSxnQkFBWXhELE9BQVosRUFBcUJDLFNBQXJCLEVBQWdDaUQsTUFBaEMsRUFBd0M7QUFDcEM7QUFDQSxhQUFLbEQsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsYUFBS0MsU0FBTCxHQUFpQkEsU0FBakI7QUFDQSxhQUFLaUQsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBS08sSUFBTCxHQUFZLG1CQUFaO0FBQ0EsYUFBS3BCLEdBQUw7QUFDSDtBQUNEdUIsYUFBU3BFLEVBQVQsRUFBYTtBQUNULFlBQUksRUFBRVEsT0FBRixFQUFXQyxTQUFYLEVBQXNCaUQsTUFBdEIsS0FBaUMsSUFBckM7QUFDQWxELGdCQUFRb0UsZUFBUixDQUF3Qm5FLFNBQXhCLEVBQW1DaUQsTUFBbkM7QUFDQTFELFdBQUcwQyxHQUFILENBQU9tQyxTQUFQLENBQWlCcEUsU0FBakIsRUFBNEJELE9BQTVCO0FBQ0g7QUFicUQ7UUFBN0NzRCxxQixHQUFBQSxxQiIsImZpbGUiOiJsaWIvY29tcGlsZWQvb3Bjb2Rlcy9jb21wb25lbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21iaW5lLCBDT05TVEFOVF9UQUcsIGlzQ29uc3QsIFJlZmVyZW5jZUNhY2hlIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTLCBVcGRhdGluZ09wY29kZSB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuaW1wb3J0IEFSR1MgZnJvbSAnLi4vLi4vdm0vYXJndW1lbnRzJztcbmltcG9ydCB7IENvbXBvbmVudEVsZW1lbnRPcGVyYXRpb25zIH0gZnJvbSAnLi9kb20nO1xuaW1wb3J0IHsgQXNzZXJ0IH0gZnJvbSAnLi92bSc7XG5BUFBFTkRfT1BDT0RFUy5hZGQoNTYgLyogUHVzaENvbXBvbmVudE1hbmFnZXIgKi8sICh2bSwgeyBvcDE6IF9kZWZpbml0aW9uIH0pID0+IHtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IHZtLmNvbnN0YW50cy5nZXRPdGhlcihfZGVmaW5pdGlvbik7XG4gICAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gICAgc3RhY2sucHVzaCh7IGRlZmluaXRpb24sIG1hbmFnZXI6IGRlZmluaXRpb24ubWFuYWdlciwgY29tcG9uZW50OiBudWxsIH0pO1xufSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoNTcgLyogUHVzaER5bmFtaWNDb21wb25lbnRNYW5hZ2VyICovLCB2bSA9PiB7XG4gICAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gICAgbGV0IHJlZmVyZW5jZSA9IHN0YWNrLnBvcCgpO1xuICAgIGxldCBjYWNoZSA9IGlzQ29uc3QocmVmZXJlbmNlKSA/IHVuZGVmaW5lZCA6IG5ldyBSZWZlcmVuY2VDYWNoZShyZWZlcmVuY2UpO1xuICAgIGxldCBkZWZpbml0aW9uID0gY2FjaGUgPyBjYWNoZS5wZWVrKCkgOiByZWZlcmVuY2UudmFsdWUoKTtcbiAgICBzdGFjay5wdXNoKHsgZGVmaW5pdGlvbiwgbWFuYWdlcjogZGVmaW5pdGlvbi5tYW5hZ2VyLCBjb21wb25lbnQ6IG51bGwgfSk7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIHZtLnVwZGF0ZVdpdGgobmV3IEFzc2VydChjYWNoZSkpO1xuICAgIH1cbn0pO1xuQVBQRU5EX09QQ09ERVMuYWRkKDU4IC8qIFB1c2hBcmdzICovLCAodm0sIHsgb3AxOiBzeW50aGV0aWMgfSkgPT4ge1xuICAgIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICAgIEFSR1Muc2V0dXAoc3RhY2ssICEhc3ludGhldGljKTtcbiAgICBzdGFjay5wdXNoKEFSR1MpO1xufSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoNTkgLyogUHJlcGFyZUFyZ3MgKi8sICh2bSwgeyBvcDE6IF9zdGF0ZSB9KSA9PiB7XG4gICAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gICAgbGV0IHsgZGVmaW5pdGlvbiwgbWFuYWdlciB9ID0gdm0uZmV0Y2hWYWx1ZShfc3RhdGUpO1xuICAgIGxldCBhcmdzID0gc3RhY2sucG9wKCk7XG4gICAgbGV0IHByZXBhcmVkQXJncyA9IG1hbmFnZXIucHJlcGFyZUFyZ3MoZGVmaW5pdGlvbiwgYXJncyk7XG4gICAgaWYgKHByZXBhcmVkQXJncykge1xuICAgICAgICBhcmdzLmNsZWFyKCk7XG4gICAgICAgIGxldCB7IHBvc2l0aW9uYWwsIG5hbWVkIH0gPSBwcmVwYXJlZEFyZ3M7XG4gICAgICAgIGxldCBwb3NpdGlvbmFsQ291bnQgPSBwb3NpdGlvbmFsLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbmFsQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgc3RhY2sucHVzaChwb3NpdGlvbmFsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHBvc2l0aW9uYWxDb3VudCk7XG4gICAgICAgIGxldCBuYW1lcyA9IE9iamVjdC5rZXlzKG5hbWVkKTtcbiAgICAgICAgbGV0IG5hbWVkQ291bnQgPSBuYW1lcy5sZW5ndGg7XG4gICAgICAgIGxldCBhdE5hbWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZWRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBuYW1lZFtuYW1lc1tpXV07XG4gICAgICAgICAgICBsZXQgYXROYW1lID0gYEAke25hbWVzW2ldfWA7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGF0TmFtZXMucHVzaChhdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2goYXROYW1lcyk7XG4gICAgICAgIGFyZ3Muc2V0dXAoc3RhY2ssIGZhbHNlKTtcbiAgICB9XG4gICAgc3RhY2sucHVzaChhcmdzKTtcbn0pO1xuQVBQRU5EX09QQ09ERVMuYWRkKDYwIC8qIENyZWF0ZUNvbXBvbmVudCAqLywgKHZtLCB7IG9wMTogZmxhZ3MsIG9wMjogX3N0YXRlIH0pID0+IHtcbiAgICBsZXQgZGVmaW5pdGlvbjtcbiAgICBsZXQgbWFuYWdlcjtcbiAgICBsZXQgYXJncyA9IHZtLnN0YWNrLnBvcCgpO1xuICAgIGxldCBkeW5hbWljU2NvcGUgPSB2bS5keW5hbWljU2NvcGUoKTtcbiAgICBsZXQgc3RhdGUgPSAoeyBkZWZpbml0aW9uLCBtYW5hZ2VyIH0gPSB2bS5mZXRjaFZhbHVlKF9zdGF0ZSkpO1xuICAgIGxldCBoYXNEZWZhdWx0QmxvY2sgPSBmbGFncyAmIDE7XG4gICAgbGV0IGNvbXBvbmVudCA9IG1hbmFnZXIuY3JlYXRlKHZtLmVudiwgZGVmaW5pdGlvbiwgYXJncywgZHluYW1pY1Njb3BlLCB2bS5nZXRTZWxmKCksICEhaGFzRGVmYXVsdEJsb2NrKTtcbiAgICBzdGF0ZS5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgVXBkYXRlQ29tcG9uZW50T3Bjb2RlKGFyZ3MudGFnLCBkZWZpbml0aW9uLm5hbWUsIGNvbXBvbmVudCwgbWFuYWdlciwgZHluYW1pY1Njb3BlKSk7XG59KTtcbkFQUEVORF9PUENPREVTLmFkZCg2MSAvKiBSZWdpc3RlckNvbXBvbmVudERlc3RydWN0b3IgKi8sICh2bSwgeyBvcDE6IF9zdGF0ZSB9KSA9PiB7XG4gICAgbGV0IHsgbWFuYWdlciwgY29tcG9uZW50IH0gPSB2bS5mZXRjaFZhbHVlKF9zdGF0ZSk7XG4gICAgbGV0IGRlc3RydWN0b3IgPSBtYW5hZ2VyLmdldERlc3RydWN0b3IoY29tcG9uZW50KTtcbiAgICBpZiAoZGVzdHJ1Y3Rvcikgdm0ubmV3RGVzdHJveWFibGUoZGVzdHJ1Y3Rvcik7XG59KTtcbkFQUEVORF9PUENPREVTLmFkZCg2NSAvKiBCZWdpbkNvbXBvbmVudFRyYW5zYWN0aW9uICovLCB2bSA9PiB7XG4gICAgdm0uYmVnaW5DYWNoZUdyb3VwKCk7XG4gICAgdm0uZWxlbWVudHMoKS5wdXNoU2ltcGxlQmxvY2soKTtcbn0pO1xuQVBQRU5EX09QQ09ERVMuYWRkKDYyIC8qIFB1c2hDb21wb25lbnRPcGVyYXRpb25zICovLCB2bSA9PiB7XG4gICAgdm0uc3RhY2sucHVzaChuZXcgQ29tcG9uZW50RWxlbWVudE9wZXJhdGlvbnModm0uZW52KSk7XG59KTtcbkFQUEVORF9PUENPREVTLmFkZCg2NyAvKiBEaWRDcmVhdGVFbGVtZW50ICovLCAodm0sIHsgb3AxOiBfc3RhdGUgfSkgPT4ge1xuICAgIGxldCB7IG1hbmFnZXIsIGNvbXBvbmVudCB9ID0gdm0uZmV0Y2hWYWx1ZShfc3RhdGUpO1xuICAgIGxldCBhY3Rpb24gPSAnRGlkQ3JlYXRlRWxlbWVudE9wY29kZSNldmFsdWF0ZSc7XG4gICAgbWFuYWdlci5kaWRDcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgdm0uZWxlbWVudHMoKS5leHBlY3RDb25zdHJ1Y3RpbmcoYWN0aW9uKSwgdm0uZWxlbWVudHMoKS5leHBlY3RPcGVyYXRpb25zKGFjdGlvbikpO1xufSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoNjMgLyogR2V0Q29tcG9uZW50U2VsZiAqLywgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2bS5mZXRjaFZhbHVlKF9zdGF0ZSk7XG4gICAgdm0uc3RhY2sucHVzaChzdGF0ZS5tYW5hZ2VyLmdldFNlbGYoc3RhdGUuY29tcG9uZW50KSk7XG59KTtcbkFQUEVORF9PUENPREVTLmFkZCg2NCAvKiBHZXRDb21wb25lbnRMYXlvdXQgKi8sICh2bSwgeyBvcDE6IF9zdGF0ZSB9KSA9PiB7XG4gICAgbGV0IHsgbWFuYWdlciwgZGVmaW5pdGlvbiwgY29tcG9uZW50IH0gPSB2bS5mZXRjaFZhbHVlKF9zdGF0ZSk7XG4gICAgdm0uc3RhY2sucHVzaChtYW5hZ2VyLmxheW91dEZvcihkZWZpbml0aW9uLCBjb21wb25lbnQsIHZtLmVudikpO1xufSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoNjggLyogRGlkUmVuZGVyTGF5b3V0ICovLCAodm0sIHsgb3AxOiBfc3RhdGUgfSkgPT4ge1xuICAgIGxldCB7IG1hbmFnZXIsIGNvbXBvbmVudCB9ID0gdm0uZmV0Y2hWYWx1ZShfc3RhdGUpO1xuICAgIGxldCBib3VuZHMgPSB2bS5lbGVtZW50cygpLnBvcEJsb2NrKCk7XG4gICAgbWFuYWdlci5kaWRSZW5kZXJMYXlvdXQoY29tcG9uZW50LCBib3VuZHMpO1xuICAgIHZtLmVudi5kaWRDcmVhdGUoY29tcG9uZW50LCBtYW5hZ2VyKTtcbiAgICB2bS51cGRhdGVXaXRoKG5ldyBEaWRVcGRhdGVMYXlvdXRPcGNvZGUobWFuYWdlciwgY29tcG9uZW50LCBib3VuZHMpKTtcbn0pO1xuQVBQRU5EX09QQ09ERVMuYWRkKDY2IC8qIENvbW1pdENvbXBvbmVudFRyYW5zYWN0aW9uICovLCB2bSA9PiB2bS5jb21taXRDYWNoZUdyb3VwKCkpO1xuZXhwb3J0IGNsYXNzIFVwZGF0ZUNvbXBvbmVudE9wY29kZSBleHRlbmRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIG5hbWUsIGNvbXBvbmVudCwgbWFuYWdlciwgZHluYW1pY1Njb3BlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgICB0aGlzLmR5bmFtaWNTY29wZSA9IGR5bmFtaWNTY29wZTtcbiAgICAgICAgdGhpcy50eXBlID0gJ3VwZGF0ZS1jb21wb25lbnQnO1xuICAgICAgICBsZXQgY29tcG9uZW50VGFnID0gbWFuYWdlci5nZXRUYWcoY29tcG9uZW50KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudFRhZykge1xuICAgICAgICAgICAgdGhpcy50YWcgPSBjb21iaW5lKFt0YWcsIGNvbXBvbmVudFRhZ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXZhbHVhdGUoX3ZtKSB7XG4gICAgICAgIGxldCB7IGNvbXBvbmVudCwgbWFuYWdlciwgZHluYW1pY1Njb3BlIH0gPSB0aGlzO1xuICAgICAgICBtYW5hZ2VyLnVwZGF0ZShjb21wb25lbnQsIGR5bmFtaWNTY29wZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyZ3M6IFtKU09OLnN0cmluZ2lmeSh0aGlzLm5hbWUpXSxcbiAgICAgICAgICAgIGd1aWQ6IHRoaXMuX2d1aWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGlkVXBkYXRlTGF5b3V0T3Bjb2RlIGV4dGVuZHMgVXBkYXRpbmdPcGNvZGUge1xuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGNvbXBvbmVudCwgYm91bmRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmJvdW5kcyA9IGJvdW5kcztcbiAgICAgICAgdGhpcy50eXBlID0gJ2RpZC11cGRhdGUtbGF5b3V0JztcbiAgICAgICAgdGhpcy50YWcgPSBDT05TVEFOVF9UQUc7XG4gICAgfVxuICAgIGV2YWx1YXRlKHZtKSB7XG4gICAgICAgIGxldCB7IG1hbmFnZXIsIGNvbXBvbmVudCwgYm91bmRzIH0gPSB0aGlzO1xuICAgICAgICBtYW5hZ2VyLmRpZFVwZGF0ZUxheW91dChjb21wb25lbnQsIGJvdW5kcyk7XG4gICAgICAgIHZtLmVudi5kaWRVcGRhdGUoY29tcG9uZW50LCBtYW5hZ2VyKTtcbiAgICB9XG59Il19