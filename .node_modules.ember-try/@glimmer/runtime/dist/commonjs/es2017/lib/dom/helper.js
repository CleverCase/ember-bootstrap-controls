'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DOMTreeConstruction = exports.DOMChanges = exports.DOM = exports.DOMOperations = exports.BLACKLIST_TABLE = exports.SVG_NAMESPACE = undefined;
exports.isWhitespace = isWhitespace;
exports.moveNodesBefore = moveNodesBefore;
exports.insertHTMLBefore = insertHTMLBefore;

var _bounds = require('../bounds');

var _innerHtmlFix = require('../compat/inner-html-fix');

var _svgInnerHtmlFix = require('../compat/svg-inner-html-fix');

var _textNodeMergingFix = require('../compat/text-node-merging-fix');

const SVG_NAMESPACE = exports.SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
// http://www.w3.org/TR/html/syntax.html#html-integration-point
const SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };
// http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes
// TODO: Adjust SVG attributes
// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
// TODO: Adjust SVG elements
// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
const BLACKLIST_TABLE = exports.BLACKLIST_TABLE = Object.create(null);
["b", "big", "blockquote", "body", "br", "center", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "i", "img", "li", "listing", "main", "meta", "nobr", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "strike", "sub", "sup", "table", "tt", "u", "ul", "var"].forEach(tag => BLACKLIST_TABLE[tag] = 1);
const WHITESPACE = /[\t-\r \xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/;
let doc = typeof document === 'undefined' ? null : document;
function isWhitespace(string) {
    return WHITESPACE.test(string);
}
function moveNodesBefore(source, target, nextSibling) {
    let first = source.firstChild;
    let last = null;
    let current = first;
    while (current) {
        last = current;
        current = current.nextSibling;
        target.insertBefore(last, nextSibling);
    }
    return [first, last];
}
class DOMOperations {
    constructor(document) {
        this.document = document;
        this.setupUselessElement();
    }
    // split into seperate method so that NodeDOMTreeConstruction
    // can override it.
    setupUselessElement() {
        this.uselessElement = this.document.createElement('div');
    }
    createElement(tag, context) {
        let isElementInSVGNamespace, isHTMLIntegrationPoint;
        if (context) {
            isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE || tag === 'svg';
            isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];
        } else {
            isElementInSVGNamespace = tag === 'svg';
            isHTMLIntegrationPoint = false;
        }
        if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
            // FIXME: This does not properly handle <font> with color, face, or
            // size attributes, which is also disallowed by the spec. We should fix
            // this.
            if (BLACKLIST_TABLE[tag]) {
                throw new Error(`Cannot create a ${tag} inside an SVG context`);
            }
            return this.document.createElementNS(SVG_NAMESPACE, tag);
        } else {
            return this.document.createElement(tag);
        }
    }
    insertBefore(parent, node, reference) {
        parent.insertBefore(node, reference);
    }
    insertHTMLBefore(_parent, nextSibling, html) {
        return insertHTMLBefore(this.uselessElement, _parent, nextSibling, html);
    }
    createTextNode(text) {
        return this.document.createTextNode(text);
    }
    createComment(data) {
        return this.document.createComment(data);
    }
}
exports.DOMOperations = DOMOperations;
var DOM = exports.DOM = undefined;
(function (DOM) {
    class TreeConstruction extends DOMOperations {
        createElementNS(namespace, tag) {
            return this.document.createElementNS(namespace, tag);
        }
        setAttribute(element, name, value, namespace) {
            if (namespace) {
                element.setAttributeNS(namespace, name, value);
            } else {
                element.setAttribute(name, value);
            }
        }
    }
    DOM.TreeConstruction = TreeConstruction;
    let appliedTreeContruction = TreeConstruction;
    appliedTreeContruction = (0, _textNodeMergingFix.treeConstruction)(doc, appliedTreeContruction);
    appliedTreeContruction = (0, _innerHtmlFix.treeConstruction)(doc, appliedTreeContruction);
    appliedTreeContruction = (0, _svgInnerHtmlFix.treeConstruction)(doc, appliedTreeContruction, SVG_NAMESPACE);
    DOM.DOMTreeConstruction = appliedTreeContruction;
})(DOM || (exports.DOM = DOM = {}));
class DOMChanges extends DOMOperations {
    constructor(document) {
        super(document);
        this.document = document;
        this.namespace = null;
    }
    setAttribute(element, name, value) {
        element.setAttribute(name, value);
    }
    setAttributeNS(element, namespace, name, value) {
        element.setAttributeNS(namespace, name, value);
    }
    removeAttribute(element, name) {
        element.removeAttribute(name);
    }
    removeAttributeNS(element, namespace, name) {
        element.removeAttributeNS(namespace, name);
    }
    insertNodeBefore(parent, node, reference) {
        if (isDocumentFragment(node)) {
            let { firstChild, lastChild } = node;
            this.insertBefore(parent, node, reference);
            return new _bounds.ConcreteBounds(parent, firstChild, lastChild);
        } else {
            this.insertBefore(parent, node, reference);
            return new _bounds.SingleNodeBounds(parent, node);
        }
    }
    insertTextBefore(parent, nextSibling, text) {
        let textNode = this.createTextNode(text);
        this.insertBefore(parent, textNode, nextSibling);
        return textNode;
    }
    insertBefore(element, node, reference) {
        element.insertBefore(node, reference);
    }
    insertAfter(element, node, reference) {
        this.insertBefore(element, node, reference.nextSibling);
    }
}
exports.DOMChanges = DOMChanges;
function insertHTMLBefore(_useless, _parent, _nextSibling, html) {
    // TypeScript vendored an old version of the DOM spec where `insertAdjacentHTML`
    // only exists on `HTMLElement` but not on `Element`. We actually work with the
    // newer version of the DOM API here (and monkey-patch this method in `./compat`
    // when we detect older browsers). This is a hack to work around this limitation.
    let parent = _parent;
    let useless = _useless;
    let nextSibling = _nextSibling;
    let prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
    let last;
    if (html === null || html === '') {
        return new _bounds.ConcreteBounds(parent, null, null);
    }
    if (nextSibling === null) {
        parent.insertAdjacentHTML('beforeend', html);
        last = parent.lastChild;
    } else if (nextSibling instanceof HTMLElement) {
        nextSibling.insertAdjacentHTML('beforebegin', html);
        last = nextSibling.previousSibling;
    } else {
        // Non-element nodes do not support insertAdjacentHTML, so add an
        // element and call it on that element. Then remove the element.
        //
        // This also protects Edge, IE and Firefox w/o the inspector open
        // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts
        parent.insertBefore(useless, nextSibling);
        useless.insertAdjacentHTML('beforebegin', html);
        last = useless.previousSibling;
        parent.removeChild(useless);
    }
    let first = prev ? prev.nextSibling : parent.firstChild;
    return new _bounds.ConcreteBounds(parent, first, last);
}
function isDocumentFragment(node) {
    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
let helper = DOMChanges;
helper = (0, _textNodeMergingFix.domChanges)(doc, helper);
helper = (0, _innerHtmlFix.domChanges)(doc, helper);
helper = (0, _svgInnerHtmlFix.domChanges)(doc, helper, SVG_NAMESPACE);
exports.default = helper;
const DOMTreeConstruction = exports.DOMTreeConstruction = DOM.DOMTreeConstruction;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kb20vaGVscGVyLmpzIl0sIm5hbWVzIjpbImlzV2hpdGVzcGFjZSIsIm1vdmVOb2Rlc0JlZm9yZSIsImluc2VydEhUTUxCZWZvcmUiLCJTVkdfTkFNRVNQQUNFIiwiU1ZHX0lOVEVHUkFUSU9OX1BPSU5UUyIsImZvcmVpZ25PYmplY3QiLCJkZXNjIiwidGl0bGUiLCJCTEFDS0xJU1RfVEFCTEUiLCJPYmplY3QiLCJjcmVhdGUiLCJmb3JFYWNoIiwidGFnIiwiV0hJVEVTUEFDRSIsImRvYyIsImRvY3VtZW50Iiwic3RyaW5nIiwidGVzdCIsInNvdXJjZSIsInRhcmdldCIsIm5leHRTaWJsaW5nIiwiZmlyc3QiLCJmaXJzdENoaWxkIiwibGFzdCIsImN1cnJlbnQiLCJpbnNlcnRCZWZvcmUiLCJET01PcGVyYXRpb25zIiwiY29uc3RydWN0b3IiLCJzZXR1cFVzZWxlc3NFbGVtZW50IiwidXNlbGVzc0VsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY29udGV4dCIsImlzRWxlbWVudEluU1ZHTmFtZXNwYWNlIiwiaXNIVE1MSW50ZWdyYXRpb25Qb2ludCIsIm5hbWVzcGFjZVVSSSIsInRhZ05hbWUiLCJFcnJvciIsImNyZWF0ZUVsZW1lbnROUyIsInBhcmVudCIsIm5vZGUiLCJyZWZlcmVuY2UiLCJfcGFyZW50IiwiaHRtbCIsImNyZWF0ZVRleHROb2RlIiwidGV4dCIsImNyZWF0ZUNvbW1lbnQiLCJkYXRhIiwiRE9NIiwiVHJlZUNvbnN0cnVjdGlvbiIsIm5hbWVzcGFjZSIsInNldEF0dHJpYnV0ZSIsImVsZW1lbnQiLCJuYW1lIiwidmFsdWUiLCJzZXRBdHRyaWJ1dGVOUyIsImFwcGxpZWRUcmVlQ29udHJ1Y3Rpb24iLCJET01UcmVlQ29uc3RydWN0aW9uIiwiRE9NQ2hhbmdlcyIsInJlbW92ZUF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiaW5zZXJ0Tm9kZUJlZm9yZSIsImlzRG9jdW1lbnRGcmFnbWVudCIsImxhc3RDaGlsZCIsImluc2VydFRleHRCZWZvcmUiLCJ0ZXh0Tm9kZSIsImluc2VydEFmdGVyIiwiX3VzZWxlc3MiLCJfbmV4dFNpYmxpbmciLCJ1c2VsZXNzIiwicHJldiIsInByZXZpb3VzU2libGluZyIsImluc2VydEFkamFjZW50SFRNTCIsIkhUTUxFbGVtZW50IiwicmVtb3ZlQ2hpbGQiLCJub2RlVHlwZSIsIk5vZGUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiaGVscGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7UUFnQmdCQSxZLEdBQUFBLFk7UUFHQUMsZSxHQUFBQSxlO1FBb0hBQyxnQixHQUFBQSxnQjs7QUF2SWhCOztBQUNBOztBQUNBOztBQUNBOztBQUNPLE1BQU1DLHdDQUFnQiw0QkFBdEI7QUFDUDtBQUNBLE1BQU1DLHlCQUF5QixFQUFFQyxlQUFlLENBQWpCLEVBQW9CQyxNQUFNLENBQTFCLEVBQTZCQyxPQUFPLENBQXBDLEVBQS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU1DLDRDQUFrQkMsT0FBT0MsTUFBUCxDQUFjLElBQWQsQ0FBeEI7QUFDUCxDQUFDLEdBQUQsRUFBTSxLQUFOLEVBQWEsWUFBYixFQUEyQixNQUEzQixFQUFtQyxJQUFuQyxFQUF5QyxRQUF6QyxFQUFtRCxNQUFuRCxFQUEyRCxJQUEzRCxFQUFpRSxLQUFqRSxFQUF3RSxJQUF4RSxFQUE4RSxJQUE5RSxFQUFvRixJQUFwRixFQUEwRixPQUExRixFQUFtRyxJQUFuRyxFQUF5RyxJQUF6RyxFQUErRyxJQUEvRyxFQUFxSCxJQUFySCxFQUEySCxJQUEzSCxFQUFpSSxJQUFqSSxFQUF1SSxNQUF2SSxFQUErSSxJQUEvSSxFQUFxSixHQUFySixFQUEwSixLQUExSixFQUFpSyxJQUFqSyxFQUF1SyxTQUF2SyxFQUFrTCxNQUFsTCxFQUEwTCxNQUExTCxFQUFrTSxNQUFsTSxFQUEwTSxJQUExTSxFQUFnTixHQUFoTixFQUFxTixLQUFyTixFQUE0TixNQUE1TixFQUFvTyxHQUFwTyxFQUF5TyxPQUF6TyxFQUFrUCxNQUFsUCxFQUEw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QyxPQUFwQixFQUE2QmhELFdBQTdCO0FBQ0FnRCxnQkFBUUcsa0JBQVIsQ0FBMkIsYUFBM0IsRUFBMEM3QixJQUExQztBQUNBbkIsZUFBTzZDLFFBQVFFLGVBQWY7QUFDQWhDLGVBQU9tQyxXQUFQLENBQW1CTCxPQUFuQjtBQUNIO0FBQ0QsUUFBSS9DLFFBQVFnRCxPQUFPQSxLQUFLakQsV0FBWixHQUEwQmtCLE9BQU9oQixVQUE3QztBQUNBLFdBQU8sMkJBQW1CZ0IsTUFBbkIsRUFBMkJqQixLQUEzQixFQUFrQ0UsSUFBbEMsQ0FBUDtBQUNIO0FBQ0QsU0FBU3NDLGtCQUFULENBQTRCdEIsSUFBNUIsRUFBa0M7QUFDOUIsV0FBT0EsS0FBS21DLFFBQUwsS0FBa0JDLEtBQUtDLHNCQUE5QjtBQUNIO0FBQ0QsSUFBSUMsU0FBU3BCLFVBQWI7QUFDQW9CLFNBQVMsb0NBQXlCL0QsR0FBekIsRUFBOEIrRCxNQUE5QixDQUFUO0FBQ0FBLFNBQVMsOEJBQTBCL0QsR0FBMUIsRUFBK0IrRCxNQUEvQixDQUFUO0FBQ0FBLFNBQVMsaUNBQXdCL0QsR0FBeEIsRUFBNkIrRCxNQUE3QixFQUFxQzFFLGFBQXJDLENBQVQ7a0JBQ2UwRSxNO0FBQ1IsTUFBTXJCLG9EQUFzQlQsSUFBSVMsbUJBQWhDIiwiZmlsZSI6ImxpYi9kb20vaGVscGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29uY3JldGVCb3VuZHMsIFNpbmdsZU5vZGVCb3VuZHMgfSBmcm9tICcuLi9ib3VuZHMnO1xuaW1wb3J0IHsgZG9tQ2hhbmdlcyBhcyBkb21DaGFuZ2VzVGFibGVFbGVtZW50Rml4LCB0cmVlQ29uc3RydWN0aW9uIGFzIHRyZWVDb25zdHJ1Y3Rpb25UYWJsZUVsZW1lbnRGaXggfSBmcm9tICcuLi9jb21wYXQvaW5uZXItaHRtbC1maXgnO1xuaW1wb3J0IHsgZG9tQ2hhbmdlcyBhcyBkb21DaGFuZ2VzU3ZnRWxlbWVudEZpeCwgdHJlZUNvbnN0cnVjdGlvbiBhcyB0cmVlQ29uc3RydWN0aW9uU3ZnRWxlbWVudEZpeCB9IGZyb20gJy4uL2NvbXBhdC9zdmctaW5uZXItaHRtbC1maXgnO1xuaW1wb3J0IHsgZG9tQ2hhbmdlcyBhcyBkb21DaGFuZ2VzTm9kZU1lcmdpbmdGaXgsIHRyZWVDb25zdHJ1Y3Rpb24gYXMgdHJlZUNvbnN0cnVjdGlvbk5vZGVNZXJnaW5nRml4IH0gZnJvbSAnLi4vY29tcGF0L3RleHQtbm9kZS1tZXJnaW5nLWZpeCc7XG5leHBvcnQgY29uc3QgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbmNvbnN0IFNWR19JTlRFR1JBVElPTl9QT0lOVFMgPSB7IGZvcmVpZ25PYmplY3Q6IDEsIGRlc2M6IDEsIHRpdGxlOiAxIH07XG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sL3N5bnRheC5odG1sI2FkanVzdC1zdmctYXR0cmlidXRlc1xuLy8gVE9ETzogQWRqdXN0IFNWRyBhdHRyaWJ1dGVzXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmZvcmVpZ25cbi8vIFRPRE86IEFkanVzdCBTVkcgZWxlbWVudHNcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluZm9yZWlnblxuZXhwb3J0IGNvbnN0IEJMQUNLTElTVF9UQUJMRSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5bXCJiXCIsIFwiYmlnXCIsIFwiYmxvY2txdW90ZVwiLCBcImJvZHlcIiwgXCJiclwiLCBcImNlbnRlclwiLCBcImNvZGVcIiwgXCJkZFwiLCBcImRpdlwiLCBcImRsXCIsIFwiZHRcIiwgXCJlbVwiLCBcImVtYmVkXCIsIFwiaDFcIiwgXCJoMlwiLCBcImgzXCIsIFwiaDRcIiwgXCJoNVwiLCBcImg2XCIsIFwiaGVhZFwiLCBcImhyXCIsIFwiaVwiLCBcImltZ1wiLCBcImxpXCIsIFwibGlzdGluZ1wiLCBcIm1haW5cIiwgXCJtZXRhXCIsIFwibm9iclwiLCBcIm9sXCIsIFwicFwiLCBcInByZVwiLCBcInJ1YnlcIiwgXCJzXCIsIFwic21hbGxcIiwgXCJzcGFuXCIsIFwic3Ryb25nXCIsIFwic3RyaWtlXCIsIFwic3ViXCIsIFwic3VwXCIsIFwidGFibGVcIiwgXCJ0dFwiLCBcInVcIiwgXCJ1bFwiLCBcInZhclwiXS5mb3JFYWNoKHRhZyA9PiBCTEFDS0xJU1RfVEFCTEVbdGFnXSA9IDEpO1xuY29uc3QgV0hJVEVTUEFDRSA9IC9bXFx0LVxcciBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGXS87XG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBkb2N1bWVudDtcbmV4cG9ydCBmdW5jdGlvbiBpc1doaXRlc3BhY2Uoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFdISVRFU1BBQ0UudGVzdChzdHJpbmcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVOb2Rlc0JlZm9yZShzb3VyY2UsIHRhcmdldCwgbmV4dFNpYmxpbmcpIHtcbiAgICBsZXQgZmlyc3QgPSBzb3VyY2UuZmlyc3RDaGlsZDtcbiAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnQgPSBmaXJzdDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBsYXN0ID0gY3VycmVudDtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dFNpYmxpbmc7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobGFzdCwgbmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcbn1cbmV4cG9ydCBjbGFzcyBET01PcGVyYXRpb25zIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuc2V0dXBVc2VsZXNzRWxlbWVudCgpO1xuICAgIH1cbiAgICAvLyBzcGxpdCBpbnRvIHNlcGVyYXRlIG1ldGhvZCBzbyB0aGF0IE5vZGVET01UcmVlQ29uc3RydWN0aW9uXG4gICAgLy8gY2FuIG92ZXJyaWRlIGl0LlxuICAgIHNldHVwVXNlbGVzc0VsZW1lbnQoKSB7XG4gICAgICAgIHRoaXMudXNlbGVzc0VsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICBjcmVhdGVFbGVtZW50KHRhZywgY29udGV4dCkge1xuICAgICAgICBsZXQgaXNFbGVtZW50SW5TVkdOYW1lc3BhY2UsIGlzSFRNTEludGVncmF0aW9uUG9pbnQ7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBpc0VsZW1lbnRJblNWR05hbWVzcGFjZSA9IGNvbnRleHQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFIHx8IHRhZyA9PT0gJ3N2Zyc7XG4gICAgICAgICAgICBpc0hUTUxJbnRlZ3JhdGlvblBvaW50ID0gU1ZHX0lOVEVHUkFUSU9OX1BPSU5UU1tjb250ZXh0LnRhZ05hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNFbGVtZW50SW5TVkdOYW1lc3BhY2UgPSB0YWcgPT09ICdzdmcnO1xuICAgICAgICAgICAgaXNIVE1MSW50ZWdyYXRpb25Qb2ludCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnRJblNWR05hbWVzcGFjZSAmJiAhaXNIVE1MSW50ZWdyYXRpb25Qb2ludCkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRoaXMgZG9lcyBub3QgcHJvcGVybHkgaGFuZGxlIDxmb250PiB3aXRoIGNvbG9yLCBmYWNlLCBvclxuICAgICAgICAgICAgLy8gc2l6ZSBhdHRyaWJ1dGVzLCB3aGljaCBpcyBhbHNvIGRpc2FsbG93ZWQgYnkgdGhlIHNwZWMuIFdlIHNob3VsZCBmaXhcbiAgICAgICAgICAgIC8vIHRoaXMuXG4gICAgICAgICAgICBpZiAoQkxBQ0tMSVNUX1RBQkxFW3RhZ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgYSAke3RhZ30gaW5zaWRlIGFuIFNWRyBjb250ZXh0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgdGFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLCByZWZlcmVuY2UpIHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCByZWZlcmVuY2UpO1xuICAgIH1cbiAgICBpbnNlcnRIVE1MQmVmb3JlKF9wYXJlbnQsIG5leHRTaWJsaW5nLCBodG1sKSB7XG4gICAgICAgIHJldHVybiBpbnNlcnRIVE1MQmVmb3JlKHRoaXMudXNlbGVzc0VsZW1lbnQsIF9wYXJlbnQsIG5leHRTaWJsaW5nLCBodG1sKTtcbiAgICB9XG4gICAgY3JlYXRlVGV4dE5vZGUodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICB9XG4gICAgY3JlYXRlQ29tbWVudChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0IHZhciBET007XG4oZnVuY3Rpb24gKERPTSkge1xuICAgIGNsYXNzIFRyZWVDb25zdHJ1Y3Rpb24gZXh0ZW5kcyBET01PcGVyYXRpb25zIHtcbiAgICAgICAgY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCB0YWcpO1xuICAgICAgICB9XG4gICAgICAgIHNldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIERPTS5UcmVlQ29uc3RydWN0aW9uID0gVHJlZUNvbnN0cnVjdGlvbjtcbiAgICBsZXQgYXBwbGllZFRyZWVDb250cnVjdGlvbiA9IFRyZWVDb25zdHJ1Y3Rpb247XG4gICAgYXBwbGllZFRyZWVDb250cnVjdGlvbiA9IHRyZWVDb25zdHJ1Y3Rpb25Ob2RlTWVyZ2luZ0ZpeChkb2MsIGFwcGxpZWRUcmVlQ29udHJ1Y3Rpb24pO1xuICAgIGFwcGxpZWRUcmVlQ29udHJ1Y3Rpb24gPSB0cmVlQ29uc3RydWN0aW9uVGFibGVFbGVtZW50Rml4KGRvYywgYXBwbGllZFRyZWVDb250cnVjdGlvbik7XG4gICAgYXBwbGllZFRyZWVDb250cnVjdGlvbiA9IHRyZWVDb25zdHJ1Y3Rpb25TdmdFbGVtZW50Rml4KGRvYywgYXBwbGllZFRyZWVDb250cnVjdGlvbiwgU1ZHX05BTUVTUEFDRSk7XG4gICAgRE9NLkRPTVRyZWVDb25zdHJ1Y3Rpb24gPSBhcHBsaWVkVHJlZUNvbnRydWN0aW9uO1xufSkoRE9NIHx8IChET00gPSB7fSkpO1xuZXhwb3J0IGNsYXNzIERPTUNoYW5nZXMgZXh0ZW5kcyBET01PcGVyYXRpb25zIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCkge1xuICAgICAgICBzdXBlcihkb2N1bWVudCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBudWxsO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGVOUyhlbGVtZW50LCBuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICByZW1vdmVBdHRyaWJ1dGVOUyhlbGVtZW50LCBuYW1lc3BhY2UsIG5hbWUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpO1xuICAgIH1cbiAgICBpbnNlcnROb2RlQmVmb3JlKHBhcmVudCwgbm9kZSwgcmVmZXJlbmNlKSB7XG4gICAgICAgIGlmIChpc0RvY3VtZW50RnJhZ21lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIGxldCB7IGZpcnN0Q2hpbGQsIGxhc3RDaGlsZCB9ID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZSwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uY3JldGVCb3VuZHMocGFyZW50LCBmaXJzdENoaWxkLCBsYXN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVOb2RlQm91bmRzKHBhcmVudCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0VGV4dEJlZm9yZShwYXJlbnQsIG5leHRTaWJsaW5nLCB0ZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IHRoaXMuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgdGV4dE5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgIH1cbiAgICBpbnNlcnRCZWZvcmUoZWxlbWVudCwgbm9kZSwgcmVmZXJlbmNlKSB7XG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIGluc2VydEFmdGVyKGVsZW1lbnQsIG5vZGUsIHJlZmVyZW5jZSkge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtZW50LCBub2RlLCByZWZlcmVuY2UubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRIVE1MQmVmb3JlKF91c2VsZXNzLCBfcGFyZW50LCBfbmV4dFNpYmxpbmcsIGh0bWwpIHtcbiAgICAvLyBUeXBlU2NyaXB0IHZlbmRvcmVkIGFuIG9sZCB2ZXJzaW9uIG9mIHRoZSBET00gc3BlYyB3aGVyZSBgaW5zZXJ0QWRqYWNlbnRIVE1MYFxuICAgIC8vIG9ubHkgZXhpc3RzIG9uIGBIVE1MRWxlbWVudGAgYnV0IG5vdCBvbiBgRWxlbWVudGAuIFdlIGFjdHVhbGx5IHdvcmsgd2l0aCB0aGVcbiAgICAvLyBuZXdlciB2ZXJzaW9uIG9mIHRoZSBET00gQVBJIGhlcmUgKGFuZCBtb25rZXktcGF0Y2ggdGhpcyBtZXRob2QgaW4gYC4vY29tcGF0YFxuICAgIC8vIHdoZW4gd2UgZGV0ZWN0IG9sZGVyIGJyb3dzZXJzKS4gVGhpcyBpcyBhIGhhY2sgdG8gd29yayBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLlxuICAgIGxldCBwYXJlbnQgPSBfcGFyZW50O1xuICAgIGxldCB1c2VsZXNzID0gX3VzZWxlc3M7XG4gICAgbGV0IG5leHRTaWJsaW5nID0gX25leHRTaWJsaW5nO1xuICAgIGxldCBwcmV2ID0gbmV4dFNpYmxpbmcgPyBuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGxldCBsYXN0O1xuICAgIGlmIChodG1sID09PSBudWxsIHx8IGh0bWwgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uY3JldGVCb3VuZHMocGFyZW50LCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGh0bWwpO1xuICAgICAgICBsYXN0ID0gcGFyZW50Lmxhc3RDaGlsZDtcbiAgICB9IGVsc2UgaWYgKG5leHRTaWJsaW5nIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIGh0bWwpO1xuICAgICAgICBsYXN0ID0gbmV4dFNpYmxpbmcucHJldmlvdXNTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vbi1lbGVtZW50IG5vZGVzIGRvIG5vdCBzdXBwb3J0IGluc2VydEFkamFjZW50SFRNTCwgc28gYWRkIGFuXG4gICAgICAgIC8vIGVsZW1lbnQgYW5kIGNhbGwgaXQgb24gdGhhdCBlbGVtZW50LiBUaGVuIHJlbW92ZSB0aGUgZWxlbWVudC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBhbHNvIHByb3RlY3RzIEVkZ2UsIElFIGFuZCBGaXJlZm94IHcvbyB0aGUgaW5zcGVjdG9yIG9wZW5cbiAgICAgICAgLy8gZnJvbSBtZXJnaW5nIGFkamFjZW50IHRleHQgbm9kZXMuIFNlZSAuL2NvbXBhdC90ZXh0LW5vZGUtbWVyZ2luZy1maXgudHNcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh1c2VsZXNzLCBuZXh0U2libGluZyk7XG4gICAgICAgIHVzZWxlc3MuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIGh0bWwpO1xuICAgICAgICBsYXN0ID0gdXNlbGVzcy5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh1c2VsZXNzKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICByZXR1cm4gbmV3IENvbmNyZXRlQm91bmRzKHBhcmVudCwgZmlyc3QsIGxhc3QpO1xufVxuZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xufVxubGV0IGhlbHBlciA9IERPTUNoYW5nZXM7XG5oZWxwZXIgPSBkb21DaGFuZ2VzTm9kZU1lcmdpbmdGaXgoZG9jLCBoZWxwZXIpO1xuaGVscGVyID0gZG9tQ2hhbmdlc1RhYmxlRWxlbWVudEZpeChkb2MsIGhlbHBlcik7XG5oZWxwZXIgPSBkb21DaGFuZ2VzU3ZnRWxlbWVudEZpeChkb2MsIGhlbHBlciwgU1ZHX05BTUVTUEFDRSk7XG5leHBvcnQgZGVmYXVsdCBoZWxwZXI7XG5leHBvcnQgY29uc3QgRE9NVHJlZUNvbnN0cnVjdGlvbiA9IERPTS5ET01UcmVlQ29uc3RydWN0aW9uOyJdfQ==