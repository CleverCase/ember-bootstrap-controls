'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.INLINES = exports.Inlines = exports.BLOCKS = exports.Blocks = exports.PartialInvoker = exports.InvokeDynamicLayout = exports.ATTRS_BLOCK = undefined;
exports.expr = expr;
exports.compileList = compileList;
exports.populateBuiltins = populateBuiltins;
exports.compileStatement = compileStatement;
exports.compileStatements = compileStatements;

var _reference = require('@glimmer/reference');

var _util = require('@glimmer/util');

var _wireFormat = require('@glimmer/wire-format');

var WireFormat = _interopRequireWildcard(_wireFormat);

var _builder = require('../compiled/opcodes/builder');

var _builder2 = _interopRequireDefault(_builder);

var _opcodes = require('../opcodes');

var _clientSide = require('../syntax/client-side');

var ClientSide = _interopRequireWildcard(_clientSide);

var _rawBlock = require('./raw-block');

var _rawBlock2 = _interopRequireDefault(_rawBlock);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var Ops = WireFormat.Ops;
const ATTRS_BLOCK = exports.ATTRS_BLOCK = '&attrs';
class Compilers {
    constructor(offset = 0) {
        this.offset = offset;
        this.names = (0, _util.dict)();
        this.funcs = [];
    }
    add(name, func) {
        this.funcs.push(func);
        this.names[name] = this.funcs.length - 1;
    }
    compile(sexp, builder) {
        let name = sexp[this.offset];
        let index = this.names[name];
        let func = this.funcs[index];
        (0, _util.assert)(!!func, `expected an implementation for ${this.offset === 0 ? Ops[sexp[0]] : ClientSide.Ops[sexp[1]]}`);
        func(sexp, builder);
    }
}
const STATEMENTS = new Compilers();
const CLIENT_SIDE = new Compilers(1);
STATEMENTS.add(Ops.Text, (sexp, builder) => {
    builder.text(sexp[1]);
});
STATEMENTS.add(Ops.Comment, (sexp, builder) => {
    builder.comment(sexp[1]);
});
STATEMENTS.add(Ops.CloseElement, (_sexp, builder) => {
    builder.closeElement();
});
STATEMENTS.add(Ops.FlushElement, (_sexp, builder) => {
    builder.flushElement();
});
STATEMENTS.add(Ops.Modifier, (sexp, builder) => {
    let { env, meta } = builder;
    let [, name, params, hash] = sexp;
    if (env.hasModifier(name, meta.templateMeta)) {
        builder.compileArgs(params, hash, true);
        builder.modifier(env.lookupModifier(name, meta.templateMeta));
    } else {
        throw new Error(`Compile Error ${name} is not a modifier: Helpers may not be used in the element form.`);
    }
});
STATEMENTS.add(Ops.StaticAttr, (sexp, builder) => {
    let [, name, value, namespace] = sexp;
    builder.staticAttr(name, namespace, value);
});
STATEMENTS.add(Ops.DynamicAttr, (sexp, builder) => {
    dynamicAttr(sexp, false, builder);
});
STATEMENTS.add(Ops.TrustingAttr, (sexp, builder) => {
    dynamicAttr(sexp, true, builder);
});
function dynamicAttr(sexp, trusting, builder) {
    let [, name, value, namespace] = sexp;
    expr(value, builder);
    if (namespace) {
        builder.dynamicAttrNS(name, namespace, trusting);
    } else {
        builder.dynamicAttr(name, trusting);
    }
}
STATEMENTS.add(Ops.OpenElement, (sexp, builder) => {
    builder.openPrimitiveElement(sexp[1]);
});
CLIENT_SIDE.add(ClientSide.Ops.OpenComponentElement, (sexp, builder) => {
    builder.pushComponentOperations();
    builder.openElementWithOperations(sexp[2]);
});
CLIENT_SIDE.add(ClientSide.Ops.DidCreateElement, (_sexp, builder) => {
    builder.didCreateElement(_opcodes.Register.s0);
});
CLIENT_SIDE.add(ClientSide.Ops.DidRenderLayout, (_sexp, builder) => {
    builder.didRenderLayout(_opcodes.Register.s0);
});
STATEMENTS.add(Ops.Append, (sexp, builder) => {
    let [, value, trusting] = sexp;
    let { inlines } = builder.env.macros();
    let returned = inlines.compile(sexp, builder) || value;
    if (returned === true) return;
    let isGet = E.isGet(value);
    let isMaybeLocal = E.isMaybeLocal(value);
    if (trusting) {
        builder.guardedAppend(value, true);
    } else {
        if (isGet || isMaybeLocal) {
            builder.guardedAppend(value, false);
        } else {
            expr(value, builder);
            builder.cautiousAppend();
        }
    }
});
STATEMENTS.add(Ops.Block, (sexp, builder) => {
    let [, name, params, hash, _template, _inverse] = sexp;
    let template = builder.template(_template);
    let inverse = builder.template(_inverse);
    let templateBlock = template && template.scan();
    let inverseBlock = inverse && inverse.scan();
    let { blocks } = builder.env.macros();
    blocks.compile(name, params, hash, templateBlock, inverseBlock, builder);
});
class InvokeDynamicLayout {
    constructor(attrs) {
        this.attrs = attrs;
    }
    invoke(vm, layout) {
        let { symbols, hasEval } = layout.symbolTable;
        let stack = vm.stack;
        let scope = vm.pushRootScope(symbols.length + 1, true);
        scope.bindSelf(stack.pop());
        scope.bindBlock(symbols.indexOf(ATTRS_BLOCK) + 1, this.attrs);
        let lookup = null;
        let $eval = -1;
        if (hasEval) {
            $eval = symbols.indexOf('$eval') + 1;
            lookup = (0, _util.dict)();
        }
        let callerNames = stack.pop();
        for (let i = callerNames.length - 1; i >= 0; i--) {
            let symbol = symbols.indexOf(callerNames[i]);
            let value = stack.pop();
            if (symbol !== -1) scope.bindSymbol(symbol + 1, value);
            if (hasEval) lookup[callerNames[i]] = value;
        }
        let numPositionalArgs = stack.pop();
        (0, _util.assert)(typeof numPositionalArgs === 'number', '[BUG] Incorrect value of positional argument count found during invoke-dynamic-layout.');
        // Currently we don't support accessing positional args in templates, so just throw them away
        stack.pop(numPositionalArgs);
        let inverseSymbol = symbols.indexOf('&inverse');
        let inverse = stack.pop();
        if (inverseSymbol !== -1) {
            scope.bindBlock(inverseSymbol + 1, inverse);
        }
        if (lookup) lookup['&inverse'] = inverse;
        let defaultSymbol = symbols.indexOf('&default');
        let defaultBlock = stack.pop();
        if (defaultSymbol !== -1) {
            scope.bindBlock(defaultSymbol + 1, defaultBlock);
        }
        if (lookup) lookup['&default'] = defaultBlock;
        if (lookup) scope.bindEvalScope(lookup);
        vm.pushFrame();
        vm.call(layout.handle);
    }
    toJSON() {
        return { GlimmerDebug: '<invoke-dynamic-layout>' };
    }
}
exports.InvokeDynamicLayout = InvokeDynamicLayout;
STATEMENTS.add(Ops.Component, (sexp, builder) => {
    let [, tag, attrs, args, block] = sexp;
    if (builder.env.hasComponentDefinition(tag, builder.meta.templateMeta)) {
        let child = builder.template(block);
        let attrsBlock = new _rawBlock2.default(builder.meta, attrs, _util.EMPTY_ARRAY);
        let definition = builder.env.getComponentDefinition(tag, builder.meta.templateMeta);
        builder.pushComponentManager(definition);
        builder.invokeComponent(attrsBlock, null, args, child && child.scan());
    } else if (block && block.parameters.length) {
        throw new Error(`Compile Error: Cannot find component ${tag}`);
    } else {
        builder.openPrimitiveElement(tag);
        for (let i = 0; i < attrs.length; i++) {
            STATEMENTS.compile(attrs[i], builder);
        }
        builder.flushElement();
        if (block) {
            let stmts = block.statements;
            for (let i = 0; i < stmts.length; i++) {
                STATEMENTS.compile(stmts[i], builder);
            }
        }
        builder.closeElement();
    }
});
class PartialInvoker {
    constructor(outerSymbols, evalInfo) {
        this.outerSymbols = outerSymbols;
        this.evalInfo = evalInfo;
    }
    invoke(vm, _partial) {
        let partial = (0, _util.unwrap)(_partial);
        let partialSymbols = partial.symbolTable.symbols;
        let outerScope = vm.scope();
        let partialScope = vm.pushRootScope(partialSymbols.length, false);
        partialScope.bindCallerScope(outerScope.getCallerScope());
        partialScope.bindEvalScope(outerScope.getEvalScope());
        partialScope.bindSelf(outerScope.getSelf());
        let { evalInfo, outerSymbols } = this;
        let locals = (0, _util.dict)();
        for (let i = 0; i < evalInfo.length; i++) {
            let slot = evalInfo[i];
            let name = outerSymbols[slot - 1];
            let ref = outerScope.getSymbol(slot);
            locals[name] = ref;
        }
        let evalScope = outerScope.getEvalScope();
        for (let i = 0; i < partialSymbols.length; i++) {
            let name = partialSymbols[i];
            let symbol = i + 1;
            let value = evalScope[name];
            if (value !== undefined) partialScope.bind(symbol, value);
        }
        partialScope.bindPartialMap(locals);
        vm.pushFrame();
        vm.call(partial.handle);
    }
}
exports.PartialInvoker = PartialInvoker;
STATEMENTS.add(Ops.Partial, (sexp, builder) => {
    let [, name, evalInfo] = sexp;
    let { templateMeta, symbols } = builder.meta;
    function helper(vm, args) {
        let { env } = vm;
        let nameRef = args.positional.at(0);
        return (0, _reference.map)(nameRef, n => {
            if (typeof n === 'string' && n) {
                if (!env.hasPartial(n, templateMeta)) {
                    throw new Error(`Could not find a partial named "${n}"`);
                }
                return env.lookupPartial(n, templateMeta);
            } else if (n) {
                throw new Error(`Could not find a partial named "${String(n)}"`);
            } else {
                return null;
            }
        });
    }
    builder.startLabels();
    builder.pushFrame();
    builder.returnTo('END');
    expr(name, builder);
    builder.pushImmediate(1);
    builder.pushImmediate(_util.EMPTY_ARRAY);
    builder.pushArgs(true);
    builder.helper(helper);
    builder.dup();
    builder.test('simple');
    builder.enter(2);
    builder.jumpUnless('ELSE');
    builder.getPartialTemplate();
    builder.compileDynamicBlock();
    builder.invokeDynamic(new PartialInvoker(symbols, evalInfo));
    builder.popScope();
    builder.popFrame();
    builder.label('ELSE');
    builder.exit();
    builder.return();
    builder.label('END');
    builder.popFrame();
    builder.stopLabels();
});
class InvokeDynamicYield {
    constructor(callerCount) {
        this.callerCount = callerCount;
    }
    invoke(vm, block) {
        let { callerCount } = this;
        let stack = vm.stack;
        if (!block) {
            // To balance the pop{Frame,Scope}
            vm.pushFrame();
            vm.pushCallerScope();
            return;
        }
        let table = block.symbolTable;
        let locals = table.parameters; // always present in inline blocks
        let calleeCount = locals ? locals.length : 0;
        let count = Math.min(callerCount, calleeCount);
        vm.pushFrame();
        vm.pushCallerScope(calleeCount > 0);
        let scope = vm.scope();
        for (let i = 0; i < count; i++) {
            scope.bindSymbol(locals[i], stack.fromBase(callerCount - i));
        }
        vm.call(block.handle);
    }
    toJSON() {
        return { GlimmerDebug: `<invoke-dynamic-yield caller-count=${this.callerCount}>` };
    }
}
STATEMENTS.add(Ops.Yield, (sexp, builder) => {
    let [, to, params] = sexp;
    let count = compileList(params, builder);
    builder.getBlock(to);
    builder.compileDynamicBlock();
    builder.invokeDynamic(new InvokeDynamicYield(count));
    builder.popScope();
    builder.popFrame();
    if (count) {
        builder.pop(count);
    }
});
STATEMENTS.add(Ops.Debugger, (sexp, builder) => {
    let [, evalInfo] = sexp;
    builder.debugger(builder.meta.symbols, evalInfo);
});
STATEMENTS.add(Ops.ClientSideStatement, (sexp, builder) => {
    CLIENT_SIDE.compile(sexp, builder);
});
const EXPRESSIONS = new Compilers();
const CLIENT_SIDE_EXPRS = new Compilers(1);
var E = WireFormat.Expressions;
function expr(expression, builder) {
    if (Array.isArray(expression)) {
        EXPRESSIONS.compile(expression, builder);
    } else {
        builder.primitive(expression);
    }
}
EXPRESSIONS.add(Ops.Unknown, (sexp, builder) => {
    let name = sexp[1];
    if (builder.env.hasHelper(name, builder.meta.templateMeta)) {
        EXPRESSIONS.compile([Ops.Helper, name, _util.EMPTY_ARRAY, null], builder);
    } else if (builder.meta.asPartial) {
        builder.resolveMaybeLocal(name);
    } else {
        builder.getVariable(0);
        builder.getProperty(name);
    }
});
EXPRESSIONS.add(Ops.Concat, (sexp, builder) => {
    let parts = sexp[1];
    for (let i = 0; i < parts.length; i++) {
        expr(parts[i], builder);
    }
    builder.concat(parts.length);
});
CLIENT_SIDE_EXPRS.add(ClientSide.Ops.FunctionExpression, (sexp, builder) => {
    builder.function(sexp[2]);
});
EXPRESSIONS.add(Ops.Helper, (sexp, builder) => {
    let { env, meta } = builder;
    let [, name, params, hash] = sexp;
    if (env.hasHelper(name, meta.templateMeta)) {
        builder.compileArgs(params, hash, true);
        builder.helper(env.lookupHelper(name, meta.templateMeta));
    } else {
        throw new Error(`Compile Error: ${name} is not a helper`);
    }
});
EXPRESSIONS.add(Ops.Get, (sexp, builder) => {
    let [, head, path] = sexp;
    builder.getVariable(head);
    for (let i = 0; i < path.length; i++) {
        builder.getProperty(path[i]);
    }
});
EXPRESSIONS.add(Ops.MaybeLocal, (sexp, builder) => {
    let [, path] = sexp;
    if (builder.meta.asPartial) {
        let head = path[0];
        path = path.slice(1);
        builder.resolveMaybeLocal(head);
    } else {
        builder.getVariable(0);
    }
    for (let i = 0; i < path.length; i++) {
        builder.getProperty(path[i]);
    }
});
EXPRESSIONS.add(Ops.Undefined, (_sexp, builder) => {
    return builder.primitive(undefined);
});
EXPRESSIONS.add(Ops.HasBlock, (sexp, builder) => {
    builder.hasBlock(sexp[1]);
});
EXPRESSIONS.add(Ops.HasBlockParams, (sexp, builder) => {
    builder.hasBlockParams(sexp[1]);
});
EXPRESSIONS.add(Ops.ClientSideExpression, (sexp, builder) => {
    CLIENT_SIDE_EXPRS.compile(sexp, builder);
});
function compileList(params, builder) {
    if (!params) return 0;
    for (let i = 0; i < params.length; i++) {
        expr(params[i], builder);
    }
    return params.length;
}
class Blocks {
    constructor() {
        this.names = (0, _util.dict)();
        this.funcs = [];
    }
    add(name, func) {
        this.funcs.push(func);
        this.names[name] = this.funcs.length - 1;
    }
    addMissing(func) {
        this.missing = func;
    }
    compile(name, params, hash, template, inverse, builder) {
        let index = this.names[name];
        if (index === undefined) {
            (0, _util.assert)(!!this.missing, `${name} not found, and no catch-all block handler was registered`);
            let func = this.missing;
            let handled = func(name, params, hash, template, inverse, builder);
            (0, _util.assert)(!!handled, `${name} not found, and the catch-all block handler didn't handle it`);
        } else {
            let func = this.funcs[index];
            func(params, hash, template, inverse, builder);
        }
    }
}
exports.Blocks = Blocks;
const BLOCKS = exports.BLOCKS = new Blocks();
class Inlines {
    constructor() {
        this.names = (0, _util.dict)();
        this.funcs = [];
    }
    add(name, func) {
        this.funcs.push(func);
        this.names[name] = this.funcs.length - 1;
    }
    addMissing(func) {
        this.missing = func;
    }
    compile(sexp, builder) {
        let value = sexp[1];
        // TODO: Fix this so that expression macros can return
        // things like components, so that {{component foo}}
        // is the same as {{(component foo)}}
        if (!Array.isArray(value)) return ['expr', value];
        let name;
        let params;
        let hash;
        if (value[0] === Ops.Helper) {
            name = value[1];
            params = value[2];
            hash = value[3];
        } else if (value[0] === Ops.Unknown) {
            name = value[1];
            params = hash = null;
        } else {
            return ['expr', value];
        }
        let index = this.names[name];
        if (index === undefined && this.missing) {
            let func = this.missing;
            let returned = func(name, params, hash, builder);
            return returned === false ? ['expr', value] : returned;
        } else if (index !== undefined) {
            let func = this.funcs[index];
            let returned = func(name, params, hash, builder);
            return returned === false ? ['expr', value] : returned;
        } else {
            return ['expr', value];
        }
    }
}
exports.Inlines = Inlines;
const INLINES = exports.INLINES = new Inlines();
populateBuiltins(BLOCKS, INLINES);
function populateBuiltins(blocks = new Blocks(), inlines = new Inlines()) {
    blocks.add('if', (params, _hash, template, inverse, builder) => {
        //        PutArgs
        //        Test(Environment)
        //        Enter(BEGIN, END)
        // BEGIN: Noop
        //        JumpUnless(ELSE)
        //        Evaluate(default)
        //        Jump(END)
        // ELSE:  Noop
        //        Evalulate(inverse)
        // END:   Noop
        //        Exit
        if (!params || params.length !== 1) {
            throw new Error(`SYNTAX ERROR: #if requires a single argument`);
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        expr(params[0], builder);
        builder.test('environment');
        builder.enter(1);
        builder.jumpUnless('ELSE');
        builder.invokeStatic((0, _util.unwrap)(template));
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStatic(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('unless', (params, _hash, template, inverse, builder) => {
        //        PutArgs
        //        Test(Environment)
        //        Enter(BEGIN, END)
        // BEGIN: Noop
        //        JumpUnless(ELSE)
        //        Evaluate(default)
        //        Jump(END)
        // ELSE:  Noop
        //        Evalulate(inverse)
        // END:   Noop
        //        Exit
        if (!params || params.length !== 1) {
            throw new Error(`SYNTAX ERROR: #unless requires a single argument`);
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        expr(params[0], builder);
        builder.test('environment');
        builder.enter(1);
        builder.jumpIf('ELSE');
        builder.invokeStatic((0, _util.unwrap)(template));
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStatic(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('with', (params, _hash, template, inverse, builder) => {
        //        PutArgs
        //        Test(Environment)
        //        Enter(BEGIN, END)
        // BEGIN: Noop
        //        JumpUnless(ELSE)
        //        Evaluate(default)
        //        Jump(END)
        // ELSE:  Noop
        //        Evalulate(inverse)
        // END:   Noop
        //        Exit
        if (!params || params.length !== 1) {
            throw new Error(`SYNTAX ERROR: #with requires a single argument`);
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        expr(params[0], builder);
        builder.dup();
        builder.test('environment');
        builder.enter(2);
        builder.jumpUnless('ELSE');
        builder.invokeStatic((0, _util.unwrap)(template), 1);
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStatic(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('each', (params, hash, template, inverse, builder) => {
        //         Enter(BEGIN, END)
        // BEGIN:  Noop
        //         PutArgs
        //         PutIterable
        //         JumpUnless(ELSE)
        //         EnterList(BEGIN2, END2)
        // ITER:   Noop
        //         NextIter(BREAK)
        // BEGIN2: Noop
        //         PushChildScope
        //         Evaluate(default)
        //         PopScope
        // END2:   Noop
        //         Exit
        //         Jump(ITER)
        // BREAK:  Noop
        //         ExitList
        //         Jump(END)
        // ELSE:   Noop
        //         Evalulate(inverse)
        // END:    Noop
        //         Exit
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        if (hash && hash[0][0] === 'key') {
            expr(hash[1][0], builder);
        } else {
            builder.primitive(null);
        }
        expr(params[0], builder);
        builder.enter(2);
        builder.putIterator();
        builder.jumpUnless('ELSE');
        builder.pushFrame();
        builder.returnTo('ITER');
        builder.dup(_opcodes.Register.fp, 1);
        builder.enterList('BODY');
        builder.label('ITER');
        builder.iterate('BREAK');
        builder.label('BODY');
        builder.invokeStatic((0, _util.unwrap)(template), 2);
        builder.pop(2);
        builder.exit();
        builder.return();
        builder.label('BREAK');
        builder.exitList();
        builder.popFrame();
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStatic(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('-in-element', (params, hash, template, _inverse, builder) => {
        if (!params || params.length !== 1) {
            throw new Error(`SYNTAX ERROR: #-in-element requires a single argument`);
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        if (hash && hash[0].length) {
            let [keys, values] = hash;
            if (keys.length === 1 && keys[0] === 'nextSibling') {
                expr(values[0], builder);
            } else {
                throw new Error(`SYNTAX ERROR: #-in-element does not take a \`${keys[0]}\` option`);
            }
        } else {
            expr(null, builder);
        }
        expr(params[0], builder);
        builder.dup();
        builder.test('simple');
        builder.enter(3);
        builder.jumpUnless('ELSE');
        builder.pushRemoteElement();
        builder.invokeStatic((0, _util.unwrap)(template));
        builder.popRemoteElement();
        builder.label('ELSE');
        builder.exit();
        builder.return();
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('-with-dynamic-vars', (_params, hash, template, _inverse, builder) => {
        if (hash) {
            let [names, expressions] = hash;
            compileList(expressions, builder);
            builder.pushDynamicScope();
            builder.bindDynamicScope(names);
            builder.invokeStatic((0, _util.unwrap)(template));
            builder.popDynamicScope();
        } else {
            builder.invokeStatic((0, _util.unwrap)(template));
        }
    });
    return { blocks, inlines };
}
function compileStatement(statement, builder) {
    STATEMENTS.compile(statement, builder);
}
function compileStatements(statements, meta, env) {
    let b = new _builder2.default(env, meta);
    for (let i = 0; i < statements.length; i++) {
        compileStatement(statements[i], b);
    }
    return b;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9zeW50YXgvZnVuY3Rpb25zLmpzIl0sIm5hbWVzIjpbImV4cHIiLCJjb21waWxlTGlzdCIsInBvcHVsYXRlQnVpbHRpbnMiLCJjb21waWxlU3RhdGVtZW50IiwiY29tcGlsZVN0YXRlbWVudHMiLCJXaXJlRm9ybWF0IiwiQ2xpZW50U2lkZSIsIk9wcyIsIkFUVFJTX0JMT0NLIiwiQ29tcGlsZXJzIiwiY29uc3RydWN0b3IiLCJvZmZzZXQiLCJuYW1lcyIsImZ1bmNzIiwiYWRkIiwibmFtZSIsImZ1bmMiLCJwdXNoIiwibGVuZ3RoIiwiY29tcGlsZSIsInNleHAiLCJidWlsZGVyIiwiaW5kZXgiLCJTVEFURU1FTlRTIiwiQ0xJRU5UX1NJREUiLCJUZXh0IiwidGV4dCIsIkNvbW1lbnQiLCJjb21tZW50IiwiQ2xvc2VFbGVtZW50IiwiX3NleHAiLCJjbG9zZUVsZW1lbnQiLCJGbHVzaEVsZW1lbnQiLCJmbHVzaEVsZW1lbnQiLCJNb2RpZmllciIsImVudiIsIm1ldGEiLCJwYXJhbXMiLCJoYXNoIiwiaGFzTW9kaWZpZXIiLCJ0ZW1wbGF0ZU1ldGEiLCJjb21waWxlQXJncyIsIm1vZGlmaWVyIiwibG9va3VwTW9kaWZpZXIiLCJFcnJvciIsIlN0YXRpY0F0dHIiLCJ2YWx1ZSIsIm5hbWVzcGFjZSIsInN0YXRpY0F0dHIiLCJEeW5hbWljQXR0ciIsImR5bmFtaWNBdHRyIiwiVHJ1c3RpbmdBdHRyIiwidHJ1c3RpbmciLCJkeW5hbWljQXR0ck5TIiwiT3BlbkVsZW1lbnQiLCJvcGVuUHJpbWl0aXZlRWxlbWVudCIsIk9wZW5Db21wb25lbnRFbGVtZW50IiwicHVzaENvbXBvbmVudE9wZXJhdGlvbnMiLCJvcGVuRWxlbWVudFdpdGhPcGVyYXRpb25zIiwiRGlkQ3JlYXRlRWxlbWVudCIsImRpZENyZWF0ZUVsZW1lbnQiLCJzMCIsIkRpZFJlbmRlckxheW91dCIsImRpZFJlbmRlckxheW91dCIsIkFwcGVuZCIsImlubGluZXMiLCJtYWNyb3MiLCJyZXR1cm5lZCIsImlzR2V0IiwiRSIsImlzTWF5YmVMb2NhbCIsImd1YXJkZWRBcHBlbmQiLCJjYXV0aW91c0FwcGVuZCIsIkJsb2NrIiwiX3RlbXBsYXRlIiwiX2ludmVyc2UiLCJ0ZW1wbGF0ZSIsImludmVyc2UiLCJ0ZW1wbGF0ZUJsb2NrIiwic2NhbiIsImludmVyc2VCbG9jayIsImJsb2NrcyIsIkludm9rZUR5bmFtaWNMYXlvdXQiLCJhdHRycyIsImludm9rZSIsInZtIiwibGF5b3V0Iiwic3ltYm9scyIsImhhc0V2YWwiLCJzeW1ib2xUYWJsZSIsInN0YWNrIiwic2NvcGUiLCJwdXNoUm9vdFNjb3BlIiwiYmluZFNlbGYiLCJwb3AiLCJiaW5kQmxvY2siLCJpbmRleE9mIiwibG9va3VwIiwiJGV2YWwiLCJjYWxsZXJOYW1lcyIsImkiLCJzeW1ib2wiLCJiaW5kU3ltYm9sIiwibnVtUG9zaXRpb25hbEFyZ3MiLCJpbnZlcnNlU3ltYm9sIiwiZGVmYXVsdFN5bWJvbCIsImRlZmF1bHRCbG9jayIsImJpbmRFdmFsU2NvcGUiLCJwdXNoRnJhbWUiLCJjYWxsIiwiaGFuZGxlIiwidG9KU09OIiwiR2xpbW1lckRlYnVnIiwiQ29tcG9uZW50IiwidGFnIiwiYXJncyIsImJsb2NrIiwiaGFzQ29tcG9uZW50RGVmaW5pdGlvbiIsImNoaWxkIiwiYXR0cnNCbG9jayIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnREZWZpbml0aW9uIiwicHVzaENvbXBvbmVudE1hbmFnZXIiLCJpbnZva2VDb21wb25lbnQiLCJwYXJhbWV0ZXJzIiwic3RtdHMiLCJzdGF0ZW1lbnRzIiwiUGFydGlhbEludm9rZXIiLCJvdXRlclN5bWJvbHMiLCJldmFsSW5mbyIsIl9wYXJ0aWFsIiwicGFydGlhbCIsInBhcnRpYWxTeW1ib2xzIiwib3V0ZXJTY29wZSIsInBhcnRpYWxTY29wZSIsImJpbmRDYWxsZXJTY29wZSIsImdldENhbGxlclNjb3BlIiwiZ2V0RXZhbFNjb3BlIiwiZ2V0U2VsZiIsImxvY2FscyIsInNsb3QiLCJyZWYiLCJnZXRTeW1ib2wiLCJldmFsU2NvcGUiLCJ1bmRlZmluZWQiLCJiaW5kIiwiYmluZFBhcnRpYWxNYXAiLCJQYXJ0aWFsIiwiaGVscGVyIiwibmFtZVJlZiIsInBvc2l0aW9uYWwiLCJhdCIsIm4iLCJoYXNQYXJ0aWFsIiwibG9va3VwUGFydGlhbCIsIlN0cmluZyIsInN0YXJ0TGFiZWxzIiwicmV0dXJuVG8iLCJwdXNoSW1tZWRpYXRlIiwicHVzaEFyZ3MiLCJkdXAiLCJ0ZXN0IiwiZW50ZXIiLCJqdW1wVW5sZXNzIiwiZ2V0UGFydGlhbFRlbXBsYXRlIiwiY29tcGlsZUR5bmFtaWNCbG9jayIsImludm9rZUR5bmFtaWMiLCJwb3BTY29wZSIsInBvcEZyYW1lIiwibGFiZWwiLCJleGl0IiwicmV0dXJuIiwic3RvcExhYmVscyIsIkludm9rZUR5bmFtaWNZaWVsZCIsImNhbGxlckNvdW50IiwicHVzaENhbGxlclNjb3BlIiwidGFibGUiLCJjYWxsZWVDb3VudCIsImNvdW50IiwiTWF0aCIsIm1pbiIsImZyb21CYXNlIiwiWWllbGQiLCJ0byIsImdldEJsb2NrIiwiRGVidWdnZXIiLCJkZWJ1Z2dlciIsIkNsaWVudFNpZGVTdGF0ZW1lbnQiLCJFWFBSRVNTSU9OUyIsIkNMSUVOVF9TSURFX0VYUFJTIiwiRXhwcmVzc2lvbnMiLCJleHByZXNzaW9uIiwiQXJyYXkiLCJpc0FycmF5IiwicHJpbWl0aXZlIiwiVW5rbm93biIsImhhc0hlbHBlciIsIkhlbHBlciIsImFzUGFydGlhbCIsInJlc29sdmVNYXliZUxvY2FsIiwiZ2V0VmFyaWFibGUiLCJnZXRQcm9wZXJ0eSIsIkNvbmNhdCIsInBhcnRzIiwiY29uY2F0IiwiRnVuY3Rpb25FeHByZXNzaW9uIiwiZnVuY3Rpb24iLCJsb29rdXBIZWxwZXIiLCJHZXQiLCJoZWFkIiwicGF0aCIsIk1heWJlTG9jYWwiLCJzbGljZSIsIlVuZGVmaW5lZCIsIkhhc0Jsb2NrIiwiaGFzQmxvY2siLCJIYXNCbG9ja1BhcmFtcyIsImhhc0Jsb2NrUGFyYW1zIiwiQ2xpZW50U2lkZUV4cHJlc3Npb24iLCJCbG9ja3MiLCJhZGRNaXNzaW5nIiwibWlzc2luZyIsImhhbmRsZWQiLCJCTE9DS1MiLCJJbmxpbmVzIiwiSU5MSU5FUyIsIl9oYXNoIiwiaW52b2tlU3RhdGljIiwianVtcCIsImp1bXBJZiIsInB1dEl0ZXJhdG9yIiwiZnAiLCJlbnRlckxpc3QiLCJpdGVyYXRlIiwiZXhpdExpc3QiLCJrZXlzIiwidmFsdWVzIiwicHVzaFJlbW90ZUVsZW1lbnQiLCJwb3BSZW1vdGVFbGVtZW50IiwiX3BhcmFtcyIsImV4cHJlc3Npb25zIiwicHVzaER5bmFtaWNTY29wZSIsImJpbmREeW5hbWljU2NvcGUiLCJwb3BEeW5hbWljU2NvcGUiLCJzdGF0ZW1lbnQiLCJiIl0sIm1hcHBpbmdzIjoiOzs7Ozs7UUFxVGdCQSxJLEdBQUFBLEk7UUFzRUFDLFcsR0FBQUEsVztRQWdGQUMsZ0IsR0FBQUEsZ0I7UUFzT0FDLGdCLEdBQUFBLGdCO1FBR0FDLGlCLEdBQUFBLGlCOztBQXByQmhCOztBQUNBOztBQUNBOztJQUFZQyxVOztBQUNaOzs7O0FBQ0E7O0FBQ0E7O0lBQVlDLFU7O0FBQ1o7Ozs7Ozs7O0FBQ0EsSUFBSUMsTUFBTUYsV0FBV0UsR0FBckI7QUFDTyxNQUFNQyxvQ0FBYyxRQUFwQjtBQUNQLE1BQU1DLFNBQU4sQ0FBZ0I7QUFDWkMsZ0JBQVlDLFNBQVMsQ0FBckIsRUFBd0I7QUFDcEIsYUFBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsYUFBS0MsS0FBTCxHQUFhLGlCQUFiO0FBQ0EsYUFBS0MsS0FBTCxHQUFhLEVBQWI7QUFDSDtBQUNEQyxRQUFJQyxJQUFKLEVBQVVDLElBQVYsRUFBZ0I7QUFDWixhQUFLSCxLQUFMLENBQVdJLElBQVgsQ0FBZ0JELElBQWhCO0FBQ0EsYUFBS0osS0FBTCxDQUFXRyxJQUFYLElBQW1CLEtBQUtGLEtBQUwsQ0FBV0ssTUFBWCxHQUFvQixDQUF2QztBQUNIO0FBQ0RDLFlBQVFDLElBQVIsRUFBY0MsT0FBZCxFQUF1QjtBQUNuQixZQUFJTixPQUFPSyxLQUFLLEtB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VCxDQUEwQmlQLFNBQTFCLEVBQXFDL04sT0FBckMsRUFBOEM7QUFDakRFLGVBQVdKLE9BQVgsQ0FBbUJpTyxTQUFuQixFQUE4Qi9OLE9BQTlCO0FBQ0g7QUFDTSxTQUFTakIsaUJBQVQsQ0FBMkIwSCxVQUEzQixFQUF1QzFGLElBQXZDLEVBQTZDRCxHQUE3QyxFQUFrRDtBQUNyRCxRQUFJa04sSUFBSSxzQkFBa0JsTixHQUFsQixFQUF1QkMsSUFBdkIsQ0FBUjtBQUNBLFNBQUssSUFBSWdFLElBQUksQ0FBYixFQUFnQkEsSUFBSTBCLFdBQVc1RyxNQUEvQixFQUF1Q2tGLEdBQXZDLEVBQTRDO0FBQ3hDakcseUJBQWlCMkgsV0FBVzFCLENBQVgsQ0FBakIsRUFBZ0NpSixDQUFoQztBQUNIO0FBQ0QsV0FBT0EsQ0FBUDtBQUNIIiwiZmlsZSI6ImxpYi9zeW50YXgvZnVuY3Rpb25zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWFwIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGFzc2VydCwgZGljdCwgRU1QVFlfQVJSQVksIHVud3JhcCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0ICogYXMgV2lyZUZvcm1hdCBmcm9tICdAZ2xpbW1lci93aXJlLWZvcm1hdCc7XG5pbXBvcnQgT3Bjb2RlQnVpbGRlciBmcm9tICcuLi9jb21waWxlZC9vcGNvZGVzL2J1aWxkZXInO1xuaW1wb3J0IHsgUmVnaXN0ZXIgfSBmcm9tICcuLi9vcGNvZGVzJztcbmltcG9ydCAqIGFzIENsaWVudFNpZGUgZnJvbSAnLi4vc3ludGF4L2NsaWVudC1zaWRlJztcbmltcG9ydCBSYXdJbmxpbmVCbG9jayBmcm9tICcuL3Jhdy1ibG9jayc7XG52YXIgT3BzID0gV2lyZUZvcm1hdC5PcHM7XG5leHBvcnQgY29uc3QgQVRUUlNfQkxPQ0sgPSAnJmF0dHJzJztcbmNsYXNzIENvbXBpbGVycyB7XG4gICAgY29uc3RydWN0b3Iob2Zmc2V0ID0gMCkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5uYW1lcyA9IGRpY3QoKTtcbiAgICAgICAgdGhpcy5mdW5jcyA9IFtdO1xuICAgIH1cbiAgICBhZGQobmFtZSwgZnVuYykge1xuICAgICAgICB0aGlzLmZ1bmNzLnB1c2goZnVuYyk7XG4gICAgICAgIHRoaXMubmFtZXNbbmFtZV0gPSB0aGlzLmZ1bmNzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGNvbXBpbGUoc2V4cCwgYnVpbGRlcikge1xuICAgICAgICBsZXQgbmFtZSA9IHNleHBbdGhpcy5vZmZzZXRdO1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm5hbWVzW25hbWVdO1xuICAgICAgICBsZXQgZnVuYyA9IHRoaXMuZnVuY3NbaW5kZXhdO1xuICAgICAgICBhc3NlcnQoISFmdW5jLCBgZXhwZWN0ZWQgYW4gaW1wbGVtZW50YXRpb24gZm9yICR7dGhpcy5vZmZzZXQgPT09IDAgPyBPcHNbc2V4cFswXV0gOiBDbGllbnRTaWRlLk9wc1tzZXhwWzFdXX1gKTtcbiAgICAgICAgZnVuYyhzZXhwLCBidWlsZGVyKTtcbiAgICB9XG59XG5jb25zdCBTVEFURU1FTlRTID0gbmV3IENvbXBpbGVycygpO1xuY29uc3QgQ0xJRU5UX1NJREUgPSBuZXcgQ29tcGlsZXJzKDEpO1xuU1RBVEVNRU5UUy5hZGQoT3BzLlRleHQsIChzZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgYnVpbGRlci50ZXh0KHNleHBbMV0pO1xufSk7XG5TVEFURU1FTlRTLmFkZChPcHMuQ29tbWVudCwgKHNleHAsIGJ1aWxkZXIpID0+IHtcbiAgICBidWlsZGVyLmNvbW1lbnQoc2V4cFsxXSk7XG59KTtcblNUQVRFTUVOVFMuYWRkKE9wcy5DbG9zZUVsZW1lbnQsIChfc2V4cCwgYnVpbGRlcikgPT4ge1xuICAgIGJ1aWxkZXIuY2xvc2VFbGVtZW50KCk7XG59KTtcblNUQVRFTUVOVFMuYWRkKE9wcy5GbHVzaEVsZW1lbnQsIChfc2V4cCwgYnVpbGRlcikgPT4ge1xuICAgIGJ1aWxkZXIuZmx1c2hFbGVtZW50KCk7XG59KTtcblNUQVRFTUVOVFMuYWRkKE9wcy5Nb2RpZmllciwgKHNleHAsIGJ1aWxkZXIpID0+IHtcbiAgICBsZXQgeyBlbnYsIG1ldGEgfSA9IGJ1aWxkZXI7XG4gICAgbGV0IFssIG5hbWUsIHBhcmFtcywgaGFzaF0gPSBzZXhwO1xuICAgIGlmIChlbnYuaGFzTW9kaWZpZXIobmFtZSwgbWV0YS50ZW1wbGF0ZU1ldGEpKSB7XG4gICAgICAgIGJ1aWxkZXIuY29tcGlsZUFyZ3MocGFyYW1zLCBoYXNoLCB0cnVlKTtcbiAgICAgICAgYnVpbGRlci5tb2RpZmllcihlbnYubG9va3VwTW9kaWZpZXIobmFtZSwgbWV0YS50ZW1wbGF0ZU1ldGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGUgRXJyb3IgJHtuYW1lfSBpcyBub3QgYSBtb2RpZmllcjogSGVscGVycyBtYXkgbm90IGJlIHVzZWQgaW4gdGhlIGVsZW1lbnQgZm9ybS5gKTtcbiAgICB9XG59KTtcblNUQVRFTUVOVFMuYWRkKE9wcy5TdGF0aWNBdHRyLCAoc2V4cCwgYnVpbGRlcikgPT4ge1xuICAgIGxldCBbLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlXSA9IHNleHA7XG4gICAgYnVpbGRlci5zdGF0aWNBdHRyKG5hbWUsIG5hbWVzcGFjZSwgdmFsdWUpO1xufSk7XG5TVEFURU1FTlRTLmFkZChPcHMuRHluYW1pY0F0dHIsIChzZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgZHluYW1pY0F0dHIoc2V4cCwgZmFsc2UsIGJ1aWxkZXIpO1xufSk7XG5TVEFURU1FTlRTLmFkZChPcHMuVHJ1c3RpbmdBdHRyLCAoc2V4cCwgYnVpbGRlcikgPT4ge1xuICAgIGR5bmFtaWNBdHRyKHNleHAsIHRydWUsIGJ1aWxkZXIpO1xufSk7XG5mdW5jdGlvbiBkeW5hbWljQXR0cihzZXhwLCB0cnVzdGluZywgYnVpbGRlcikge1xuICAgIGxldCBbLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlXSA9IHNleHA7XG4gICAgZXhwcih2YWx1ZSwgYnVpbGRlcik7XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICBidWlsZGVyLmR5bmFtaWNBdHRyTlMobmFtZSwgbmFtZXNwYWNlLCB0cnVzdGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYnVpbGRlci5keW5hbWljQXR0cihuYW1lLCB0cnVzdGluZyk7XG4gICAgfVxufVxuU1RBVEVNRU5UUy5hZGQoT3BzLk9wZW5FbGVtZW50LCAoc2V4cCwgYnVpbGRlcikgPT4ge1xuICAgIGJ1aWxkZXIub3BlblByaW1pdGl2ZUVsZW1lbnQoc2V4cFsxXSk7XG59KTtcbkNMSUVOVF9TSURFLmFkZChDbGllbnRTaWRlLk9wcy5PcGVuQ29tcG9uZW50RWxlbWVudCwgKHNleHAsIGJ1aWxkZXIpID0+IHtcbiAgICBidWlsZGVyLnB1c2hDb21wb25lbnRPcGVyYXRpb25zKCk7XG4gICAgYnVpbGRlci5vcGVuRWxlbWVudFdpdGhPcGVyYXRpb25zKHNleHBbMl0pO1xufSk7XG5DTElFTlRfU0lERS5hZGQoQ2xpZW50U2lkZS5PcHMuRGlkQ3JlYXRlRWxlbWVudCwgKF9zZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgYnVpbGRlci5kaWRDcmVhdGVFbGVtZW50KFJlZ2lzdGVyLnMwKTtcbn0pO1xuQ0xJRU5UX1NJREUuYWRkKENsaWVudFNpZGUuT3BzLkRpZFJlbmRlckxheW91dCwgKF9zZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgYnVpbGRlci5kaWRSZW5kZXJMYXlvdXQoUmVnaXN0ZXIuczApO1xufSk7XG5TVEFURU1FTlRTLmFkZChPcHMuQXBwZW5kLCAoc2V4cCwgYnVpbGRlcikgPT4ge1xuICAgIGxldCBbLCB2YWx1ZSwgdHJ1c3RpbmddID0gc2V4cDtcbiAgICBsZXQgeyBpbmxpbmVzIH0gPSBidWlsZGVyLmVudi5tYWNyb3MoKTtcbiAgICBsZXQgcmV0dXJuZWQgPSBpbmxpbmVzLmNvbXBpbGUoc2V4cCwgYnVpbGRlcikgfHwgdmFsdWU7XG4gICAgaWYgKHJldHVybmVkID09PSB0cnVlKSByZXR1cm47XG4gICAgbGV0IGlzR2V0ID0gRS5pc0dldCh2YWx1ZSk7XG4gICAgbGV0IGlzTWF5YmVMb2NhbCA9IEUuaXNNYXliZUxvY2FsKHZhbHVlKTtcbiAgICBpZiAodHJ1c3RpbmcpIHtcbiAgICAgICAgYnVpbGRlci5ndWFyZGVkQXBwZW5kKHZhbHVlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNHZXQgfHwgaXNNYXliZUxvY2FsKSB7XG4gICAgICAgICAgICBidWlsZGVyLmd1YXJkZWRBcHBlbmQodmFsdWUsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIodmFsdWUsIGJ1aWxkZXIpO1xuICAgICAgICAgICAgYnVpbGRlci5jYXV0aW91c0FwcGVuZCgpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5TVEFURU1FTlRTLmFkZChPcHMuQmxvY2ssIChzZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgbGV0IFssIG5hbWUsIHBhcmFtcywgaGFzaCwgX3RlbXBsYXRlLCBfaW52ZXJzZV0gPSBzZXhwO1xuICAgIGxldCB0ZW1wbGF0ZSA9IGJ1aWxkZXIudGVtcGxhdGUoX3RlbXBsYXRlKTtcbiAgICBsZXQgaW52ZXJzZSA9IGJ1aWxkZXIudGVtcGxhdGUoX2ludmVyc2UpO1xuICAgIGxldCB0ZW1wbGF0ZUJsb2NrID0gdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2NhbigpO1xuICAgIGxldCBpbnZlcnNlQmxvY2sgPSBpbnZlcnNlICYmIGludmVyc2Uuc2NhbigpO1xuICAgIGxldCB7IGJsb2NrcyB9ID0gYnVpbGRlci5lbnYubWFjcm9zKCk7XG4gICAgYmxvY2tzLmNvbXBpbGUobmFtZSwgcGFyYW1zLCBoYXNoLCB0ZW1wbGF0ZUJsb2NrLCBpbnZlcnNlQmxvY2ssIGJ1aWxkZXIpO1xufSk7XG5leHBvcnQgY2xhc3MgSW52b2tlRHluYW1pY0xheW91dCB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIH1cbiAgICBpbnZva2Uodm0sIGxheW91dCkge1xuICAgICAgICBsZXQgeyBzeW1ib2xzLCBoYXNFdmFsIH0gPSBsYXlvdXQuc3ltYm9sVGFibGU7XG4gICAgICAgIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICAgICAgICBsZXQgc2NvcGUgPSB2bS5wdXNoUm9vdFNjb3BlKHN5bWJvbHMubGVuZ3RoICsgMSwgdHJ1ZSk7XG4gICAgICAgIHNjb3BlLmJpbmRTZWxmKHN0YWNrLnBvcCgpKTtcbiAgICAgICAgc2NvcGUuYmluZEJsb2NrKHN5bWJvbHMuaW5kZXhPZihBVFRSU19CTE9DSykgKyAxLCB0aGlzLmF0dHJzKTtcbiAgICAgICAgbGV0IGxvb2t1cCA9IG51bGw7XG4gICAgICAgIGxldCAkZXZhbCA9IC0xO1xuICAgICAgICBpZiAoaGFzRXZhbCkge1xuICAgICAgICAgICAgJGV2YWwgPSBzeW1ib2xzLmluZGV4T2YoJyRldmFsJykgKyAxO1xuICAgICAgICAgICAgbG9va3VwID0gZGljdCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWxsZXJOYW1lcyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gY2FsbGVyTmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBzeW1ib2xzLmluZGV4T2YoY2FsbGVyTmFtZXNbaV0pO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3ltYm9sICE9PSAtMSkgc2NvcGUuYmluZFN5bWJvbChzeW1ib2wgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaGFzRXZhbCkgbG9va3VwW2NhbGxlck5hbWVzW2ldXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW1Qb3NpdGlvbmFsQXJncyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBhc3NlcnQodHlwZW9mIG51bVBvc2l0aW9uYWxBcmdzID09PSAnbnVtYmVyJywgJ1tCVUddIEluY29ycmVjdCB2YWx1ZSBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50IGNvdW50IGZvdW5kIGR1cmluZyBpbnZva2UtZHluYW1pYy1sYXlvdXQuJyk7XG4gICAgICAgIC8vIEN1cnJlbnRseSB3ZSBkb24ndCBzdXBwb3J0IGFjY2Vzc2luZyBwb3NpdGlvbmFsIGFyZ3MgaW4gdGVtcGxhdGVzLCBzbyBqdXN0IHRocm93IHRoZW0gYXdheVxuICAgICAgICBzdGFjay5wb3AobnVtUG9zaXRpb25hbEFyZ3MpO1xuICAgICAgICBsZXQgaW52ZXJzZVN5bWJvbCA9IHN5bWJvbHMuaW5kZXhPZignJmludmVyc2UnKTtcbiAgICAgICAgbGV0IGludmVyc2UgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKGludmVyc2VTeW1ib2wgIT09IC0xKSB7XG4gICAgICAgICAgICBzY29wZS5iaW5kQmxvY2soaW52ZXJzZVN5bWJvbCArIDEsIGludmVyc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rdXApIGxvb2t1cFsnJmludmVyc2UnXSA9IGludmVyc2U7XG4gICAgICAgIGxldCBkZWZhdWx0U3ltYm9sID0gc3ltYm9scy5pbmRleE9mKCcmZGVmYXVsdCcpO1xuICAgICAgICBsZXQgZGVmYXVsdEJsb2NrID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmIChkZWZhdWx0U3ltYm9sICE9PSAtMSkge1xuICAgICAgICAgICAgc2NvcGUuYmluZEJsb2NrKGRlZmF1bHRTeW1ib2wgKyAxLCBkZWZhdWx0QmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rdXApIGxvb2t1cFsnJmRlZmF1bHQnXSA9IGRlZmF1bHRCbG9jaztcbiAgICAgICAgaWYgKGxvb2t1cCkgc2NvcGUuYmluZEV2YWxTY29wZShsb29rdXApO1xuICAgICAgICB2bS5wdXNoRnJhbWUoKTtcbiAgICAgICAgdm0uY2FsbChsYXlvdXQuaGFuZGxlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBHbGltbWVyRGVidWc6ICc8aW52b2tlLWR5bmFtaWMtbGF5b3V0PicgfTtcbiAgICB9XG59XG5TVEFURU1FTlRTLmFkZChPcHMuQ29tcG9uZW50LCAoc2V4cCwgYnVpbGRlcikgPT4ge1xuICAgIGxldCBbLCB0YWcsIGF0dHJzLCBhcmdzLCBibG9ja10gPSBzZXhwO1xuICAgIGlmIChidWlsZGVyLmVudi5oYXNDb21wb25lbnREZWZpbml0aW9uKHRhZywgYnVpbGRlci5tZXRhLnRlbXBsYXRlTWV0YSkpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gYnVpbGRlci50ZW1wbGF0ZShibG9jayk7XG4gICAgICAgIGxldCBhdHRyc0Jsb2NrID0gbmV3IFJhd0lubGluZUJsb2NrKGJ1aWxkZXIubWV0YSwgYXR0cnMsIEVNUFRZX0FSUkFZKTtcbiAgICAgICAgbGV0IGRlZmluaXRpb24gPSBidWlsZGVyLmVudi5nZXRDb21wb25lbnREZWZpbml0aW9uKHRhZywgYnVpbGRlci5tZXRhLnRlbXBsYXRlTWV0YSk7XG4gICAgICAgIGJ1aWxkZXIucHVzaENvbXBvbmVudE1hbmFnZXIoZGVmaW5pdGlvbik7XG4gICAgICAgIGJ1aWxkZXIuaW52b2tlQ29tcG9uZW50KGF0dHJzQmxvY2ssIG51bGwsIGFyZ3MsIGNoaWxkICYmIGNoaWxkLnNjYW4oKSk7XG4gICAgfSBlbHNlIGlmIChibG9jayAmJiBibG9jay5wYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbXBpbGUgRXJyb3I6IENhbm5vdCBmaW5kIGNvbXBvbmVudCAke3RhZ31gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWlsZGVyLm9wZW5QcmltaXRpdmVFbGVtZW50KHRhZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIFNUQVRFTUVOVFMuY29tcGlsZShhdHRyc1tpXSwgYnVpbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRlci5mbHVzaEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICBsZXQgc3RtdHMgPSBibG9jay5zdGF0ZW1lbnRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG10cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIFNUQVRFTUVOVFMuY29tcGlsZShzdG10c1tpXSwgYnVpbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRlci5jbG9zZUVsZW1lbnQoKTtcbiAgICB9XG59KTtcbmV4cG9ydCBjbGFzcyBQYXJ0aWFsSW52b2tlciB7XG4gICAgY29uc3RydWN0b3Iob3V0ZXJTeW1ib2xzLCBldmFsSW5mbykge1xuICAgICAgICB0aGlzLm91dGVyU3ltYm9scyA9IG91dGVyU3ltYm9scztcbiAgICAgICAgdGhpcy5ldmFsSW5mbyA9IGV2YWxJbmZvO1xuICAgIH1cbiAgICBpbnZva2Uodm0sIF9wYXJ0aWFsKSB7XG4gICAgICAgIGxldCBwYXJ0aWFsID0gdW53cmFwKF9wYXJ0aWFsKTtcbiAgICAgICAgbGV0IHBhcnRpYWxTeW1ib2xzID0gcGFydGlhbC5zeW1ib2xUYWJsZS5zeW1ib2xzO1xuICAgICAgICBsZXQgb3V0ZXJTY29wZSA9IHZtLnNjb3BlKCk7XG4gICAgICAgIGxldCBwYXJ0aWFsU2NvcGUgPSB2bS5wdXNoUm9vdFNjb3BlKHBhcnRpYWxTeW1ib2xzLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICBwYXJ0aWFsU2NvcGUuYmluZENhbGxlclNjb3BlKG91dGVyU2NvcGUuZ2V0Q2FsbGVyU2NvcGUoKSk7XG4gICAgICAgIHBhcnRpYWxTY29wZS5iaW5kRXZhbFNjb3BlKG91dGVyU2NvcGUuZ2V0RXZhbFNjb3BlKCkpO1xuICAgICAgICBwYXJ0aWFsU2NvcGUuYmluZFNlbGYob3V0ZXJTY29wZS5nZXRTZWxmKCkpO1xuICAgICAgICBsZXQgeyBldmFsSW5mbywgb3V0ZXJTeW1ib2xzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbG9jYWxzID0gZGljdCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2YWxJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc2xvdCA9IGV2YWxJbmZvW2ldO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBvdXRlclN5bWJvbHNbc2xvdCAtIDFdO1xuICAgICAgICAgICAgbGV0IHJlZiA9IG91dGVyU2NvcGUuZ2V0U3ltYm9sKHNsb3QpO1xuICAgICAgICAgICAgbG9jYWxzW25hbWVdID0gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmFsU2NvcGUgPSBvdXRlclNjb3BlLmdldEV2YWxTY29wZSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpYWxTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHBhcnRpYWxTeW1ib2xzW2ldO1xuICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGkgKyAxO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZXZhbFNjb3BlW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHBhcnRpYWxTY29wZS5iaW5kKHN5bWJvbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRpYWxTY29wZS5iaW5kUGFydGlhbE1hcChsb2NhbHMpO1xuICAgICAgICB2bS5wdXNoRnJhbWUoKTtcbiAgICAgICAgdm0uY2FsbChwYXJ0aWFsLmhhbmRsZSk7XG4gICAgfVxufVxuU1RBVEVNRU5UUy5hZGQoT3BzLlBhcnRpYWwsIChzZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgbGV0IFssIG5hbWUsIGV2YWxJbmZvXSA9IHNleHA7XG4gICAgbGV0IHsgdGVtcGxhdGVNZXRhLCBzeW1ib2xzIH0gPSBidWlsZGVyLm1ldGE7XG4gICAgZnVuY3Rpb24gaGVscGVyKHZtLCBhcmdzKSB7XG4gICAgICAgIGxldCB7IGVudiB9ID0gdm07XG4gICAgICAgIGxldCBuYW1lUmVmID0gYXJncy5wb3NpdGlvbmFsLmF0KDApO1xuICAgICAgICByZXR1cm4gbWFwKG5hbWVSZWYsIG4gPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuID09PSAnc3RyaW5nJyAmJiBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbnYuaGFzUGFydGlhbChuLCB0ZW1wbGF0ZU1ldGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBwYXJ0aWFsIG5hbWVkIFwiJHtufVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbnYubG9va3VwUGFydGlhbChuLCB0ZW1wbGF0ZU1ldGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhIHBhcnRpYWwgbmFtZWQgXCIke1N0cmluZyhuKX1cImApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJ1aWxkZXIuc3RhcnRMYWJlbHMoKTtcbiAgICBidWlsZGVyLnB1c2hGcmFtZSgpO1xuICAgIGJ1aWxkZXIucmV0dXJuVG8oJ0VORCcpO1xuICAgIGV4cHIobmFtZSwgYnVpbGRlcik7XG4gICAgYnVpbGRlci5wdXNoSW1tZWRpYXRlKDEpO1xuICAgIGJ1aWxkZXIucHVzaEltbWVkaWF0ZShFTVBUWV9BUlJBWSk7XG4gICAgYnVpbGRlci5wdXNoQXJncyh0cnVlKTtcbiAgICBidWlsZGVyLmhlbHBlcihoZWxwZXIpO1xuICAgIGJ1aWxkZXIuZHVwKCk7XG4gICAgYnVpbGRlci50ZXN0KCdzaW1wbGUnKTtcbiAgICBidWlsZGVyLmVudGVyKDIpO1xuICAgIGJ1aWxkZXIuanVtcFVubGVzcygnRUxTRScpO1xuICAgIGJ1aWxkZXIuZ2V0UGFydGlhbFRlbXBsYXRlKCk7XG4gICAgYnVpbGRlci5jb21waWxlRHluYW1pY0Jsb2NrKCk7XG4gICAgYnVpbGRlci5pbnZva2VEeW5hbWljKG5ldyBQYXJ0aWFsSW52b2tlcihzeW1ib2xzLCBldmFsSW5mbykpO1xuICAgIGJ1aWxkZXIucG9wU2NvcGUoKTtcbiAgICBidWlsZGVyLnBvcEZyYW1lKCk7XG4gICAgYnVpbGRlci5sYWJlbCgnRUxTRScpO1xuICAgIGJ1aWxkZXIuZXhpdCgpO1xuICAgIGJ1aWxkZXIucmV0dXJuKCk7XG4gICAgYnVpbGRlci5sYWJlbCgnRU5EJyk7XG4gICAgYnVpbGRlci5wb3BGcmFtZSgpO1xuICAgIGJ1aWxkZXIuc3RvcExhYmVscygpO1xufSk7XG5jbGFzcyBJbnZva2VEeW5hbWljWWllbGQge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxlckNvdW50KSB7XG4gICAgICAgIHRoaXMuY2FsbGVyQ291bnQgPSBjYWxsZXJDb3VudDtcbiAgICB9XG4gICAgaW52b2tlKHZtLCBibG9jaykge1xuICAgICAgICBsZXQgeyBjYWxsZXJDb3VudCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgIC8vIFRvIGJhbGFuY2UgdGhlIHBvcHtGcmFtZSxTY29wZX1cbiAgICAgICAgICAgIHZtLnB1c2hGcmFtZSgpO1xuICAgICAgICAgICAgdm0ucHVzaENhbGxlclNjb3BlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhYmxlID0gYmxvY2suc3ltYm9sVGFibGU7XG4gICAgICAgIGxldCBsb2NhbHMgPSB0YWJsZS5wYXJhbWV0ZXJzOyAvLyBhbHdheXMgcHJlc2VudCBpbiBpbmxpbmUgYmxvY2tzXG4gICAgICAgIGxldCBjYWxsZWVDb3VudCA9IGxvY2FscyA/IGxvY2Fscy5sZW5ndGggOiAwO1xuICAgICAgICBsZXQgY291bnQgPSBNYXRoLm1pbihjYWxsZXJDb3VudCwgY2FsbGVlQ291bnQpO1xuICAgICAgICB2bS5wdXNoRnJhbWUoKTtcbiAgICAgICAgdm0ucHVzaENhbGxlclNjb3BlKGNhbGxlZUNvdW50ID4gMCk7XG4gICAgICAgIGxldCBzY29wZSA9IHZtLnNjb3BlKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgc2NvcGUuYmluZFN5bWJvbChsb2NhbHNbaV0sIHN0YWNrLmZyb21CYXNlKGNhbGxlckNvdW50IC0gaSkpO1xuICAgICAgICB9XG4gICAgICAgIHZtLmNhbGwoYmxvY2suaGFuZGxlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBHbGltbWVyRGVidWc6IGA8aW52b2tlLWR5bmFtaWMteWllbGQgY2FsbGVyLWNvdW50PSR7dGhpcy5jYWxsZXJDb3VudH0+YCB9O1xuICAgIH1cbn1cblNUQVRFTUVOVFMuYWRkKE9wcy5ZaWVsZCwgKHNleHAsIGJ1aWxkZXIpID0+IHtcbiAgICBsZXQgWywgdG8sIHBhcmFtc10gPSBzZXhwO1xuICAgIGxldCBjb3VudCA9IGNvbXBpbGVMaXN0KHBhcmFtcywgYnVpbGRlcik7XG4gICAgYnVpbGRlci5nZXRCbG9jayh0byk7XG4gICAgYnVpbGRlci5jb21waWxlRHluYW1pY0Jsb2NrKCk7XG4gICAgYnVpbGRlci5pbnZva2VEeW5hbWljKG5ldyBJbnZva2VEeW5hbWljWWllbGQoY291bnQpKTtcbiAgICBidWlsZGVyLnBvcFNjb3BlKCk7XG4gICAgYnVpbGRlci5wb3BGcmFtZSgpO1xuICAgIGlmIChjb3VudCkge1xuICAgICAgICBidWlsZGVyLnBvcChjb3VudCk7XG4gICAgfVxufSk7XG5TVEFURU1FTlRTLmFkZChPcHMuRGVidWdnZXIsIChzZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgbGV0IFssIGV2YWxJbmZvXSA9IHNleHA7XG4gICAgYnVpbGRlci5kZWJ1Z2dlcihidWlsZGVyLm1ldGEuc3ltYm9scywgZXZhbEluZm8pO1xufSk7XG5TVEFURU1FTlRTLmFkZChPcHMuQ2xpZW50U2lkZVN0YXRlbWVudCwgKHNleHAsIGJ1aWxkZXIpID0+IHtcbiAgICBDTElFTlRfU0lERS5jb21waWxlKHNleHAsIGJ1aWxkZXIpO1xufSk7XG5jb25zdCBFWFBSRVNTSU9OUyA9IG5ldyBDb21waWxlcnMoKTtcbmNvbnN0IENMSUVOVF9TSURFX0VYUFJTID0gbmV3IENvbXBpbGVycygxKTtcbnZhciBFID0gV2lyZUZvcm1hdC5FeHByZXNzaW9ucztcbmV4cG9ydCBmdW5jdGlvbiBleHByKGV4cHJlc3Npb24sIGJ1aWxkZXIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShleHByZXNzaW9uKSkge1xuICAgICAgICBFWFBSRVNTSU9OUy5jb21waWxlKGV4cHJlc3Npb24sIGJ1aWxkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1aWxkZXIucHJpbWl0aXZlKGV4cHJlc3Npb24pO1xuICAgIH1cbn1cbkVYUFJFU1NJT05TLmFkZChPcHMuVW5rbm93biwgKHNleHAsIGJ1aWxkZXIpID0+IHtcbiAgICBsZXQgbmFtZSA9IHNleHBbMV07XG4gICAgaWYgKGJ1aWxkZXIuZW52Lmhhc0hlbHBlcihuYW1lLCBidWlsZGVyLm1ldGEudGVtcGxhdGVNZXRhKSkge1xuICAgICAgICBFWFBSRVNTSU9OUy5jb21waWxlKFtPcHMuSGVscGVyLCBuYW1lLCBFTVBUWV9BUlJBWSwgbnVsbF0sIGJ1aWxkZXIpO1xuICAgIH0gZWxzZSBpZiAoYnVpbGRlci5tZXRhLmFzUGFydGlhbCkge1xuICAgICAgICBidWlsZGVyLnJlc29sdmVNYXliZUxvY2FsKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1aWxkZXIuZ2V0VmFyaWFibGUoMCk7XG4gICAgICAgIGJ1aWxkZXIuZ2V0UHJvcGVydHkobmFtZSk7XG4gICAgfVxufSk7XG5FWFBSRVNTSU9OUy5hZGQoT3BzLkNvbmNhdCwgKHNleHAsIGJ1aWxkZXIpID0+IHtcbiAgICBsZXQgcGFydHMgPSBzZXhwWzFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhwcihwYXJ0c1tpXSwgYnVpbGRlcik7XG4gICAgfVxuICAgIGJ1aWxkZXIuY29uY2F0KHBhcnRzLmxlbmd0aCk7XG59KTtcbkNMSUVOVF9TSURFX0VYUFJTLmFkZChDbGllbnRTaWRlLk9wcy5GdW5jdGlvbkV4cHJlc3Npb24sIChzZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgYnVpbGRlci5mdW5jdGlvbihzZXhwWzJdKTtcbn0pO1xuRVhQUkVTU0lPTlMuYWRkKE9wcy5IZWxwZXIsIChzZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgbGV0IHsgZW52LCBtZXRhIH0gPSBidWlsZGVyO1xuICAgIGxldCBbLCBuYW1lLCBwYXJhbXMsIGhhc2hdID0gc2V4cDtcbiAgICBpZiAoZW52Lmhhc0hlbHBlcihuYW1lLCBtZXRhLnRlbXBsYXRlTWV0YSkpIHtcbiAgICAgICAgYnVpbGRlci5jb21waWxlQXJncyhwYXJhbXMsIGhhc2gsIHRydWUpO1xuICAgICAgICBidWlsZGVyLmhlbHBlcihlbnYubG9va3VwSGVscGVyKG5hbWUsIG1ldGEudGVtcGxhdGVNZXRhKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlIEVycm9yOiAke25hbWV9IGlzIG5vdCBhIGhlbHBlcmApO1xuICAgIH1cbn0pO1xuRVhQUkVTU0lPTlMuYWRkKE9wcy5HZXQsIChzZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgbGV0IFssIGhlYWQsIHBhdGhdID0gc2V4cDtcbiAgICBidWlsZGVyLmdldFZhcmlhYmxlKGhlYWQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWlsZGVyLmdldFByb3BlcnR5KHBhdGhbaV0pO1xuICAgIH1cbn0pO1xuRVhQUkVTU0lPTlMuYWRkKE9wcy5NYXliZUxvY2FsLCAoc2V4cCwgYnVpbGRlcikgPT4ge1xuICAgIGxldCBbLCBwYXRoXSA9IHNleHA7XG4gICAgaWYgKGJ1aWxkZXIubWV0YS5hc1BhcnRpYWwpIHtcbiAgICAgICAgbGV0IGhlYWQgPSBwYXRoWzBdO1xuICAgICAgICBwYXRoID0gcGF0aC5zbGljZSgxKTtcbiAgICAgICAgYnVpbGRlci5yZXNvbHZlTWF5YmVMb2NhbChoZWFkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWlsZGVyLmdldFZhcmlhYmxlKDApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnVpbGRlci5nZXRQcm9wZXJ0eShwYXRoW2ldKTtcbiAgICB9XG59KTtcbkVYUFJFU1NJT05TLmFkZChPcHMuVW5kZWZpbmVkLCAoX3NleHAsIGJ1aWxkZXIpID0+IHtcbiAgICByZXR1cm4gYnVpbGRlci5wcmltaXRpdmUodW5kZWZpbmVkKTtcbn0pO1xuRVhQUkVTU0lPTlMuYWRkKE9wcy5IYXNCbG9jaywgKHNleHAsIGJ1aWxkZXIpID0+IHtcbiAgICBidWlsZGVyLmhhc0Jsb2NrKHNleHBbMV0pO1xufSk7XG5FWFBSRVNTSU9OUy5hZGQoT3BzLkhhc0Jsb2NrUGFyYW1zLCAoc2V4cCwgYnVpbGRlcikgPT4ge1xuICAgIGJ1aWxkZXIuaGFzQmxvY2tQYXJhbXMoc2V4cFsxXSk7XG59KTtcbkVYUFJFU1NJT05TLmFkZChPcHMuQ2xpZW50U2lkZUV4cHJlc3Npb24sIChzZXhwLCBidWlsZGVyKSA9PiB7XG4gICAgQ0xJRU5UX1NJREVfRVhQUlMuY29tcGlsZShzZXhwLCBidWlsZGVyKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVMaXN0KHBhcmFtcywgYnVpbGRlcikge1xuICAgIGlmICghcGFyYW1zKSByZXR1cm4gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHByKHBhcmFtc1tpXSwgYnVpbGRlcik7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXMubGVuZ3RoO1xufVxuZXhwb3J0IGNsYXNzIEJsb2NrcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmFtZXMgPSBkaWN0KCk7XG4gICAgICAgIHRoaXMuZnVuY3MgPSBbXTtcbiAgICB9XG4gICAgYWRkKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jcy5wdXNoKGZ1bmMpO1xuICAgICAgICB0aGlzLm5hbWVzW25hbWVdID0gdGhpcy5mdW5jcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBhZGRNaXNzaW5nKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5taXNzaW5nID0gZnVuYztcbiAgICB9XG4gICAgY29tcGlsZShuYW1lLCBwYXJhbXMsIGhhc2gsIHRlbXBsYXRlLCBpbnZlcnNlLCBidWlsZGVyKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubmFtZXNbbmFtZV07XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnQoISF0aGlzLm1pc3NpbmcsIGAke25hbWV9IG5vdCBmb3VuZCwgYW5kIG5vIGNhdGNoLWFsbCBibG9jayBoYW5kbGVyIHdhcyByZWdpc3RlcmVkYCk7XG4gICAgICAgICAgICBsZXQgZnVuYyA9IHRoaXMubWlzc2luZztcbiAgICAgICAgICAgIGxldCBoYW5kbGVkID0gZnVuYyhuYW1lLCBwYXJhbXMsIGhhc2gsIHRlbXBsYXRlLCBpbnZlcnNlLCBidWlsZGVyKTtcbiAgICAgICAgICAgIGFzc2VydCghIWhhbmRsZWQsIGAke25hbWV9IG5vdCBmb3VuZCwgYW5kIHRoZSBjYXRjaC1hbGwgYmxvY2sgaGFuZGxlciBkaWRuJ3QgaGFuZGxlIGl0YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZnVuYyA9IHRoaXMuZnVuY3NbaW5kZXhdO1xuICAgICAgICAgICAgZnVuYyhwYXJhbXMsIGhhc2gsIHRlbXBsYXRlLCBpbnZlcnNlLCBidWlsZGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBCTE9DS1MgPSBuZXcgQmxvY2tzKCk7XG5leHBvcnQgY2xhc3MgSW5saW5lcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmFtZXMgPSBkaWN0KCk7XG4gICAgICAgIHRoaXMuZnVuY3MgPSBbXTtcbiAgICB9XG4gICAgYWRkKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5mdW5jcy5wdXNoKGZ1bmMpO1xuICAgICAgICB0aGlzLm5hbWVzW25hbWVdID0gdGhpcy5mdW5jcy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBhZGRNaXNzaW5nKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5taXNzaW5nID0gZnVuYztcbiAgICB9XG4gICAgY29tcGlsZShzZXhwLCBidWlsZGVyKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHNleHBbMV07XG4gICAgICAgIC8vIFRPRE86IEZpeCB0aGlzIHNvIHRoYXQgZXhwcmVzc2lvbiBtYWNyb3MgY2FuIHJldHVyblxuICAgICAgICAvLyB0aGluZ3MgbGlrZSBjb21wb25lbnRzLCBzbyB0aGF0IHt7Y29tcG9uZW50IGZvb319XG4gICAgICAgIC8vIGlzIHRoZSBzYW1lIGFzIHt7KGNvbXBvbmVudCBmb28pfX1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIFsnZXhwcicsIHZhbHVlXTtcbiAgICAgICAgbGV0IG5hbWU7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGxldCBoYXNoO1xuICAgICAgICBpZiAodmFsdWVbMF0gPT09IE9wcy5IZWxwZXIpIHtcbiAgICAgICAgICAgIG5hbWUgPSB2YWx1ZVsxXTtcbiAgICAgICAgICAgIHBhcmFtcyA9IHZhbHVlWzJdO1xuICAgICAgICAgICAgaGFzaCA9IHZhbHVlWzNdO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlWzBdID09PSBPcHMuVW5rbm93bikge1xuICAgICAgICAgICAgbmFtZSA9IHZhbHVlWzFdO1xuICAgICAgICAgICAgcGFyYW1zID0gaGFzaCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gWydleHByJywgdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubmFtZXNbbmFtZV07XG4gICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkICYmIHRoaXMubWlzc2luZykge1xuICAgICAgICAgICAgbGV0IGZ1bmMgPSB0aGlzLm1pc3Npbmc7XG4gICAgICAgICAgICBsZXQgcmV0dXJuZWQgPSBmdW5jKG5hbWUsIHBhcmFtcywgaGFzaCwgYnVpbGRlcik7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuZWQgPT09IGZhbHNlID8gWydleHByJywgdmFsdWVdIDogcmV0dXJuZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGZ1bmMgPSB0aGlzLmZ1bmNzW2luZGV4XTtcbiAgICAgICAgICAgIGxldCByZXR1cm5lZCA9IGZ1bmMobmFtZSwgcGFyYW1zLCBoYXNoLCBidWlsZGVyKTtcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5lZCA9PT0gZmFsc2UgPyBbJ2V4cHInLCB2YWx1ZV0gOiByZXR1cm5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2V4cHInLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgSU5MSU5FUyA9IG5ldyBJbmxpbmVzKCk7XG5wb3B1bGF0ZUJ1aWx0aW5zKEJMT0NLUywgSU5MSU5FUyk7XG5leHBvcnQgZnVuY3Rpb24gcG9wdWxhdGVCdWlsdGlucyhibG9ja3MgPSBuZXcgQmxvY2tzKCksIGlubGluZXMgPSBuZXcgSW5saW5lcygpKSB7XG4gICAgYmxvY2tzLmFkZCgnaWYnLCAocGFyYW1zLCBfaGFzaCwgdGVtcGxhdGUsIGludmVyc2UsIGJ1aWxkZXIpID0+IHtcbiAgICAgICAgLy8gICAgICAgIFB1dEFyZ3NcbiAgICAgICAgLy8gICAgICAgIFRlc3QoRW52aXJvbm1lbnQpXG4gICAgICAgIC8vICAgICAgICBFbnRlcihCRUdJTiwgRU5EKVxuICAgICAgICAvLyBCRUdJTjogTm9vcFxuICAgICAgICAvLyAgICAgICAgSnVtcFVubGVzcyhFTFNFKVxuICAgICAgICAvLyAgICAgICAgRXZhbHVhdGUoZGVmYXVsdClcbiAgICAgICAgLy8gICAgICAgIEp1bXAoRU5EKVxuICAgICAgICAvLyBFTFNFOiAgTm9vcFxuICAgICAgICAvLyAgICAgICAgRXZhbHVsYXRlKGludmVyc2UpXG4gICAgICAgIC8vIEVORDogICBOb29wXG4gICAgICAgIC8vICAgICAgICBFeGl0XG4gICAgICAgIGlmICghcGFyYW1zIHx8IHBhcmFtcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU1lOVEFYIEVSUk9SOiAjaWYgcmVxdWlyZXMgYSBzaW5nbGUgYXJndW1lbnRgKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLnN0YXJ0TGFiZWxzKCk7XG4gICAgICAgIGJ1aWxkZXIucHVzaEZyYW1lKCk7XG4gICAgICAgIGJ1aWxkZXIucmV0dXJuVG8oJ0VORCcpO1xuICAgICAgICBleHByKHBhcmFtc1swXSwgYnVpbGRlcik7XG4gICAgICAgIGJ1aWxkZXIudGVzdCgnZW52aXJvbm1lbnQnKTtcbiAgICAgICAgYnVpbGRlci5lbnRlcigxKTtcbiAgICAgICAgYnVpbGRlci5qdW1wVW5sZXNzKCdFTFNFJyk7XG4gICAgICAgIGJ1aWxkZXIuaW52b2tlU3RhdGljKHVud3JhcCh0ZW1wbGF0ZSkpO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgYnVpbGRlci5qdW1wKCdFWElUJyk7XG4gICAgICAgICAgICBidWlsZGVyLmxhYmVsKCdFTFNFJyk7XG4gICAgICAgICAgICBidWlsZGVyLmludm9rZVN0YXRpYyhpbnZlcnNlKTtcbiAgICAgICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VYSVQnKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuZXhpdCgpO1xuICAgICAgICAgICAgYnVpbGRlci5yZXR1cm4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VMU0UnKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuZXhpdCgpO1xuICAgICAgICAgICAgYnVpbGRlci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLmxhYmVsKCdFTkQnKTtcbiAgICAgICAgYnVpbGRlci5wb3BGcmFtZSgpO1xuICAgICAgICBidWlsZGVyLnN0b3BMYWJlbHMoKTtcbiAgICB9KTtcbiAgICBibG9ja3MuYWRkKCd1bmxlc3MnLCAocGFyYW1zLCBfaGFzaCwgdGVtcGxhdGUsIGludmVyc2UsIGJ1aWxkZXIpID0+IHtcbiAgICAgICAgLy8gICAgICAgIFB1dEFyZ3NcbiAgICAgICAgLy8gICAgICAgIFRlc3QoRW52aXJvbm1lbnQpXG4gICAgICAgIC8vICAgICAgICBFbnRlcihCRUdJTiwgRU5EKVxuICAgICAgICAvLyBCRUdJTjogTm9vcFxuICAgICAgICAvLyAgICAgICAgSnVtcFVubGVzcyhFTFNFKVxuICAgICAgICAvLyAgICAgICAgRXZhbHVhdGUoZGVmYXVsdClcbiAgICAgICAgLy8gICAgICAgIEp1bXAoRU5EKVxuICAgICAgICAvLyBFTFNFOiAgTm9vcFxuICAgICAgICAvLyAgICAgICAgRXZhbHVsYXRlKGludmVyc2UpXG4gICAgICAgIC8vIEVORDogICBOb29wXG4gICAgICAgIC8vICAgICAgICBFeGl0XG4gICAgICAgIGlmICghcGFyYW1zIHx8IHBhcmFtcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU1lOVEFYIEVSUk9SOiAjdW5sZXNzIHJlcXVpcmVzIGEgc2luZ2xlIGFyZ3VtZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRlci5zdGFydExhYmVscygpO1xuICAgICAgICBidWlsZGVyLnB1c2hGcmFtZSgpO1xuICAgICAgICBidWlsZGVyLnJldHVyblRvKCdFTkQnKTtcbiAgICAgICAgZXhwcihwYXJhbXNbMF0sIGJ1aWxkZXIpO1xuICAgICAgICBidWlsZGVyLnRlc3QoJ2Vudmlyb25tZW50Jyk7XG4gICAgICAgIGJ1aWxkZXIuZW50ZXIoMSk7XG4gICAgICAgIGJ1aWxkZXIuanVtcElmKCdFTFNFJyk7XG4gICAgICAgIGJ1aWxkZXIuaW52b2tlU3RhdGljKHVud3JhcCh0ZW1wbGF0ZSkpO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgYnVpbGRlci5qdW1wKCdFWElUJyk7XG4gICAgICAgICAgICBidWlsZGVyLmxhYmVsKCdFTFNFJyk7XG4gICAgICAgICAgICBidWlsZGVyLmludm9rZVN0YXRpYyhpbnZlcnNlKTtcbiAgICAgICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VYSVQnKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuZXhpdCgpO1xuICAgICAgICAgICAgYnVpbGRlci5yZXR1cm4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VMU0UnKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuZXhpdCgpO1xuICAgICAgICAgICAgYnVpbGRlci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLmxhYmVsKCdFTkQnKTtcbiAgICAgICAgYnVpbGRlci5wb3BGcmFtZSgpO1xuICAgICAgICBidWlsZGVyLnN0b3BMYWJlbHMoKTtcbiAgICB9KTtcbiAgICBibG9ja3MuYWRkKCd3aXRoJywgKHBhcmFtcywgX2hhc2gsIHRlbXBsYXRlLCBpbnZlcnNlLCBidWlsZGVyKSA9PiB7XG4gICAgICAgIC8vICAgICAgICBQdXRBcmdzXG4gICAgICAgIC8vICAgICAgICBUZXN0KEVudmlyb25tZW50KVxuICAgICAgICAvLyAgICAgICAgRW50ZXIoQkVHSU4sIEVORClcbiAgICAgICAgLy8gQkVHSU46IE5vb3BcbiAgICAgICAgLy8gICAgICAgIEp1bXBVbmxlc3MoRUxTRSlcbiAgICAgICAgLy8gICAgICAgIEV2YWx1YXRlKGRlZmF1bHQpXG4gICAgICAgIC8vICAgICAgICBKdW1wKEVORClcbiAgICAgICAgLy8gRUxTRTogIE5vb3BcbiAgICAgICAgLy8gICAgICAgIEV2YWx1bGF0ZShpbnZlcnNlKVxuICAgICAgICAvLyBFTkQ6ICAgTm9vcFxuICAgICAgICAvLyAgICAgICAgRXhpdFxuICAgICAgICBpZiAoIXBhcmFtcyB8fCBwYXJhbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNZTlRBWCBFUlJPUjogI3dpdGggcmVxdWlyZXMgYSBzaW5nbGUgYXJndW1lbnRgKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLnN0YXJ0TGFiZWxzKCk7XG4gICAgICAgIGJ1aWxkZXIucHVzaEZyYW1lKCk7XG4gICAgICAgIGJ1aWxkZXIucmV0dXJuVG8oJ0VORCcpO1xuICAgICAgICBleHByKHBhcmFtc1swXSwgYnVpbGRlcik7XG4gICAgICAgIGJ1aWxkZXIuZHVwKCk7XG4gICAgICAgIGJ1aWxkZXIudGVzdCgnZW52aXJvbm1lbnQnKTtcbiAgICAgICAgYnVpbGRlci5lbnRlcigyKTtcbiAgICAgICAgYnVpbGRlci5qdW1wVW5sZXNzKCdFTFNFJyk7XG4gICAgICAgIGJ1aWxkZXIuaW52b2tlU3RhdGljKHVud3JhcCh0ZW1wbGF0ZSksIDEpO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgYnVpbGRlci5qdW1wKCdFWElUJyk7XG4gICAgICAgICAgICBidWlsZGVyLmxhYmVsKCdFTFNFJyk7XG4gICAgICAgICAgICBidWlsZGVyLmludm9rZVN0YXRpYyhpbnZlcnNlKTtcbiAgICAgICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VYSVQnKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuZXhpdCgpO1xuICAgICAgICAgICAgYnVpbGRlci5yZXR1cm4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VMU0UnKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuZXhpdCgpO1xuICAgICAgICAgICAgYnVpbGRlci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLmxhYmVsKCdFTkQnKTtcbiAgICAgICAgYnVpbGRlci5wb3BGcmFtZSgpO1xuICAgICAgICBidWlsZGVyLnN0b3BMYWJlbHMoKTtcbiAgICB9KTtcbiAgICBibG9ja3MuYWRkKCdlYWNoJywgKHBhcmFtcywgaGFzaCwgdGVtcGxhdGUsIGludmVyc2UsIGJ1aWxkZXIpID0+IHtcbiAgICAgICAgLy8gICAgICAgICBFbnRlcihCRUdJTiwgRU5EKVxuICAgICAgICAvLyBCRUdJTjogIE5vb3BcbiAgICAgICAgLy8gICAgICAgICBQdXRBcmdzXG4gICAgICAgIC8vICAgICAgICAgUHV0SXRlcmFibGVcbiAgICAgICAgLy8gICAgICAgICBKdW1wVW5sZXNzKEVMU0UpXG4gICAgICAgIC8vICAgICAgICAgRW50ZXJMaXN0KEJFR0lOMiwgRU5EMilcbiAgICAgICAgLy8gSVRFUjogICBOb29wXG4gICAgICAgIC8vICAgICAgICAgTmV4dEl0ZXIoQlJFQUspXG4gICAgICAgIC8vIEJFR0lOMjogTm9vcFxuICAgICAgICAvLyAgICAgICAgIFB1c2hDaGlsZFNjb3BlXG4gICAgICAgIC8vICAgICAgICAgRXZhbHVhdGUoZGVmYXVsdClcbiAgICAgICAgLy8gICAgICAgICBQb3BTY29wZVxuICAgICAgICAvLyBFTkQyOiAgIE5vb3BcbiAgICAgICAgLy8gICAgICAgICBFeGl0XG4gICAgICAgIC8vICAgICAgICAgSnVtcChJVEVSKVxuICAgICAgICAvLyBCUkVBSzogIE5vb3BcbiAgICAgICAgLy8gICAgICAgICBFeGl0TGlzdFxuICAgICAgICAvLyAgICAgICAgIEp1bXAoRU5EKVxuICAgICAgICAvLyBFTFNFOiAgIE5vb3BcbiAgICAgICAgLy8gICAgICAgICBFdmFsdWxhdGUoaW52ZXJzZSlcbiAgICAgICAgLy8gRU5EOiAgICBOb29wXG4gICAgICAgIC8vICAgICAgICAgRXhpdFxuICAgICAgICBidWlsZGVyLnN0YXJ0TGFiZWxzKCk7XG4gICAgICAgIGJ1aWxkZXIucHVzaEZyYW1lKCk7XG4gICAgICAgIGJ1aWxkZXIucmV0dXJuVG8oJ0VORCcpO1xuICAgICAgICBpZiAoaGFzaCAmJiBoYXNoWzBdWzBdID09PSAna2V5Jykge1xuICAgICAgICAgICAgZXhwcihoYXNoWzFdWzBdLCBidWlsZGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1aWxkZXIucHJpbWl0aXZlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHIocGFyYW1zWzBdLCBidWlsZGVyKTtcbiAgICAgICAgYnVpbGRlci5lbnRlcigyKTtcbiAgICAgICAgYnVpbGRlci5wdXRJdGVyYXRvcigpO1xuICAgICAgICBidWlsZGVyLmp1bXBVbmxlc3MoJ0VMU0UnKTtcbiAgICAgICAgYnVpbGRlci5wdXNoRnJhbWUoKTtcbiAgICAgICAgYnVpbGRlci5yZXR1cm5UbygnSVRFUicpO1xuICAgICAgICBidWlsZGVyLmR1cChSZWdpc3Rlci5mcCwgMSk7XG4gICAgICAgIGJ1aWxkZXIuZW50ZXJMaXN0KCdCT0RZJyk7XG4gICAgICAgIGJ1aWxkZXIubGFiZWwoJ0lURVInKTtcbiAgICAgICAgYnVpbGRlci5pdGVyYXRlKCdCUkVBSycpO1xuICAgICAgICBidWlsZGVyLmxhYmVsKCdCT0RZJyk7XG4gICAgICAgIGJ1aWxkZXIuaW52b2tlU3RhdGljKHVud3JhcCh0ZW1wbGF0ZSksIDIpO1xuICAgICAgICBidWlsZGVyLnBvcCgyKTtcbiAgICAgICAgYnVpbGRlci5leGl0KCk7XG4gICAgICAgIGJ1aWxkZXIucmV0dXJuKCk7XG4gICAgICAgIGJ1aWxkZXIubGFiZWwoJ0JSRUFLJyk7XG4gICAgICAgIGJ1aWxkZXIuZXhpdExpc3QoKTtcbiAgICAgICAgYnVpbGRlci5wb3BGcmFtZSgpO1xuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgYnVpbGRlci5qdW1wKCdFWElUJyk7XG4gICAgICAgICAgICBidWlsZGVyLmxhYmVsKCdFTFNFJyk7XG4gICAgICAgICAgICBidWlsZGVyLmludm9rZVN0YXRpYyhpbnZlcnNlKTtcbiAgICAgICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VYSVQnKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuZXhpdCgpO1xuICAgICAgICAgICAgYnVpbGRlci5yZXR1cm4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VMU0UnKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuZXhpdCgpO1xuICAgICAgICAgICAgYnVpbGRlci5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLmxhYmVsKCdFTkQnKTtcbiAgICAgICAgYnVpbGRlci5wb3BGcmFtZSgpO1xuICAgICAgICBidWlsZGVyLnN0b3BMYWJlbHMoKTtcbiAgICB9KTtcbiAgICBibG9ja3MuYWRkKCctaW4tZWxlbWVudCcsIChwYXJhbXMsIGhhc2gsIHRlbXBsYXRlLCBfaW52ZXJzZSwgYnVpbGRlcikgPT4ge1xuICAgICAgICBpZiAoIXBhcmFtcyB8fCBwYXJhbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNZTlRBWCBFUlJPUjogIy1pbi1lbGVtZW50IHJlcXVpcmVzIGEgc2luZ2xlIGFyZ3VtZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRlci5zdGFydExhYmVscygpO1xuICAgICAgICBidWlsZGVyLnB1c2hGcmFtZSgpO1xuICAgICAgICBidWlsZGVyLnJldHVyblRvKCdFTkQnKTtcbiAgICAgICAgaWYgKGhhc2ggJiYgaGFzaFswXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBba2V5cywgdmFsdWVzXSA9IGhhc2g7XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEgJiYga2V5c1swXSA9PT0gJ25leHRTaWJsaW5nJykge1xuICAgICAgICAgICAgICAgIGV4cHIodmFsdWVzWzBdLCBidWlsZGVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTWU5UQVggRVJST1I6ICMtaW4tZWxlbWVudCBkb2VzIG5vdCB0YWtlIGEgXFxgJHtrZXlzWzBdfVxcYCBvcHRpb25gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cHIobnVsbCwgYnVpbGRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZXhwcihwYXJhbXNbMF0sIGJ1aWxkZXIpO1xuICAgICAgICBidWlsZGVyLmR1cCgpO1xuICAgICAgICBidWlsZGVyLnRlc3QoJ3NpbXBsZScpO1xuICAgICAgICBidWlsZGVyLmVudGVyKDMpO1xuICAgICAgICBidWlsZGVyLmp1bXBVbmxlc3MoJ0VMU0UnKTtcbiAgICAgICAgYnVpbGRlci5wdXNoUmVtb3RlRWxlbWVudCgpO1xuICAgICAgICBidWlsZGVyLmludm9rZVN0YXRpYyh1bndyYXAodGVtcGxhdGUpKTtcbiAgICAgICAgYnVpbGRlci5wb3BSZW1vdGVFbGVtZW50KCk7XG4gICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VMU0UnKTtcbiAgICAgICAgYnVpbGRlci5leGl0KCk7XG4gICAgICAgIGJ1aWxkZXIucmV0dXJuKCk7XG4gICAgICAgIGJ1aWxkZXIubGFiZWwoJ0VORCcpO1xuICAgICAgICBidWlsZGVyLnBvcEZyYW1lKCk7XG4gICAgICAgIGJ1aWxkZXIuc3RvcExhYmVscygpO1xuICAgIH0pO1xuICAgIGJsb2Nrcy5hZGQoJy13aXRoLWR5bmFtaWMtdmFycycsIChfcGFyYW1zLCBoYXNoLCB0ZW1wbGF0ZSwgX2ludmVyc2UsIGJ1aWxkZXIpID0+IHtcbiAgICAgICAgaWYgKGhhc2gpIHtcbiAgICAgICAgICAgIGxldCBbbmFtZXMsIGV4cHJlc3Npb25zXSA9IGhhc2g7XG4gICAgICAgICAgICBjb21waWxlTGlzdChleHByZXNzaW9ucywgYnVpbGRlcik7XG4gICAgICAgICAgICBidWlsZGVyLnB1c2hEeW5hbWljU2NvcGUoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYmluZER5bmFtaWNTY29wZShuYW1lcyk7XG4gICAgICAgICAgICBidWlsZGVyLmludm9rZVN0YXRpYyh1bndyYXAodGVtcGxhdGUpKTtcbiAgICAgICAgICAgIGJ1aWxkZXIucG9wRHluYW1pY1Njb3BlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWlsZGVyLmludm9rZVN0YXRpYyh1bndyYXAodGVtcGxhdGUpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IGJsb2NrcywgaW5saW5lcyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVTdGF0ZW1lbnQoc3RhdGVtZW50LCBidWlsZGVyKSB7XG4gICAgU1RBVEVNRU5UUy5jb21waWxlKHN0YXRlbWVudCwgYnVpbGRlcik7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVN0YXRlbWVudHMoc3RhdGVtZW50cywgbWV0YSwgZW52KSB7XG4gICAgbGV0IGIgPSBuZXcgT3Bjb2RlQnVpbGRlcihlbnYsIG1ldGEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb21waWxlU3RhdGVtZW50KHN0YXRlbWVudHNbaV0sIGIpO1xuICAgIH1cbiAgICByZXR1cm4gYjtcbn0iXX0=