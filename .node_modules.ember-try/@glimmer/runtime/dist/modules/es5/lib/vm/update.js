function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { clear, move as moveBounds } from '../bounds';
import { ElementStack } from '../builder';
import { Stack, LinkedList, dict } from '@glimmer/util';
import { IteratorSynchronizer,
// Tags
combine, UpdatableTag, combineSlice, CONSTANT_TAG, INITIAL } from '@glimmer/reference';
import { UpdatingOpcode } from '../opcodes';
import VM, { EvaluationStack } from './append';

var UpdatingVM = function () {
    function UpdatingVM(env, _ref) {
        var _ref$alwaysRevalidate = _ref.alwaysRevalidate,
            alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;

        _classCallCheck(this, UpdatingVM);

        this.frameStack = new Stack();
        this.env = env;
        this.constants = env.program.constants;
        this.dom = env.getDOM();
        this.alwaysRevalidate = alwaysRevalidate;
    }

    UpdatingVM.prototype.execute = function execute(opcodes, handler) {
        var frameStack = this.frameStack;

        this.try(opcodes, handler);
        while (true) {
            if (frameStack.isEmpty()) break;
            var opcode = this.frame.nextStatement();
            if (opcode === null) {
                this.frameStack.pop();
                continue;
            }
            opcode.evaluate(this);
        }
    };

    UpdatingVM.prototype.goto = function goto(op) {
        this.frame.goto(op);
    };

    UpdatingVM.prototype.try = function _try(ops, handler) {
        this.frameStack.push(new UpdatingVMFrame(this, ops, handler));
    };

    UpdatingVM.prototype.throw = function _throw() {
        this.frame.handleException();
        this.frameStack.pop();
    };

    UpdatingVM.prototype.evaluateOpcode = function evaluateOpcode(opcode) {
        opcode.evaluate(this);
    };

    _createClass(UpdatingVM, [{
        key: 'frame',
        get: function () {
            return this.frameStack.current;
        }
    }]);

    return UpdatingVM;
}();

export default UpdatingVM;

export var BlockOpcode = function (_UpdatingOpcode) {
    _inherits(BlockOpcode, _UpdatingOpcode);

    function BlockOpcode(start, state, bounds, children) {
        _classCallCheck(this, BlockOpcode);

        var _this = _possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.start = start;
        _this.type = "block";
        _this.next = null;
        _this.prev = null;
        var env = state.env,
            scope = state.scope,
            dynamicScope = state.dynamicScope,
            stack = state.stack;

        _this.children = children;
        _this.env = env;
        _this.scope = scope;
        _this.dynamicScope = dynamicScope;
        _this.stack = stack;
        _this.bounds = bounds;
        return _this;
    }

    BlockOpcode.prototype.parentElement = function parentElement() {
        return this.bounds.parentElement();
    };

    BlockOpcode.prototype.firstNode = function firstNode() {
        return this.bounds.firstNode();
    };

    BlockOpcode.prototype.lastNode = function lastNode() {
        return this.bounds.lastNode();
    };

    BlockOpcode.prototype.evaluate = function evaluate(vm) {
        vm.try(this.children, null);
    };

    BlockOpcode.prototype.destroy = function destroy() {
        this.bounds.destroy();
    };

    BlockOpcode.prototype.didDestroy = function didDestroy() {
        this.env.didDestroy(this.bounds);
    };

    BlockOpcode.prototype.toJSON = function toJSON() {
        var details = dict();
        details["guid"] = '' + this._guid;
        return {
            guid: this._guid,
            type: this.type,
            details: details,
            children: this.children.toArray().map(function (op) {
                return op.toJSON();
            })
        };
    };

    return BlockOpcode;
}(UpdatingOpcode);
export var TryOpcode = function (_BlockOpcode) {
    _inherits(TryOpcode, _BlockOpcode);

    function TryOpcode(start, state, bounds, children) {
        _classCallCheck(this, TryOpcode);

        var _this2 = _possibleConstructorReturn(this, _BlockOpcode.call(this, start, state, bounds, children));

        _this2.type = "try";
        _this2.tag = _this2._tag = UpdatableTag.create(CONSTANT_TAG);
        return _this2;
    }

    TryOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
        this._tag.inner.update(combineSlice(this.children));
    };

    TryOpcode.prototype.evaluate = function evaluate(vm) {
        vm.try(this.children, this);
    };

    TryOpcode.prototype.handleException = function handleException() {
        var _this3 = this;

        var env = this.env,
            bounds = this.bounds,
            children = this.children,
            scope = this.scope,
            dynamicScope = this.dynamicScope,
            start = this.start,
            stack = this.stack,
            prev = this.prev,
            next = this.next;

        children.clear();
        var elementStack = ElementStack.resume(env, bounds, bounds.reset(env));
        var vm = new VM(env, scope, dynamicScope, elementStack);
        var updating = new LinkedList();
        vm.execute(start, function (vm) {
            vm.stack = EvaluationStack.restore(stack);
            vm.updatingOpcodeStack.push(updating);
            vm.updateWith(_this3);
            vm.updatingOpcodeStack.push(children);
        });
        this.prev = prev;
        this.next = next;
    };

    TryOpcode.prototype.toJSON = function toJSON() {
        var json = _BlockOpcode.prototype.toJSON.call(this);
        var details = json["details"];
        if (!details) {
            details = json["details"] = {};
        }
        return _BlockOpcode.prototype.toJSON.call(this);
    };

    return TryOpcode;
}(BlockOpcode);

var ListRevalidationDelegate = function () {
    function ListRevalidationDelegate(opcode, marker) {
        _classCallCheck(this, ListRevalidationDelegate);

        this.opcode = opcode;
        this.marker = marker;
        this.didInsert = false;
        this.didDelete = false;
        this.map = opcode.map;
        this.updating = opcode['children'];
    }

    ListRevalidationDelegate.prototype.insert = function insert(key, item, memo, before) {
        var map = this.map,
            opcode = this.opcode,
            updating = this.updating;

        var nextSibling = null;
        var reference = null;
        if (before) {
            reference = map[before];
            nextSibling = reference['bounds'].firstNode();
        } else {
            nextSibling = this.marker;
        }
        var vm = opcode.vmForInsertion(nextSibling);
        var tryOpcode = null;
        var start = opcode.start;

        vm.execute(start, function (vm) {
            map[key] = tryOpcode = vm.iterate(memo, item);
            vm.updatingOpcodeStack.push(new LinkedList());
            vm.updateWith(tryOpcode);
            vm.updatingOpcodeStack.push(tryOpcode.children);
        });
        updating.insertBefore(tryOpcode, reference);
        this.didInsert = true;
    };

    ListRevalidationDelegate.prototype.retain = function retain(_key, _item, _memo) {};

    ListRevalidationDelegate.prototype.move = function move(key, _item, _memo, before) {
        var map = this.map,
            updating = this.updating;

        var entry = map[key];
        var reference = map[before] || null;
        if (before) {
            moveBounds(entry, reference.firstNode());
        } else {
            moveBounds(entry, this.marker);
        }
        updating.remove(entry);
        updating.insertBefore(entry, reference);
    };

    ListRevalidationDelegate.prototype.delete = function _delete(key) {
        var map = this.map;

        var opcode = map[key];
        opcode.didDestroy();
        clear(opcode);
        this.updating.remove(opcode);
        delete map[key];
        this.didDelete = true;
    };

    ListRevalidationDelegate.prototype.done = function done() {
        this.opcode.didInitializeChildren(this.didInsert || this.didDelete);
    };

    return ListRevalidationDelegate;
}();

export var ListBlockOpcode = function (_BlockOpcode2) {
    _inherits(ListBlockOpcode, _BlockOpcode2);

    function ListBlockOpcode(start, state, bounds, children, artifacts) {
        _classCallCheck(this, ListBlockOpcode);

        var _this4 = _possibleConstructorReturn(this, _BlockOpcode2.call(this, start, state, bounds, children));

        _this4.type = "list-block";
        _this4.map = dict();
        _this4.lastIterated = INITIAL;
        _this4.artifacts = artifacts;
        var _tag = _this4._tag = UpdatableTag.create(CONSTANT_TAG);
        _this4.tag = combine([artifacts.tag, _tag]);
        return _this4;
    }

    ListBlockOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
        var listDidChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        this.lastIterated = this.artifacts.tag.value();
        if (listDidChange) {
            this._tag.inner.update(combineSlice(this.children));
        }
    };

    ListBlockOpcode.prototype.evaluate = function evaluate(vm) {
        var artifacts = this.artifacts,
            lastIterated = this.lastIterated;

        if (!artifacts.tag.validate(lastIterated)) {
            var bounds = this.bounds;
            var dom = vm.dom;

            var marker = dom.createComment('');
            dom.insertAfter(bounds.parentElement(), marker, bounds.lastNode());
            var target = new ListRevalidationDelegate(this, marker);
            var synchronizer = new IteratorSynchronizer({ target: target, artifacts: artifacts });
            synchronizer.sync();
            this.parentElement().removeChild(marker);
        }
        // Run now-updated updating opcodes
        _BlockOpcode2.prototype.evaluate.call(this, vm);
    };

    ListBlockOpcode.prototype.vmForInsertion = function vmForInsertion(nextSibling) {
        var env = this.env,
            scope = this.scope,
            dynamicScope = this.dynamicScope;

        var elementStack = ElementStack.forInitialRender(this.env, this.bounds.parentElement(), nextSibling);
        return new VM(env, scope, dynamicScope, elementStack);
    };

    ListBlockOpcode.prototype.toJSON = function toJSON() {
        var json = _BlockOpcode2.prototype.toJSON.call(this);
        var map = this.map;
        var inner = Object.keys(map).map(function (key) {
            return JSON.stringify(key) + ': ' + map[key]._guid;
        }).join(", ");
        var details = json["details"];
        if (!details) {
            details = json["details"] = {};
        }
        details["map"] = '{' + inner + '}';
        return json;
    };

    return ListBlockOpcode;
}(BlockOpcode);

var UpdatingVMFrame = function () {
    function UpdatingVMFrame(vm, ops, exceptionHandler) {
        _classCallCheck(this, UpdatingVMFrame);

        this.vm = vm;
        this.ops = ops;
        this.exceptionHandler = exceptionHandler;
        this.vm = vm;
        this.ops = ops;
        this.current = ops.head();
    }

    UpdatingVMFrame.prototype.goto = function goto(op) {
        this.current = op;
    };

    UpdatingVMFrame.prototype.nextStatement = function nextStatement() {
        var current = this.current,
            ops = this.ops;

        if (current) this.current = ops.nextNode(current);
        return current;
    };

    UpdatingVMFrame.prototype.handleException = function handleException() {
        if (this.exceptionHandler) {
            this.exceptionHandler.handleException();
        }
    };

    return UpdatingVMFrame;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi92bS91cGRhdGUuanMiXSwibmFtZXMiOlsiY2xlYXIiLCJtb3ZlIiwibW92ZUJvdW5kcyIsIkVsZW1lbnRTdGFjayIsIlN0YWNrIiwiTGlua2VkTGlzdCIsImRpY3QiLCJJdGVyYXRvclN5bmNocm9uaXplciIsImNvbWJpbmUiLCJVcGRhdGFibGVUYWciLCJjb21iaW5lU2xpY2UiLCJDT05TVEFOVF9UQUciLCJJTklUSUFMIiwiVXBkYXRpbmdPcGNvZGUiLCJWTSIsIkV2YWx1YXRpb25TdGFjayIsIlVwZGF0aW5nVk0iLCJlbnYiLCJhbHdheXNSZXZhbGlkYXRlIiwiZnJhbWVTdGFjayIsImNvbnN0YW50cyIsInByb2dyYW0iLCJkb20iLCJnZXRET00iLCJleGVjdXRlIiwib3Bjb2RlcyIsImhhbmRsZXIiLCJ0cnkiLCJpc0VtcHR5Iiwib3Bjb2RlIiwiZnJhbWUiLCJuZXh0U3RhdGVtZW50IiwicG9wIiwiZXZhbHVhdGUiLCJnb3RvIiwib3AiLCJvcHMiLCJwdXNoIiwiVXBkYXRpbmdWTUZyYW1lIiwidGhyb3ciLCJoYW5kbGVFeGNlcHRpb24iLCJldmFsdWF0ZU9wY29kZSIsImN1cnJlbnQiLCJCbG9ja09wY29kZSIsInN0YXJ0Iiwic3RhdGUiLCJib3VuZHMiLCJjaGlsZHJlbiIsInR5cGUiLCJuZXh0IiwicHJldiIsInNjb3BlIiwiZHluYW1pY1Njb3BlIiwic3RhY2siLCJwYXJlbnRFbGVtZW50IiwiZmlyc3ROb2RlIiwibGFzdE5vZGUiLCJ2bSIsImRlc3Ryb3kiLCJkaWREZXN0cm95IiwidG9KU09OIiwiZGV0YWlscyIsIl9ndWlkIiwiZ3VpZCIsInRvQXJyYXkiLCJtYXAiLCJUcnlPcGNvZGUiLCJ0YWciLCJfdGFnIiwiY3JlYXRlIiwiZGlkSW5pdGlhbGl6ZUNoaWxkcmVuIiwiaW5uZXIiLCJ1cGRhdGUiLCJlbGVtZW50U3RhY2siLCJyZXN1bWUiLCJyZXNldCIsInVwZGF0aW5nIiwicmVzdG9yZSIsInVwZGF0aW5nT3Bjb2RlU3RhY2siLCJ1cGRhdGVXaXRoIiwianNvbiIsIkxpc3RSZXZhbGlkYXRpb25EZWxlZ2F0ZSIsIm1hcmtlciIsImRpZEluc2VydCIsImRpZERlbGV0ZSIsImluc2VydCIsImtleSIsIml0ZW0iLCJtZW1vIiwiYmVmb3JlIiwibmV4dFNpYmxpbmciLCJyZWZlcmVuY2UiLCJ2bUZvckluc2VydGlvbiIsInRyeU9wY29kZSIsIml0ZXJhdGUiLCJpbnNlcnRCZWZvcmUiLCJyZXRhaW4iLCJfa2V5IiwiX2l0ZW0iLCJfbWVtbyIsImVudHJ5IiwicmVtb3ZlIiwiZGVsZXRlIiwiZG9uZSIsIkxpc3RCbG9ja09wY29kZSIsImFydGlmYWN0cyIsImxhc3RJdGVyYXRlZCIsImxpc3REaWRDaGFuZ2UiLCJ2YWx1ZSIsInZhbGlkYXRlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEFmdGVyIiwidGFyZ2V0Iiwic3luY2hyb25pemVyIiwic3luYyIsInJlbW92ZUNoaWxkIiwiZm9ySW5pdGlhbFJlbmRlciIsIk9iamVjdCIsImtleXMiLCJKU09OIiwic3RyaW5naWZ5Iiwiam9pbiIsImV4Y2VwdGlvbkhhbmRsZXIiLCJoZWFkIiwibmV4dE5vZGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxLQUFULEVBQWdCQyxRQUFRQyxVQUF4QixRQUEwQyxXQUExQztBQUNBLFNBQVNDLFlBQVQsUUFBNkIsWUFBN0I7QUFDQSxTQUFTQyxLQUFULEVBQWdCQyxVQUFoQixFQUE0QkMsSUFBNUIsUUFBZ0QsZUFBaEQ7QUFDQSxTQUFTQyxvQkFBVDtBQUNBO0FBQ0FDLE9BRkEsRUFFU0MsWUFGVCxFQUV1QkMsWUFGdkIsRUFFcUNDLFlBRnJDLEVBRW1EQyxPQUZuRCxRQUVrRSxvQkFGbEU7QUFHQSxTQUFTQyxjQUFULFFBQStCLFlBQS9CO0FBQ0EsT0FBT0MsRUFBUCxJQUFhQyxlQUFiLFFBQW9DLFVBQXBDOztJQUNxQkMsVTtBQUNqQix3QkFBWUMsR0FBWixRQUErQztBQUFBLHlDQUE1QkMsZ0JBQTRCO0FBQUEsWUFBNUJBLGdC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LGdCQUF4QjtBQUNBLGFBQUtqRSxFQUFMLEdBQVVBLEVBQVY7QUFDQSxhQUFLckIsR0FBTCxHQUFXQSxHQUFYO0FBQ0EsYUFBS00sT0FBTCxHQUFlTixJQUFJdUYsSUFBSixFQUFmO0FBQ0g7OzhCQUNEekYsSSxpQkFBS0MsRSxFQUFJO0FBQ0wsYUFBS08sT0FBTCxHQUFlUCxFQUFmO0FBQ0gsSzs7OEJBQ0RKLGEsNEJBQWdCO0FBQUEsWUFDTlcsT0FETSxHQUNXLElBRFgsQ0FDTkEsT0FETTtBQUFBLFlBQ0dOLEdBREgsR0FDVyxJQURYLENBQ0dBLEdBREg7O0FBRVosWUFBSU0sT0FBSixFQUFhLEtBQUtBLE9BQUwsR0FBZU4sSUFBSXdGLFFBQUosQ0FBYWxGLE9BQWIsQ0FBZjtBQUNiLGVBQU9BLE9BQVA7QUFDSCxLOzs4QkFDREYsZSw4QkFBa0I7QUFDZCxZQUFJLEtBQUtrRixnQkFBVCxFQUEyQjtBQUN2QixpQkFBS0EsZ0JBQUwsQ0FBc0JsRixlQUF0QjtBQUNIO0FBQ0osSyIsImZpbGUiOiJsaWIvdm0vdXBkYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xlYXIsIG1vdmUgYXMgbW92ZUJvdW5kcyB9IGZyb20gJy4uL2JvdW5kcyc7XG5pbXBvcnQgeyBFbGVtZW50U3RhY2sgfSBmcm9tICcuLi9idWlsZGVyJztcbmltcG9ydCB7IFN0YWNrLCBMaW5rZWRMaXN0LCBkaWN0LCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IEl0ZXJhdG9yU3luY2hyb25pemVyLFxuLy8gVGFnc1xuY29tYmluZSwgVXBkYXRhYmxlVGFnLCBjb21iaW5lU2xpY2UsIENPTlNUQU5UX1RBRywgSU5JVElBTCB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBVcGRhdGluZ09wY29kZSB9IGZyb20gJy4uL29wY29kZXMnO1xuaW1wb3J0IFZNLCB7IEV2YWx1YXRpb25TdGFjayB9IGZyb20gJy4vYXBwZW5kJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwZGF0aW5nVk0ge1xuICAgIGNvbnN0cnVjdG9yKGVudiwgeyBhbHdheXNSZXZhbGlkYXRlID0gZmFsc2UgfSkge1xuICAgICAgICB0aGlzLmZyYW1lU3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgICAgIHRoaXMuY29uc3RhbnRzID0gZW52LnByb2dyYW0uY29uc3RhbnRzO1xuICAgICAgICB0aGlzLmRvbSA9IGVudi5nZXRET00oKTtcbiAgICAgICAgdGhpcy5hbHdheXNSZXZhbGlkYXRlID0gYWx3YXlzUmV2YWxpZGF0ZTtcbiAgICB9XG4gICAgZXhlY3V0ZShvcGNvZGVzLCBoYW5kbGVyKSB7XG4gICAgICAgIGxldCB7IGZyYW1lU3RhY2sgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMudHJ5KG9wY29kZXMsIGhhbmRsZXIpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGZyYW1lU3RhY2suaXNFbXB0eSgpKSBicmVhaztcbiAgICAgICAgICAgIGxldCBvcGNvZGUgPSB0aGlzLmZyYW1lLm5leHRTdGF0ZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChvcGNvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGNvZGUuZXZhbHVhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZyYW1lKCkge1xuICAgICAgICByZXR1cm4gZXhwZWN0KHRoaXMuZnJhbWVTdGFjay5jdXJyZW50LCAnYnVnOiBleHBlY3RlZCBhIGZyYW1lJyk7XG4gICAgfVxuICAgIGdvdG8ob3ApIHtcbiAgICAgICAgdGhpcy5mcmFtZS5nb3RvKG9wKTtcbiAgICB9XG4gICAgdHJ5KG9wcywgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmZyYW1lU3RhY2sucHVzaChuZXcgVXBkYXRpbmdWTUZyYW1lKHRoaXMsIG9wcywgaGFuZGxlcikpO1xuICAgIH1cbiAgICB0aHJvdygpIHtcbiAgICAgICAgdGhpcy5mcmFtZS5oYW5kbGVFeGNlcHRpb24oKTtcbiAgICAgICAgdGhpcy5mcmFtZVN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICBldmFsdWF0ZU9wY29kZShvcGNvZGUpIHtcbiAgICAgICAgb3Bjb2RlLmV2YWx1YXRlKHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCbG9ja09wY29kZSBleHRlbmRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgc3RhdGUsIGJvdW5kcywgY2hpbGRyZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLnR5cGUgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgICAgIGxldCB7IGVudiwgc2NvcGUsIGR5bmFtaWNTY29wZSwgc3RhY2sgfSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZW52ID0gZW52O1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIHRoaXMuZHluYW1pY1Njb3BlID0gZHluYW1pY1Njb3BlO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMuYm91bmRzID0gYm91bmRzO1xuICAgIH1cbiAgICBwYXJlbnRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICAgIH1cbiAgICBmaXJzdE5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kcy5maXJzdE5vZGUoKTtcbiAgICB9XG4gICAgbGFzdE5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kcy5sYXN0Tm9kZSgpO1xuICAgIH1cbiAgICBldmFsdWF0ZSh2bSkge1xuICAgICAgICB2bS50cnkodGhpcy5jaGlsZHJlbiwgbnVsbCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYm91bmRzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlkRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbnYuZGlkRGVzdHJveSh0aGlzLmJvdW5kcyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGRldGFpbHMgPSBkaWN0KCk7XG4gICAgICAgIGRldGFpbHNbXCJndWlkXCJdID0gYCR7dGhpcy5fZ3VpZH1gO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3VpZDogdGhpcy5fZ3VpZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIGRldGFpbHMsXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlbi50b0FycmF5KCkubWFwKG9wID0+IG9wLnRvSlNPTigpKVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUcnlPcGNvZGUgZXh0ZW5kcyBCbG9ja09wY29kZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIHN0YXRlLCBib3VuZHMsIGNoaWxkcmVuKSB7XG4gICAgICAgIHN1cGVyKHN0YXJ0LCBzdGF0ZSwgYm91bmRzLCBjaGlsZHJlbik7XG4gICAgICAgIHRoaXMudHlwZSA9IFwidHJ5XCI7XG4gICAgICAgIHRoaXMudGFnID0gdGhpcy5fdGFnID0gVXBkYXRhYmxlVGFnLmNyZWF0ZShDT05TVEFOVF9UQUcpO1xuICAgIH1cbiAgICBkaWRJbml0aWFsaXplQ2hpbGRyZW4oKSB7XG4gICAgICAgIHRoaXMuX3RhZy5pbm5lci51cGRhdGUoY29tYmluZVNsaWNlKHRoaXMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgZXZhbHVhdGUodm0pIHtcbiAgICAgICAgdm0udHJ5KHRoaXMuY2hpbGRyZW4sIHRoaXMpO1xuICAgIH1cbiAgICBoYW5kbGVFeGNlcHRpb24oKSB7XG4gICAgICAgIGxldCB7IGVudiwgYm91bmRzLCBjaGlsZHJlbiwgc2NvcGUsIGR5bmFtaWNTY29wZSwgc3RhcnQsIHN0YWNrLCBwcmV2LCBuZXh0IH0gPSB0aGlzO1xuICAgICAgICBjaGlsZHJlbi5jbGVhcigpO1xuICAgICAgICBsZXQgZWxlbWVudFN0YWNrID0gRWxlbWVudFN0YWNrLnJlc3VtZShlbnYsIGJvdW5kcywgYm91bmRzLnJlc2V0KGVudikpO1xuICAgICAgICBsZXQgdm0gPSBuZXcgVk0oZW52LCBzY29wZSwgZHluYW1pY1Njb3BlLCBlbGVtZW50U3RhY2spO1xuICAgICAgICBsZXQgdXBkYXRpbmcgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgICAgICB2bS5leGVjdXRlKHN0YXJ0LCB2bSA9PiB7XG4gICAgICAgICAgICB2bS5zdGFjayA9IEV2YWx1YXRpb25TdGFjay5yZXN0b3JlKHN0YWNrKTtcbiAgICAgICAgICAgIHZtLnVwZGF0aW5nT3Bjb2RlU3RhY2sucHVzaCh1cGRhdGluZyk7XG4gICAgICAgICAgICB2bS51cGRhdGVXaXRoKHRoaXMpO1xuICAgICAgICAgICAgdm0udXBkYXRpbmdPcGNvZGVTdGFjay5wdXNoKGNoaWxkcmVuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSBzdXBlci50b0pTT04oKTtcbiAgICAgICAgbGV0IGRldGFpbHMgPSBqc29uW1wiZGV0YWlsc1wiXTtcbiAgICAgICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICAgICAgICBkZXRhaWxzID0ganNvbltcImRldGFpbHNcIl0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKCk7XG4gICAgfVxufVxuY2xhc3MgTGlzdFJldmFsaWRhdGlvbkRlbGVnYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihvcGNvZGUsIG1hcmtlcikge1xuICAgICAgICB0aGlzLm9wY29kZSA9IG9wY29kZTtcbiAgICAgICAgdGhpcy5tYXJrZXIgPSBtYXJrZXI7XG4gICAgICAgIHRoaXMuZGlkSW5zZXJ0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlkRGVsZXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWFwID0gb3Bjb2RlLm1hcDtcbiAgICAgICAgdGhpcy51cGRhdGluZyA9IG9wY29kZVsnY2hpbGRyZW4nXTtcbiAgICB9XG4gICAgaW5zZXJ0KGtleSwgaXRlbSwgbWVtbywgYmVmb3JlKSB7XG4gICAgICAgIGxldCB7IG1hcCwgb3Bjb2RlLCB1cGRhdGluZyB9ID0gdGhpcztcbiAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gbnVsbDtcbiAgICAgICAgbGV0IHJlZmVyZW5jZSA9IG51bGw7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IG1hcFtiZWZvcmVdO1xuICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSByZWZlcmVuY2VbJ2JvdW5kcyddLmZpcnN0Tm9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSB0aGlzLm1hcmtlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdm0gPSBvcGNvZGUudm1Gb3JJbnNlcnRpb24obmV4dFNpYmxpbmcpO1xuICAgICAgICBsZXQgdHJ5T3Bjb2RlID0gbnVsbDtcbiAgICAgICAgbGV0IHsgc3RhcnQgfSA9IG9wY29kZTtcbiAgICAgICAgdm0uZXhlY3V0ZShzdGFydCwgdm0gPT4ge1xuICAgICAgICAgICAgbWFwW2tleV0gPSB0cnlPcGNvZGUgPSB2bS5pdGVyYXRlKG1lbW8sIGl0ZW0pO1xuICAgICAgICAgICAgdm0udXBkYXRpbmdPcGNvZGVTdGFjay5wdXNoKG5ldyBMaW5rZWRMaXN0KCkpO1xuICAgICAgICAgICAgdm0udXBkYXRlV2l0aCh0cnlPcGNvZGUpO1xuICAgICAgICAgICAgdm0udXBkYXRpbmdPcGNvZGVTdGFjay5wdXNoKHRyeU9wY29kZS5jaGlsZHJlbik7XG4gICAgICAgIH0pO1xuICAgICAgICB1cGRhdGluZy5pbnNlcnRCZWZvcmUodHJ5T3Bjb2RlLCByZWZlcmVuY2UpO1xuICAgICAgICB0aGlzLmRpZEluc2VydCA9IHRydWU7XG4gICAgfVxuICAgIHJldGFpbihfa2V5LCBfaXRlbSwgX21lbW8pIHt9XG4gICAgbW92ZShrZXksIF9pdGVtLCBfbWVtbywgYmVmb3JlKSB7XG4gICAgICAgIGxldCB7IG1hcCwgdXBkYXRpbmcgfSA9IHRoaXM7XG4gICAgICAgIGxldCBlbnRyeSA9IG1hcFtrZXldO1xuICAgICAgICBsZXQgcmVmZXJlbmNlID0gbWFwW2JlZm9yZV0gfHwgbnVsbDtcbiAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgbW92ZUJvdW5kcyhlbnRyeSwgcmVmZXJlbmNlLmZpcnN0Tm9kZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVCb3VuZHMoZW50cnksIHRoaXMubWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGluZy5yZW1vdmUoZW50cnkpO1xuICAgICAgICB1cGRhdGluZy5pbnNlcnRCZWZvcmUoZW50cnksIHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgbGV0IHsgbWFwIH0gPSB0aGlzO1xuICAgICAgICBsZXQgb3Bjb2RlID0gbWFwW2tleV07XG4gICAgICAgIG9wY29kZS5kaWREZXN0cm95KCk7XG4gICAgICAgIGNsZWFyKG9wY29kZSk7XG4gICAgICAgIHRoaXMudXBkYXRpbmcucmVtb3ZlKG9wY29kZSk7XG4gICAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICAgICAgdGhpcy5kaWREZWxldGUgPSB0cnVlO1xuICAgIH1cbiAgICBkb25lKCkge1xuICAgICAgICB0aGlzLm9wY29kZS5kaWRJbml0aWFsaXplQ2hpbGRyZW4odGhpcy5kaWRJbnNlcnQgfHwgdGhpcy5kaWREZWxldGUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMaXN0QmxvY2tPcGNvZGUgZXh0ZW5kcyBCbG9ja09wY29kZSB7XG4gICAgY29uc3RydWN0b3Ioc3RhcnQsIHN0YXRlLCBib3VuZHMsIGNoaWxkcmVuLCBhcnRpZmFjdHMpIHtcbiAgICAgICAgc3VwZXIoc3RhcnQsIHN0YXRlLCBib3VuZHMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJsaXN0LWJsb2NrXCI7XG4gICAgICAgIHRoaXMubWFwID0gZGljdCgpO1xuICAgICAgICB0aGlzLmxhc3RJdGVyYXRlZCA9IElOSVRJQUw7XG4gICAgICAgIHRoaXMuYXJ0aWZhY3RzID0gYXJ0aWZhY3RzO1xuICAgICAgICBsZXQgX3RhZyA9IHRoaXMuX3RhZyA9IFVwZGF0YWJsZVRhZy5jcmVhdGUoQ09OU1RBTlRfVEFHKTtcbiAgICAgICAgdGhpcy50YWcgPSBjb21iaW5lKFthcnRpZmFjdHMudGFnLCBfdGFnXSk7XG4gICAgfVxuICAgIGRpZEluaXRpYWxpemVDaGlsZHJlbihsaXN0RGlkQ2hhbmdlID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxhc3RJdGVyYXRlZCA9IHRoaXMuYXJ0aWZhY3RzLnRhZy52YWx1ZSgpO1xuICAgICAgICBpZiAobGlzdERpZENoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5fdGFnLmlubmVyLnVwZGF0ZShjb21iaW5lU2xpY2UodGhpcy5jaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV2YWx1YXRlKHZtKSB7XG4gICAgICAgIGxldCB7IGFydGlmYWN0cywgbGFzdEl0ZXJhdGVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWFydGlmYWN0cy50YWcudmFsaWRhdGUobGFzdEl0ZXJhdGVkKSkge1xuICAgICAgICAgICAgbGV0IHsgYm91bmRzIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgZG9tIH0gPSB2bTtcbiAgICAgICAgICAgIGxldCBtYXJrZXIgPSBkb20uY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICAgICAgICBkb20uaW5zZXJ0QWZ0ZXIoYm91bmRzLnBhcmVudEVsZW1lbnQoKSwgbWFya2VyLCBleHBlY3QoYm91bmRzLmxhc3ROb2RlKCksIFwiY2FuJ3QgaW5zZXJ0IGFmdGVyIGFuIGVtcHR5IGJvdW5kc1wiKSk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gbmV3IExpc3RSZXZhbGlkYXRpb25EZWxlZ2F0ZSh0aGlzLCBtYXJrZXIpO1xuICAgICAgICAgICAgbGV0IHN5bmNocm9uaXplciA9IG5ldyBJdGVyYXRvclN5bmNocm9uaXplcih7IHRhcmdldCwgYXJ0aWZhY3RzIH0pO1xuICAgICAgICAgICAgc3luY2hyb25pemVyLnN5bmMoKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudCgpLnJlbW92ZUNoaWxkKG1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUnVuIG5vdy11cGRhdGVkIHVwZGF0aW5nIG9wY29kZXNcbiAgICAgICAgc3VwZXIuZXZhbHVhdGUodm0pO1xuICAgIH1cbiAgICB2bUZvckluc2VydGlvbihuZXh0U2libGluZykge1xuICAgICAgICBsZXQgeyBlbnYsIHNjb3BlLCBkeW5hbWljU2NvcGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBlbGVtZW50U3RhY2sgPSBFbGVtZW50U3RhY2suZm9ySW5pdGlhbFJlbmRlcih0aGlzLmVudiwgdGhpcy5ib3VuZHMucGFyZW50RWxlbWVudCgpLCBuZXh0U2libGluZyk7XG4gICAgICAgIHJldHVybiBuZXcgVk0oZW52LCBzY29wZSwgZHluYW1pY1Njb3BlLCBlbGVtZW50U3RhY2spO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIGxldCBtYXAgPSB0aGlzLm1hcDtcbiAgICAgICAgbGV0IGlubmVyID0gT2JqZWN0LmtleXMobWFwKS5tYXAoa2V5ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBgJHtKU09OLnN0cmluZ2lmeShrZXkpfTogJHttYXBba2V5XS5fZ3VpZH1gO1xuICAgICAgICB9KS5qb2luKFwiLCBcIik7XG4gICAgICAgIGxldCBkZXRhaWxzID0ganNvbltcImRldGFpbHNcIl07XG4gICAgICAgIGlmICghZGV0YWlscykge1xuICAgICAgICAgICAgZGV0YWlscyA9IGpzb25bXCJkZXRhaWxzXCJdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWlsc1tcIm1hcFwiXSA9IGB7JHtpbm5lcn19YDtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxufVxuY2xhc3MgVXBkYXRpbmdWTUZyYW1lIHtcbiAgICBjb25zdHJ1Y3Rvcih2bSwgb3BzLCBleGNlcHRpb25IYW5kbGVyKSB7XG4gICAgICAgIHRoaXMudm0gPSB2bTtcbiAgICAgICAgdGhpcy5vcHMgPSBvcHM7XG4gICAgICAgIHRoaXMuZXhjZXB0aW9uSGFuZGxlciA9IGV4Y2VwdGlvbkhhbmRsZXI7XG4gICAgICAgIHRoaXMudm0gPSB2bTtcbiAgICAgICAgdGhpcy5vcHMgPSBvcHM7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG9wcy5oZWFkKCk7XG4gICAgfVxuICAgIGdvdG8ob3ApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gb3A7XG4gICAgfVxuICAgIG5leHRTdGF0ZW1lbnQoKSB7XG4gICAgICAgIGxldCB7IGN1cnJlbnQsIG9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKGN1cnJlbnQpIHRoaXMuY3VycmVudCA9IG9wcy5uZXh0Tm9kZShjdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGhhbmRsZUV4Y2VwdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhjZXB0aW9uSGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5leGNlcHRpb25IYW5kbGVyLmhhbmRsZUV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxufSJdfQ==