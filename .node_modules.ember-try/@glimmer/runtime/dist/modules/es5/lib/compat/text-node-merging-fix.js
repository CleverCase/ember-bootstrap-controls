function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

// Patch:    Adjacent text node merging fix
// Browsers: IE, Edge, Firefox w/o inspector open
// Reason:   These browsers will merge adjacent text nodes. For exmaple given
//           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers
//           with proper behavior will populate div.childNodes with two items.
//           These browsers will populate it with one merged node instead.
// Fix:      Add these nodes to a wrapper element, then iterate the childNodes
//           of that wrapper and move the nodes to their target location. Note
//           that potential SVG bugs will have been handled before this fix.
//           Note that this fix must only apply to the previous text node, as
//           the base implementation of `insertHTMLBefore` already handles
//           following text nodes correctly.
export function domChanges(document, DOMChangesClass) {
    if (!document) return DOMChangesClass;
    if (!shouldApplyFix(document)) {
        return DOMChangesClass;
    }
    return function (_DOMChangesClass) {
        _inherits(DOMChangesWithTextNodeMergingFix, _DOMChangesClass);

        function DOMChangesWithTextNodeMergingFix(document) {
            _classCallCheck(this, DOMChangesWithTextNodeMergingFix);

            var _this = _possibleConstructorReturn(this, _DOMChangesClass.call(this, document));

            _this.uselessComment = document.createComment('');
            return _this;
        }

        DOMChangesWithTextNodeMergingFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
            if (html === null) {
                return _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            }
            var didSetUselessComment = false;
            var nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;
            if (nextPrevious && nextPrevious instanceof Text) {
                didSetUselessComment = true;
                parent.insertBefore(this.uselessComment, nextSibling);
            }
            var bounds = _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            if (didSetUselessComment) {
                parent.removeChild(this.uselessComment);
            }
            return bounds;
        };

        return DOMChangesWithTextNodeMergingFix;
    }(DOMChangesClass);
}
export function treeConstruction(document, TreeConstructionClass) {
    if (!document) return TreeConstructionClass;
    if (!shouldApplyFix(document)) {
        return TreeConstructionClass;
    }
    return function (_TreeConstructionClas) {
        _inherits(TreeConstructionWithTextNodeMergingFix, _TreeConstructionClas);

        function TreeConstructionWithTextNodeMergingFix(document) {
            _classCallCheck(this, TreeConstructionWithTextNodeMergingFix);

            var _this2 = _possibleConstructorReturn(this, _TreeConstructionClas.call(this, document));

            _this2.uselessComment = _this2.createComment('');
            return _this2;
        }

        TreeConstructionWithTextNodeMergingFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, reference, html) {
            if (html === null) {
                return _TreeConstructionClas.prototype.insertHTMLBefore.call(this, parent, reference, html);
            }
            var didSetUselessComment = false;
            var nextPrevious = reference ? reference.previousSibling : parent.lastChild;
            if (nextPrevious && nextPrevious instanceof Text) {
                didSetUselessComment = true;
                parent.insertBefore(this.uselessComment, reference);
            }
            var bounds = _TreeConstructionClas.prototype.insertHTMLBefore.call(this, parent, reference, html);
            if (didSetUselessComment) {
                parent.removeChild(this.uselessComment);
            }
            return bounds;
        };

        return TreeConstructionWithTextNodeMergingFix;
    }(TreeConstructionClass);
}
function shouldApplyFix(document) {
    var mergingTextDiv = document.createElement('div');
    mergingTextDiv.innerHTML = 'first';
    mergingTextDiv.insertAdjacentHTML('beforeend', 'second');
    if (mergingTextDiv.childNodes.length === 2) {
        // It worked as expected, no fix required
        return false;
    }
    return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21wYXQvdGV4dC1ub2RlLW1lcmdpbmctZml4LmpzIl0sIm5hbWVzIjpbImRvbUNoYW5nZXMiLCJkb2N1bWVudCIsIkRPTUNoYW5nZXNDbGFzcyIsInNob3VsZEFwcGx5Rml4IiwidXNlbGVzc0NvbW1lbnQiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0SFRNTEJlZm9yZSIsInBhcmVudCIsIm5leHRTaWJsaW5nIiwiaHRtbCIsImRpZFNldFVzZWxlc3NDb21tZW50IiwibmV4dFByZXZpb3VzIiwicHJldmlvdXNTaWJsaW5nIiwibGFzdENoaWxkIiwiVGV4dCIsImluc2VydEJlZm9yZSIsImJvdW5kcyIsInJlbW92ZUNoaWxkIiwidHJlZUNvbnN0cnVjdGlvbiIsIlRyZWVDb25zdHJ1Y3Rpb25DbGFzcyIsInJlZmVyZW5jZSIsIm1lcmdpbmdUZXh0RGl2IiwiY3JlYXRlRWxlbWVudCIsImlubmVySFRNTCIsImluc2VydEFkamFjZW50SFRNTCIsImNoaWxkTm9kZXMiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxTQUFTQSxVQUFULENBQW9CQyxRQUFwQixFQUE4QkMsZUFBOUIsRUFBK0M7QUFDbEQsUUFBSSxDQUFDRCxRQUFMLEVBQWUsT0FBT0MsZUFBUDtBQUNmLFFBQUksQ0FBQ0MsZUFBZUYsUUFBZixDQUFMLEVBQStCO0FBQzNCLGVBQU9DLGVBQVA7QUFDSDtBQUNEO0FBQUE7O0FBQ0ksa0RBQVlELFFBQVosRUFBc0I7QUFBQTs7QUFBQSx5REFDbEIsNEJBQU1BLFFBQU4sQ0FEa0I7O0FBRWxCLGtCQUFLRyxjQUFMLEdBQXNCSCxTQUFTSSxhQUFULENBQXVCLEVBQXZCLENBQXRCO0FBRmtCO0FBR3JCOztBQUpMLG1EQUtJQyxnQkFMSiw2QkFLcUJDLE1BTHJCLEVBSzZCQyxXQUw3QixFQUswQ0MsSUFMMUMsRUFLZ0Q7QUFDeEMsZ0JBQUlBLFNBQVMsSUFBYixFQUFtQjtBQUNmLHVCQUFPLDJCQUFNSCxnQkFBTixZQUF1QkMsTUFBdkIsRUFBK0JDLFdBQS9CLEVBQTRDQyxJQUE1QyxDQUFQO0FBQ0g7QUFDRCxnQkFBSUMsdUJBQXVCLEtBQTNCO0FBQ0EsZ0JBQUlDLGVBQWVILGNBQWNBLFlBQVlJLGVBQTFCLEdBQTRDTCxPQUFPTSxTQUF0RTtBQUNBLGdCQUFJRixnQkFBZ0JBLHdCQUF3QkcsSUFBNUMsRUFBa0Q7QUFDOUNKLHVDQUF1QixJQUF2QjtBQUNBSCx1QkFBT1EsWUFBUCxDQUFvQixLQUFLWCxjQUF6QixFQUF5Q0ksV0FBekM7QUFDSDtBQUNELGdCQUFJUSxTQUFTLDJCQUFNVixnQkFBTixZQUF1QkMsTUFBdkIsRUFBK0JDLFdBQS9CLEVBQTRDQyxJQUE1QyxDQUFiO0FBQ0EsZ0JBQUlDLG9CQUFKLEVBQTBCO0FBQ3RCSCx1QkFBT1UsV0FBUCxDQUFtQixLQUFLYixjQUF4QjtBQUNIO0FBQ0QsbUJBQU9ZLE1BQVA7QUFDSCxTQXBCTDs7QUFBQTtBQUFBLE1BQXNEZCxlQUF0RDtBQXNCSDtBQUNELE9BQU8sU0FBU2dCLGdCQUFULENBQTBCakIsUUFBMUIsRUFBb0NrQixxQkFBcEMsRUFBMkQ7QUFDOUQsUUFBSSxDQUFDbEIsUUFBTCxFQUFlLE9BQU9rQixxQkFBUDtBQUNmLFFBQUksQ0FBQ2hCLGVBQWVGLFFBQWYsQ0FBTCxFQUErQjtBQUMzQixlQUFPa0IscUJBQVA7QUFDSDtBQUNEO0FBQUE7O0FBQ0ksd0RBQVlsQixRQUFaLEVBQXNCO0FBQUE7O0FBQUEsMERBQ2xCLGlDQUFNQSxRQUFOLENBRGtCOztBQUVsQixtQkFBS0csY0FBTCxHQUFzQixPQUFLQyxhQUFMLENBQW1CLEVBQW5CLENBQXRCO0FBRmtCO0FBR3JCOztBQUpMLHlEQUtJQyxnQkFMSiw2QkFLcUJDLE1BTHJCLEVBSzZCYSxTQUw3QixFQUt3Q1gsSUFMeEMsRUFLOEM7QUFDdEMsZ0JBQUlBLFNBQVMsSUFBYixFQUFtQjtBQUNmLHVCQUFPLGdDQUFNSCxnQkFBTixZQUF1QkMsTUFBdkIsRUFBK0JhLFNBQS9CLEVBQTBDWCxJQUExQyxDQUFQO0FBQ0g7QUFDRCxnQkFBSUMsdUJBQXVCLEtBQTNCO0FBQ0EsZ0JBQUlDLGVBQWVTLFlBQVlBLFVBQVVSLGVBQXRCLEdBQXdDTCxPQUFPTSxTQUFsRTtBQUNBLGdCQUFJRixnQkFBZ0JBLHdCQUF3QkcsSUFBNUMsRUFBa0Q7QUFDOUNKLHVDQUF1QixJQUF2QjtBQUNBSCx1QkFBT1EsWUFBUCxDQUFvQixLQUFLWCxjQUF6QixFQUF5Q2dCLFNBQXpDO0FBQ0g7QUFDRCxnQkFBSUosU0FBUyxnQ0FBTVYsZ0JBQU4sWUFBdUJDLE1BQXZCLEVBQStCYSxTQUEvQixFQUEwQ1gsSUFBMUMsQ0FBYjtBQUNBLGdCQUFJQyxvQkFBSixFQUEwQjtBQUN0QkgsdUJBQU9VLFdBQVAsQ0FBbUIsS0FBS2IsY0FBeEI7QUFDSDtBQUNELG1CQUFPWSxNQUFQO0FBQ0gsU0FwQkw7O0FBQUE7QUFBQSxNQUE0REcscUJBQTVEO0FBc0JIO0FBQ0QsU0FBU2hCLGNBQVQsQ0FBd0JGLFFBQXhCLEVBQWtDO0FBQzlCLFFBQUlvQixpQkFBaUJwQixTQUFTcUIsYUFBVCxDQUF1QixLQUF2QixDQUFyQjtBQUNBRCxtQkFBZUUsU0FBZixHQUEyQixPQUEzQjtBQUNBRixtQkFBZUcsa0JBQWYsQ0FBa0MsV0FBbEMsRUFBK0MsUUFBL0M7QUFDQSxRQUFJSCxlQUFlSSxVQUFmLENBQTBCQyxNQUExQixLQUFxQyxDQUF6QyxFQUE0QztBQUN4QztBQUNBLGVBQU8sS0FBUDtBQUNIO0FBQ0QsV0FBTyxJQUFQO0FBQ0giLCJmaWxlIjoibGliL2NvbXBhdC90ZXh0LW5vZGUtbWVyZ2luZy1maXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQYXRjaDogICAgQWRqYWNlbnQgdGV4dCBub2RlIG1lcmdpbmcgZml4XG4vLyBCcm93c2VyczogSUUsIEVkZ2UsIEZpcmVmb3ggdy9vIGluc3BlY3RvciBvcGVuXG4vLyBSZWFzb246ICAgVGhlc2UgYnJvd3NlcnMgd2lsbCBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzLiBGb3IgZXhtYXBsZSBnaXZlblxuLy8gICAgICAgICAgIDxkaXY+SGVsbG88L2Rpdj4gd2l0aCBkaXYuaW5zZXJ0QWRqYWNlbnRIVE1MKCcgd29ybGQnKSBicm93c2Vyc1xuLy8gICAgICAgICAgIHdpdGggcHJvcGVyIGJlaGF2aW9yIHdpbGwgcG9wdWxhdGUgZGl2LmNoaWxkTm9kZXMgd2l0aCB0d28gaXRlbXMuXG4vLyAgICAgICAgICAgVGhlc2UgYnJvd3NlcnMgd2lsbCBwb3B1bGF0ZSBpdCB3aXRoIG9uZSBtZXJnZWQgbm9kZSBpbnN0ZWFkLlxuLy8gRml4OiAgICAgIEFkZCB0aGVzZSBub2RlcyB0byBhIHdyYXBwZXIgZWxlbWVudCwgdGhlbiBpdGVyYXRlIHRoZSBjaGlsZE5vZGVzXG4vLyAgICAgICAgICAgb2YgdGhhdCB3cmFwcGVyIGFuZCBtb3ZlIHRoZSBub2RlcyB0byB0aGVpciB0YXJnZXQgbG9jYXRpb24uIE5vdGVcbi8vICAgICAgICAgICB0aGF0IHBvdGVudGlhbCBTVkcgYnVncyB3aWxsIGhhdmUgYmVlbiBoYW5kbGVkIGJlZm9yZSB0aGlzIGZpeC5cbi8vICAgICAgICAgICBOb3RlIHRoYXQgdGhpcyBmaXggbXVzdCBvbmx5IGFwcGx5IHRvIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGUsIGFzXG4vLyAgICAgICAgICAgdGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGluc2VydEhUTUxCZWZvcmVgIGFscmVhZHkgaGFuZGxlc1xuLy8gICAgICAgICAgIGZvbGxvd2luZyB0ZXh0IG5vZGVzIGNvcnJlY3RseS5cbmV4cG9ydCBmdW5jdGlvbiBkb21DaGFuZ2VzKGRvY3VtZW50LCBET01DaGFuZ2VzQ2xhc3MpIHtcbiAgICBpZiAoIWRvY3VtZW50KSByZXR1cm4gRE9NQ2hhbmdlc0NsYXNzO1xuICAgIGlmICghc2hvdWxkQXBwbHlGaXgoZG9jdW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBET01DaGFuZ2VzQ2xhc3M7XG4gICAgfVxuICAgIHJldHVybiBjbGFzcyBET01DaGFuZ2VzV2l0aFRleHROb2RlTWVyZ2luZ0ZpeCBleHRlbmRzIERPTUNoYW5nZXNDbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50KSB7XG4gICAgICAgICAgICBzdXBlcihkb2N1bWVudCk7XG4gICAgICAgICAgICB0aGlzLnVzZWxlc3NDb21tZW50ID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQsIG5leHRTaWJsaW5nLCBodG1sKSB7XG4gICAgICAgICAgICBpZiAoaHRtbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5pbnNlcnRIVE1MQmVmb3JlKHBhcmVudCwgbmV4dFNpYmxpbmcsIGh0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZFNldFVzZWxlc3NDb21tZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmV4dFByZXZpb3VzID0gbmV4dFNpYmxpbmcgPyBuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKG5leHRQcmV2aW91cyAmJiBuZXh0UHJldmlvdXMgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICAgICAgZGlkU2V0VXNlbGVzc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy51c2VsZXNzQ29tbWVudCwgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGJvdW5kcyA9IHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCk7XG4gICAgICAgICAgICBpZiAoZGlkU2V0VXNlbGVzc0NvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy51c2VsZXNzQ29tbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmVlQ29uc3RydWN0aW9uKGRvY3VtZW50LCBUcmVlQ29uc3RydWN0aW9uQ2xhc3MpIHtcbiAgICBpZiAoIWRvY3VtZW50KSByZXR1cm4gVHJlZUNvbnN0cnVjdGlvbkNsYXNzO1xuICAgIGlmICghc2hvdWxkQXBwbHlGaXgoZG9jdW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBUcmVlQ29uc3RydWN0aW9uQ2xhc3M7XG4gICAgfVxuICAgIHJldHVybiBjbGFzcyBUcmVlQ29uc3RydWN0aW9uV2l0aFRleHROb2RlTWVyZ2luZ0ZpeCBleHRlbmRzIFRyZWVDb25zdHJ1Y3Rpb25DbGFzcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50KSB7XG4gICAgICAgICAgICBzdXBlcihkb2N1bWVudCk7XG4gICAgICAgICAgICB0aGlzLnVzZWxlc3NDb21tZW50ID0gdGhpcy5jcmVhdGVDb21tZW50KCcnKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRIVE1MQmVmb3JlKHBhcmVudCwgcmVmZXJlbmNlLCBodG1sKSB7XG4gICAgICAgICAgICBpZiAoaHRtbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5pbnNlcnRIVE1MQmVmb3JlKHBhcmVudCwgcmVmZXJlbmNlLCBodG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkaWRTZXRVc2VsZXNzQ29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5leHRQcmV2aW91cyA9IHJlZmVyZW5jZSA/IHJlZmVyZW5jZS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgICAgICAgICAgaWYgKG5leHRQcmV2aW91cyAmJiBuZXh0UHJldmlvdXMgaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICAgICAgZGlkU2V0VXNlbGVzc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcy51c2VsZXNzQ29tbWVudCwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBib3VuZHMgPSBzdXBlci5pbnNlcnRIVE1MQmVmb3JlKHBhcmVudCwgcmVmZXJlbmNlLCBodG1sKTtcbiAgICAgICAgICAgIGlmIChkaWRTZXRVc2VsZXNzQ29tbWVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLnVzZWxlc3NDb21tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gc2hvdWxkQXBwbHlGaXgoZG9jdW1lbnQpIHtcbiAgICBsZXQgbWVyZ2luZ1RleHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBtZXJnaW5nVGV4dERpdi5pbm5lckhUTUwgPSAnZmlyc3QnO1xuICAgIG1lcmdpbmdUZXh0RGl2Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgJ3NlY29uZCcpO1xuICAgIGlmIChtZXJnaW5nVGV4dERpdi5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAvLyBJdCB3b3JrZWQgYXMgZXhwZWN0ZWQsIG5vIGZpeCByZXF1aXJlZFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSJdfQ==