function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

import { ConcreteBounds } from '../bounds';
import { moveNodesBefore } from '../dom/helper';

export var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
// Patch:    insertAdjacentHTML on SVG Fix
// Browsers: Safari, IE, Edge, Firefox ~33-34
// Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is
//           present but throws an exception on IE and Edge. Old versions of
//           Firefox create nodes in the incorrect namespace.
// Fix:      Since IE and Edge silently fail to create SVG nodes using
//           innerHTML, and because Firefox may create nodes in the incorrect
//           namespace using innerHTML on SVG elements, an HTML-string wrapping
//           approach is used. A pre/post SVG tag is added to the string, then
//           that whole string is added to a div. The created nodes are plucked
//           out and applied to the target location on DOM.
export function domChanges(document, DOMChangesClass, svgNamespace) {
    if (!document) return DOMChangesClass;
    if (!shouldApplyFix(document, svgNamespace)) {
        return DOMChangesClass;
    }
    var div = document.createElement('div');
    return function (_DOMChangesClass) {
        _inherits(DOMChangesWithSVGInnerHTMLFix, _DOMChangesClass);

        function DOMChangesWithSVGInnerHTMLFix() {
            _classCallCheck(this, DOMChangesWithSVGInnerHTMLFix);

            return _possibleConstructorReturn(this, _DOMChangesClass.apply(this, arguments));
        }

        DOMChangesWithSVGInnerHTMLFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
            if (html === null || html === '') {
                return _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            }
            if (parent.namespaceURI !== svgNamespace) {
                return _DOMChangesClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            }
            return fixSVG(parent, div, html, nextSibling);
        };

        return DOMChangesWithSVGInnerHTMLFix;
    }(DOMChangesClass);
}
export function treeConstruction(document, TreeConstructionClass, svgNamespace) {
    if (!document) return TreeConstructionClass;
    if (!shouldApplyFix(document, svgNamespace)) {
        return TreeConstructionClass;
    }
    var div = document.createElement('div');
    return function (_TreeConstructionClas) {
        _inherits(TreeConstructionWithSVGInnerHTMLFix, _TreeConstructionClas);

        function TreeConstructionWithSVGInnerHTMLFix() {
            _classCallCheck(this, TreeConstructionWithSVGInnerHTMLFix);

            return _possibleConstructorReturn(this, _TreeConstructionClas.apply(this, arguments));
        }

        TreeConstructionWithSVGInnerHTMLFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, reference, html) {
            if (html === null || html === '') {
                return _TreeConstructionClas.prototype.insertHTMLBefore.call(this, parent, reference, html);
            }
            if (parent.namespaceURI !== svgNamespace) {
                return _TreeConstructionClas.prototype.insertHTMLBefore.call(this, parent, reference, html);
            }
            return fixSVG(parent, div, html, reference);
        };

        return TreeConstructionWithSVGInnerHTMLFix;
    }(TreeConstructionClass);
}
function fixSVG(parent, div, html, reference) {
    // IE, Edge: also do not correctly support using `innerHTML` on SVG
    // namespaced elements. So here a wrapper is used.
    var wrappedHtml = '<svg>' + html + '</svg>';
    div.innerHTML = wrappedHtml;

    var _moveNodesBefore = moveNodesBefore(div.firstChild, parent, reference),
        first = _moveNodesBefore[0],
        last = _moveNodesBefore[1];

    return new ConcreteBounds(parent, first, last);
}
function shouldApplyFix(document, svgNamespace) {
    var svg = document.createElementNS(svgNamespace, 'svg');
    try {
        svg['insertAdjacentHTML']('beforeend', '<circle></circle>');
    } catch (e) {
        // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG
        // Safari: Will throw, insertAdjacentHTML is not present on SVG
    } finally {
        // FF: Old versions will create a node in the wrong namespace
        if (svg.childNodes.length === 1 && svg.firstChild.namespaceURI === SVG_NAMESPACE) {
            // The test worked as expected, no fix required
            return false;
        }
        return true;
    }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21wYXQvc3ZnLWlubmVyLWh0bWwtZml4LmpzIl0sIm5hbWVzIjpbIkNvbmNyZXRlQm91bmRzIiwibW92ZU5vZGVzQmVmb3JlIiwiU1ZHX05BTUVTUEFDRSIsImRvbUNoYW5nZXMiLCJkb2N1bWVudCIsIkRPTUNoYW5nZXNDbGFzcyIsInN2Z05hbWVzcGFjZSIsInNob3VsZEFwcGx5Rml4IiwiZGl2IiwiY3JlYXRlRWxlbWVudCIsImluc2VydEhUTUxCZWZvcmUiLCJwYXJlbnQiLCJuZXh0U2libGluZyIsImh0bWwiLCJuYW1lc3BhY2VVUkkiLCJmaXhTVkciLCJ0cmVlQ29uc3RydWN0aW9uIiwiVHJlZUNvbnN0cnVjdGlvbkNsYXNzIiwicmVmZXJlbmNlIiwid3JhcHBlZEh0bWwiLCJpbm5lckhUTUwiLCJmaXJzdENoaWxkIiwiZmlyc3QiLCJsYXN0Iiwic3ZnIiwiY3JlYXRlRWxlbWVudE5TIiwiZSIsImNoaWxkTm9kZXMiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsU0FBU0EsY0FBVCxRQUErQixXQUEvQjtBQUNBLFNBQVNDLGVBQVQsUUFBZ0MsZUFBaEM7O0FBRUEsT0FBTyxJQUFNQyxnQkFBZ0IsNEJBQXRCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sU0FBU0MsVUFBVCxDQUFvQkMsUUFBcEIsRUFBOEJDLGVBQTlCLEVBQStDQyxZQUEvQyxFQUE2RDtBQUNoRSxRQUFJLENBQUNGLFFBQUwsRUFBZSxPQUFPQyxlQUFQO0FBQ2YsUUFBSSxDQUFDRSxlQUFlSCxRQUFmLEVBQXlCRSxZQUF6QixDQUFMLEVBQTZDO0FBQ3pDLGVBQU9ELGVBQVA7QUFDSDtBQUNELFFBQUlHLE1BQU1KLFNBQVNLLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVjtBQUNBO0FBQUE7O0FBQUE7QUFBQTs7QUFBQTtBQUFBOztBQUFBLGdEQUNJQyxnQkFESiw2QkFDcUJDLE1BRHJCLEVB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WyJpbXBvcnQgeyBDb25jcmV0ZUJvdW5kcyB9IGZyb20gJy4uL2JvdW5kcyc7XG5pbXBvcnQgeyBtb3ZlTm9kZXNCZWZvcmUgfSBmcm9tICcuLi9kb20vaGVscGVyJztcbmltcG9ydCB7IHVud3JhcCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuZXhwb3J0IGNvbnN0IFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuLy8gUGF0Y2g6ICAgIGluc2VydEFkamFjZW50SFRNTCBvbiBTVkcgRml4XG4vLyBCcm93c2VyczogU2FmYXJpLCBJRSwgRWRnZSwgRmlyZWZveCB+MzMtMzRcbi8vIFJlYXNvbjogICBpbnNlcnRBZGphY2VudEhUTUwgZG9lcyBub3QgZXhpc3Qgb24gU1ZHIGVsZW1lbnRzIGluIFNhZmFyaS4gSXQgaXNcbi8vICAgICAgICAgICBwcmVzZW50IGJ1dCB0aHJvd3MgYW4gZXhjZXB0aW9uIG9uIElFIGFuZCBFZGdlLiBPbGQgdmVyc2lvbnMgb2Zcbi8vICAgICAgICAgICBGaXJlZm94IGNyZWF0ZSBub2RlcyBpbiB0aGUgaW5jb3JyZWN0IG5hbWVzcGFjZS5cbi8vIEZpeDogICAgICBTaW5jZSBJRSBhbmQgRWRnZSBzaWxlbnRseSBmYWlsIHRvIGNyZWF0ZSBTVkcgbm9kZXMgdXNpbmdcbi8vICAgICAgICAgICBpbm5lckhUTUwsIGFuZCBiZWNhdXNlIEZpcmVmb3ggbWF5IGNyZWF0ZSBub2RlcyBpbiB0aGUgaW5jb3JyZWN0XG4vLyAgICAgICAgICAgbmFtZXNwYWNlIHVzaW5nIGlubmVySFRNTCBvbiBTVkcgZWxlbWVudHMsIGFuIEhUTUwtc3RyaW5nIHdyYXBwaW5nXG4vLyAgICAgICAgICAgYXBwcm9hY2ggaXMgdXNlZC4gQSBwcmUvcG9zdCBTVkcgdGFnIGlzIGFkZGVkIHRvIHRoZSBzdHJpbmcsIHRoZW5cbi8vICAgICAgICAgICB0aGF0IHdob2xlIHN0cmluZyBpcyBhZGRlZCB0byBhIGRpdi4gVGhlIGNyZWF0ZWQgbm9kZXMgYXJlIHBsdWNrZWRcbi8vICAgICAgICAgICBvdXQgYW5kIGFwcGxpZWQgdG8gdGhlIHRhcmdldCBsb2NhdGlvbiBvbiBET00uXG5leHBvcnQgZnVuY3Rpb24gZG9tQ2hhbmdlcyhkb2N1bWVudCwgRE9NQ2hhbmdlc0NsYXNzLCBzdmdOYW1lc3BhY2UpIHtcbiAgICBpZiAoIWRvY3VtZW50KSByZXR1cm4gRE9NQ2hhbmdlc0NsYXNzO1xuICAgIGlmICghc2hvdWxkQXBwbHlGaXgoZG9jdW1lbnQsIHN2Z05hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuIERPTUNoYW5nZXNDbGFzcztcbiAgICB9XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldHVybiBjbGFzcyBET01DaGFuZ2VzV2l0aFNWR0lubmVySFRNTEZpeCBleHRlbmRzIERPTUNoYW5nZXNDbGFzcyB7XG4gICAgICAgIGluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCkge1xuICAgICAgICAgICAgaWYgKGh0bWwgPT09IG51bGwgfHwgaHRtbCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQsIG5leHRTaWJsaW5nLCBodG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJICE9PSBzdmdOYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQsIG5leHRTaWJsaW5nLCBodG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaXhTVkcocGFyZW50LCBkaXYsIGh0bWwsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdHJlZUNvbnN0cnVjdGlvbihkb2N1bWVudCwgVHJlZUNvbnN0cnVjdGlvbkNsYXNzLCBzdmdOYW1lc3BhY2UpIHtcbiAgICBpZiAoIWRvY3VtZW50KSByZXR1cm4gVHJlZUNvbnN0cnVjdGlvbkNsYXNzO1xuICAgIGlmICghc2hvdWxkQXBwbHlGaXgoZG9jdW1lbnQsIHN2Z05hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuIFRyZWVDb25zdHJ1Y3Rpb25DbGFzcztcbiAgICB9XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldHVybiBjbGFzcyBUcmVlQ29uc3RydWN0aW9uV2l0aFNWR0lubmVySFRNTEZpeCBleHRlbmRzIFRyZWVDb25zdHJ1Y3Rpb25DbGFzcyB7XG4gICAgICAgIGluc2VydEhUTUxCZWZvcmUocGFyZW50LCByZWZlcmVuY2UsIGh0bWwpIHtcbiAgICAgICAgICAgIGlmIChodG1sID09PSBudWxsIHx8IGh0bWwgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCByZWZlcmVuY2UsIGh0bWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgIT09IHN2Z05hbWVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdXBlci5pbnNlcnRIVE1MQmVmb3JlKHBhcmVudCwgcmVmZXJlbmNlLCBodG1sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaXhTVkcocGFyZW50LCBkaXYsIGh0bWwsIHJlZmVyZW5jZSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gZml4U1ZHKHBhcmVudCwgZGl2LCBodG1sLCByZWZlcmVuY2UpIHtcbiAgICAvLyBJRSwgRWRnZTogYWxzbyBkbyBub3QgY29ycmVjdGx5IHN1cHBvcnQgdXNpbmcgYGlubmVySFRNTGAgb24gU1ZHXG4gICAgLy8gbmFtZXNwYWNlZCBlbGVtZW50cy4gU28gaGVyZSBhIHdyYXBwZXIgaXMgdXNlZC5cbiAgICBsZXQgd3JhcHBlZEh0bWwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIGRpdi5pbm5lckhUTUwgPSB3cmFwcGVkSHRtbDtcbiAgICBsZXQgW2ZpcnN0LCBsYXN0XSA9IG1vdmVOb2Rlc0JlZm9yZShkaXYuZmlyc3RDaGlsZCwgcGFyZW50LCByZWZlcmVuY2UpO1xuICAgIHJldHVybiBuZXcgQ29uY3JldGVCb3VuZHMocGFyZW50LCBmaXJzdCwgbGFzdCk7XG59XG5mdW5jdGlvbiBzaG91bGRBcHBseUZpeChkb2N1bWVudCwgc3ZnTmFtZXNwYWNlKSB7XG4gICAgbGV0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOYW1lc3BhY2UsICdzdmcnKTtcbiAgICB0cnkge1xuICAgICAgICBzdmdbJ2luc2VydEFkamFjZW50SFRNTCddKCdiZWZvcmVlbmQnLCAnPGNpcmNsZT48L2NpcmNsZT4nKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElFLCBFZGdlOiBXaWxsIHRocm93LCBpbnNlcnRBZGphY2VudEhUTUwgaXMgdW5zdXBwb3J0ZWQgb24gU1ZHXG4gICAgICAgIC8vIFNhZmFyaTogV2lsbCB0aHJvdywgaW5zZXJ0QWRqYWNlbnRIVE1MIGlzIG5vdCBwcmVzZW50IG9uIFNWR1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIEZGOiBPbGQgdmVyc2lvbnMgd2lsbCBjcmVhdGUgYSBub2RlIGluIHRoZSB3cm9uZyBuYW1lc3BhY2VcbiAgICAgICAgaWYgKHN2Zy5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiB1bndyYXAoc3ZnLmZpcnN0Q2hpbGQpLm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gVGhlIHRlc3Qgd29ya2VkIGFzIGV4cGVjdGVkLCBubyBmaXggcmVxdWlyZWRcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59Il19