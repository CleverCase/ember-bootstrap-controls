export { _insertHTMLBefore as insertHTMLBefore };

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { ConcreteBounds, SingleNodeBounds } from '../bounds';
import { domChanges as domChangesTableElementFix, treeConstruction as treeConstructionTableElementFix } from '../compat/inner-html-fix';
import { domChanges as domChangesSvgElementFix, treeConstruction as treeConstructionSvgElementFix } from '../compat/svg-inner-html-fix';
import { domChanges as domChangesNodeMergingFix, treeConstruction as treeConstructionNodeMergingFix } from '../compat/text-node-merging-fix';
export var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
// http://www.w3.org/TR/html/syntax.html#html-integration-point
var SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };
// http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes
// TODO: Adjust SVG attributes
// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
// TODO: Adjust SVG elements
// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
export var BLACKLIST_TABLE = Object.create(null);
["b", "big", "blockquote", "body", "br", "center", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "i", "img", "li", "listing", "main", "meta", "nobr", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "strike", "sub", "sup", "table", "tt", "u", "ul", "var"].forEach(function (tag) {
    return BLACKLIST_TABLE[tag] = 1;
});
var WHITESPACE = /[\t-\r \xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/;
var doc = typeof document === 'undefined' ? null : document;
export function isWhitespace(string) {
    return WHITESPACE.test(string);
}
export function moveNodesBefore(source, target, nextSibling) {
    var first = source.firstChild;
    var last = null;
    var current = first;
    while (current) {
        last = current;
        current = current.nextSibling;
        target.insertBefore(last, nextSibling);
    }
    return [first, last];
}
export var DOMOperations = function () {
    function DOMOperations(document) {
        _classCallCheck(this, DOMOperations);

        this.document = document;
        this.setupUselessElement();
    }
    // split into seperate method so that NodeDOMTreeConstruction
    // can override it.


    DOMOperations.prototype.setupUselessElement = function setupUselessElement() {
        this.uselessElement = this.document.createElement('div');
    };

    DOMOperations.prototype.createElement = function createElement(tag, context) {
        var isElementInSVGNamespace = void 0,
            isHTMLIntegrationPoint = void 0;
        if (context) {
            isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE || tag === 'svg';
            isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];
        } else {
            isElementInSVGNamespace = tag === 'svg';
            isHTMLIntegrationPoint = false;
        }
        if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
            // FIXME: This does not properly handle <font> with color, face, or
            // size attributes, which is also disallowed by the spec. We should fix
            // this.
            if (BLACKLIST_TABLE[tag]) {
                throw new Error('Cannot create a ' + tag + ' inside an SVG context');
            }
            return this.document.createElementNS(SVG_NAMESPACE, tag);
        } else {
            return this.document.createElement(tag);
        }
    };

    DOMOperations.prototype.insertBefore = function insertBefore(parent, node, reference) {
        parent.insertBefore(node, reference);
    };

    DOMOperations.prototype.insertHTMLBefore = function insertHTMLBefore(_parent, nextSibling, html) {
        return _insertHTMLBefore(this.uselessElement, _parent, nextSibling, html);
    };

    DOMOperations.prototype.createTextNode = function createTextNode(text) {
        return this.document.createTextNode(text);
    };

    DOMOperations.prototype.createComment = function createComment(data) {
        return this.document.createComment(data);
    };

    return DOMOperations;
}();
export var DOM;
(function (DOM) {
    var TreeConstruction = function (_DOMOperations) {
        _inherits(TreeConstruction, _DOMOperations);

        function TreeConstruction() {
            _classCallCheck(this, TreeConstruction);

            return _possibleConstructorReturn(this, _DOMOperations.apply(this, arguments));
        }

        TreeConstruction.prototype.createElementNS = function createElementNS(namespace, tag) {
            return this.document.createElementNS(namespace, tag);
        };

        TreeConstruction.prototype.setAttribute = function setAttribute(element, name, value, namespace) {
            if (namespace) {
                element.setAttributeNS(namespace, name, value);
            } else {
                element.setAttribute(name, value);
            }
        };

        return TreeConstruction;
    }(DOMOperations);

    DOM.TreeConstruction = TreeConstruction;
    var appliedTreeContruction = TreeConstruction;
    appliedTreeContruction = treeConstructionNodeMergingFix(doc, appliedTreeContruction);
    appliedTreeContruction = treeConstructionTableElementFix(doc, appliedTreeContruction);
    appliedTreeContruction = treeConstructionSvgElementFix(doc, appliedTreeContruction, SVG_NAMESPACE);
    DOM.DOMTreeConstruction = appliedTreeContruction;
})(DOM || (DOM = {}));
export var DOMChanges = function (_DOMOperations2) {
    _inherits(DOMChanges, _DOMOperations2);

    function DOMChanges(document) {
        _classCallCheck(this, DOMChanges);

        var _this2 = _possibleConstructorReturn(this, _DOMOperations2.call(this, document));

        _this2.document = document;
        _this2.namespace = null;
        return _this2;
    }

    DOMChanges.prototype.setAttribute = function setAttribute(element, name, value) {
        element.setAttribute(name, value);
    };

    DOMChanges.prototype.setAttributeNS = function setAttributeNS(element, namespace, name, value) {
        element.setAttributeNS(namespace, name, value);
    };

    DOMChanges.prototype.removeAttribute = function removeAttribute(element, name) {
        element.removeAttribute(name);
    };

    DOMChanges.prototype.removeAttributeNS = function removeAttributeNS(element, namespace, name) {
        element.removeAttributeNS(namespace, name);
    };

    DOMChanges.prototype.insertNodeBefore = function insertNodeBefore(parent, node, reference) {
        if (isDocumentFragment(node)) {
            var firstChild = node.firstChild,
                lastChild = node.lastChild;

            this.insertBefore(parent, node, reference);
            return new ConcreteBounds(parent, firstChild, lastChild);
        } else {
            this.insertBefore(parent, node, reference);
            return new SingleNodeBounds(parent, node);
        }
    };

    DOMChanges.prototype.insertTextBefore = function insertTextBefore(parent, nextSibling, text) {
        var textNode = this.createTextNode(text);
        this.insertBefore(parent, textNode, nextSibling);
        return textNode;
    };

    DOMChanges.prototype.insertBefore = function insertBefore(element, node, reference) {
        element.insertBefore(node, reference);
    };

    DOMChanges.prototype.insertAfter = function insertAfter(element, node, reference) {
        this.insertBefore(element, node, reference.nextSibling);
    };

    return DOMChanges;
}(DOMOperations);
function _insertHTMLBefore(_useless, _parent, _nextSibling, html) {
    // TypeScript vendored an old version of the DOM spec where `insertAdjacentHTML`
    // only exists on `HTMLElement` but not on `Element`. We actually work with the
    // newer version of the DOM API here (and monkey-patch this method in `./compat`
    // when we detect older browsers). This is a hack to work around this limitation.
    var parent = _parent;
    var useless = _useless;
    var nextSibling = _nextSibling;
    var prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
    var last = void 0;
    if (html === null || html === '') {
        return new ConcreteBounds(parent, null, null);
    }
    if (nextSibling === null) {
        parent.insertAdjacentHTML('beforeend', html);
        last = parent.lastChild;
    } else if (nextSibling instanceof HTMLElement) {
        nextSibling.insertAdjacentHTML('beforebegin', html);
        last = nextSibling.previousSibling;
    } else {
        // Non-element nodes do not support insertAdjacentHTML, so add an
        // element and call it on that element. Then remove the element.
        //
        // This also protects Edge, IE and Firefox w/o the inspector open
        // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts
        parent.insertBefore(useless, nextSibling);
        useless.insertAdjacentHTML('beforebegin', html);
        last = useless.previousSibling;
        parent.removeChild(useless);
    }
    var first = prev ? prev.nextSibling : parent.firstChild;
    return new ConcreteBounds(parent, first, last);
}
function isDocumentFragment(node) {
    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
var helper = DOMChanges;
helper = domChangesNodeMergingFix(doc, helper);
helper = domChangesTableElementFix(doc, helper);
helper = domChangesSvgElementFix(doc, helper, SVG_NAMESPACE);
export default helper;
export var DOMTreeConstruction = DOM.DOMTreeConstruction;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9kb20vaGVscGVyLmpzIl0sIm5hbWVzIjpbIkNvbmNyZXRlQm91bmRzIiwiU2luZ2xlTm9kZUJvdW5kcyIsImRvbUNoYW5nZXMiLCJkb21DaGFuZ2VzVGFibGVFbGVtZW50Rml4IiwidHJlZUNvbnN0cnVjdGlvbiIsInRyZWVDb25zdHJ1Y3Rpb25UYWJsZUVsZW1lbnRGaXgiLCJkb21DaGFuZ2VzU3ZnRWxlbWVudEZpeCIsInRyZWVDb25zdHJ1Y3Rpb25TdmdFbGVtZW50Rml4IiwiZG9tQ2hhbmdlc05vZGVNZXJnaW5nRml4IiwidHJlZUNvbnN0cnVjdGlvbk5vZGVNZXJnaW5nRml4IiwiU1ZHX05BTUVTUEFDRSIsIlNWR19JTlRFR1JBVElPTl9QT0lOVFMiLCJmb3JlaWduT2JqZWN0IiwiZGVzYyIsInRpdGxlIiwiQkxBQ0tMSVNUX1RBQkxFIiwiT2JqZWN0IiwiY3JlYXRlIiwiZm9yRWFjaCIsInRhZyIsIldISVRFU1BBQ0UiLCJkb2MiLCJkb2N1bWVudCIsImlzV2hpdGVzcGFjZSIsInN0cmluZyIsInRlc3QiLCJtb3ZlTm9kZXNCZWZvcmUiLCJzb3VyY2UiLCJ0YXJnZXQiLCJuZXh0U2libGluZyIsImZpcnN0IiwiZmlyc3RDaGlsZCIsImxhc3QiLCJjdXJyZW50IiwiaW5zZXJ0QmVmb3JlIiwiRE9NT3BlcmF0aW9ucyIsInNldHVwVXNlbGVzc0VsZW1lbnQiLCJ1c2VsZXNzRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwiaXNFbGVtZW50SW5TVkdOYW1lc3BhY2UiLCJpc0hUTUxJbnRlZ3JhdGlvblBvaW50IiwibmFtZXNwYWNlVVJJIiwidGFnTmFtZSIsIkVycm9yIiwiY3JlYXRlRWxlbWVudE5TIiwicGFyZW50Iiwibm9kZSIsInJlZmVyZW5jZSIsImluc2VydEhUTUxCZWZvcmUiLCJfcGFyZW50IiwiaHRtbCIsImNyZWF0ZVRleHROb2RlIiwidGV4dCIsImNyZWF0ZUNvbW1lbnQiLCJkYXRhIiwiRE9NIiwiVHJlZUNvbnN0cnVjdGlvbiIsIm5hbWVzcGFjZSIsInNldEF0dHJpYnV0ZSIsImVsZW1lbnQiLCJuYW1lIiwidmFsdWUiLCJzZXRBdHRyaWJ1dGVOUyIsImFwcGxpZWRUcmVlQ29udHJ1Y3Rpb24iLCJET01UcmVlQ29uc3RydWN0aW9uIiwiRE9NQ2hhbmdlcyIsInJlbW92ZUF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiaW5zZXJ0Tm9kZUJlZm9yZSIsImlzRG9jdW1lbnRGcmFnbWVudCIsImxhc3RDaGlsZCIsImluc2VydFRleHRCZWZvcmUiLCJ0ZXh0Tm9kZSIsImluc2VydEFmdGVyIiwiX3VzZWxlc3MiLCJfbmV4dFNpYmxpbmciLCJ1c2VsZXNzIiwicHJldiIsInByZXZpb3VzU2libGluZyIsImluc2VydEFkamFjZW50SFRNTCIsIkhUTUxFbGVtZW50IiwicmVtb3ZlQ2hpbGQiLCJub2RlVHlwZSIsIk5vZGUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiaGVscGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsU0FBU0EsY0FBVCxFQUF5QkMsZ0JBQXpCLFFBQWlELFdBQWpEO0FBQ0EsU0FBU0MsY0FBY0MseUJBQXZCLEVBQWtEQyxvQkFBb0JDLCtCQUF0RSxRQUE2RywwQkFBN0c7QUFDQSxTQUFTSCxjQUFjSSx1QkFBdkIsRUFBZ0RGLG9CQUFvQkcsNkJBQXBFLFFBQXlHLDhCQUF6RztBQUNBLFNBQVNMLGNBQWNNLHdCQUF2QixFQUFpREosb0JBQW9CSyw4QkFBckUsUUFBMkcsaUNBQTNHO0FBQ0EsT0FBTyxJQUFNQyxnQkFBZ0IsNEJBQXRCO0FBQ1A7QUFDQSxJQUFNQyx5QkFBeUIsRUFBRUMsZUFBZSxDQUFqQixFQUFvQkMsTUFBTSxDQUExQixFQUE2QkMsT0FBTyxDQUFwQyxFQUEvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQU1DLGtCQUFrQkMsT0FBT0MsTUFBUCxDQUFjLElBQWQsQ0FBeEI7QUFDUCxDQUFDLEdBQUQsRUFBTSxLQUFOLEVBQWEsWUFBYixF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LENBQTJCLGFBQTNCLEVBQTBDN0IsSUFBMUM7QUFDQW5CLGVBQU82QyxRQUFRRSxlQUFmO0FBQ0FqQyxlQUFPb0MsV0FBUCxDQUFtQkwsT0FBbkI7QUFDSDtBQUNELFFBQUkvQyxRQUFRZ0QsT0FBT0EsS0FBS2pELFdBQVosR0FBMEJpQixPQUFPZixVQUE3QztBQUNBLFdBQU8sSUFBSS9CLGNBQUosQ0FBbUI4QyxNQUFuQixFQUEyQmhCLEtBQTNCLEVBQWtDRSxJQUFsQyxDQUFQO0FBQ0g7QUFDRCxTQUFTc0Msa0JBQVQsQ0FBNEJ2QixJQUE1QixFQUFrQztBQUM5QixXQUFPQSxLQUFLb0MsUUFBTCxLQUFrQkMsS0FBS0Msc0JBQTlCO0FBQ0g7QUFDRCxJQUFJQyxTQUFTcEIsVUFBYjtBQUNBb0IsU0FBUzlFLHlCQUF5QmEsR0FBekIsRUFBOEJpRSxNQUE5QixDQUFUO0FBQ0FBLFNBQVNuRiwwQkFBMEJrQixHQUExQixFQUErQmlFLE1BQS9CLENBQVQ7QUFDQUEsU0FBU2hGLHdCQUF3QmUsR0FBeEIsRUFBNkJpRSxNQUE3QixFQUFxQzVFLGFBQXJDLENBQVQ7QUFDQSxlQUFlNEUsTUFBZjtBQUNBLE9BQU8sSUFBTXJCLHNCQUFzQlQsSUFBSVMsbUJBQWhDIiwiZmlsZSI6ImxpYi9kb20vaGVscGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29uY3JldGVCb3VuZHMsIFNpbmdsZU5vZGVCb3VuZHMgfSBmcm9tICcuLi9ib3VuZHMnO1xuaW1wb3J0IHsgZG9tQ2hhbmdlcyBhcyBkb21DaGFuZ2VzVGFibGVFbGVtZW50Rml4LCB0cmVlQ29uc3RydWN0aW9uIGFzIHRyZWVDb25zdHJ1Y3Rpb25UYWJsZUVsZW1lbnRGaXggfSBmcm9tICcuLi9jb21wYXQvaW5uZXItaHRtbC1maXgnO1xuaW1wb3J0IHsgZG9tQ2hhbmdlcyBhcyBkb21DaGFuZ2VzU3ZnRWxlbWVudEZpeCwgdHJlZUNvbnN0cnVjdGlvbiBhcyB0cmVlQ29uc3RydWN0aW9uU3ZnRWxlbWVudEZpeCB9IGZyb20gJy4uL2NvbXBhdC9zdmctaW5uZXItaHRtbC1maXgnO1xuaW1wb3J0IHsgZG9tQ2hhbmdlcyBhcyBkb21DaGFuZ2VzTm9kZU1lcmdpbmdGaXgsIHRyZWVDb25zdHJ1Y3Rpb24gYXMgdHJlZUNvbnN0cnVjdGlvbk5vZGVNZXJnaW5nRml4IH0gZnJvbSAnLi4vY29tcGF0L3RleHQtbm9kZS1tZXJnaW5nLWZpeCc7XG5leHBvcnQgY29uc3QgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbmNvbnN0IFNWR19JTlRFR1JBVElPTl9QT0lOVFMgPSB7IGZvcmVpZ25PYmplY3Q6IDEsIGRlc2M6IDEsIHRpdGxlOiAxIH07XG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sL3N5bnRheC5odG1sI2FkanVzdC1zdmctYXR0cmlidXRlc1xuLy8gVE9ETzogQWRqdXN0IFNWRyBhdHRyaWJ1dGVzXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmZvcmVpZ25cbi8vIFRPRE86IEFkanVzdCBTVkcgZWxlbWVudHNcbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluZm9yZWlnblxuZXhwb3J0IGNvbnN0IEJMQUNLTElTVF9UQUJMRSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5bXCJiXCIsIFwiYmlnXCIsIFwiYmxvY2txdW90ZVwiLCBcImJvZHlcIiwgXCJiclwiLCBcImNlbnRlclwiLCBcImNvZGVcIiwgXCJkZFwiLCBcImRpdlwiLCBcImRsXCIsIFwiZHRcIiwgXCJlbVwiLCBcImVtYmVkXCIsIFwiaDFcIiwgXCJoMlwiLCBcImgzXCIsIFwiaDRcIiwgXCJoNVwiLCBcImg2XCIsIFwiaGVhZFwiLCBcImhyXCIsIFwiaVwiLCBcImltZ1wiLCBcImxpXCIsIFwibGlzdGluZ1wiLCBcIm1haW5cIiwgXCJtZXRhXCIsIFwibm9iclwiLCBcIm9sXCIsIFwicFwiLCBcInByZVwiLCBcInJ1YnlcIiwgXCJzXCIsIFwic21hbGxcIiwgXCJzcGFuXCIsIFwic3Ryb25nXCIsIFwic3RyaWtlXCIsIFwic3ViXCIsIFwic3VwXCIsIFwidGFibGVcIiwgXCJ0dFwiLCBcInVcIiwgXCJ1bFwiLCBcInZhclwiXS5mb3JFYWNoKHRhZyA9PiBCTEFDS0xJU1RfVEFCTEVbdGFnXSA9IDEpO1xuY29uc3QgV0hJVEVTUEFDRSA9IC9bXFx0LVxcciBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGXS87XG5sZXQgZG9jID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiBkb2N1bWVudDtcbmV4cG9ydCBmdW5jdGlvbiBpc1doaXRlc3BhY2Uoc3RyaW5nKSB7XG4gICAgcmV0dXJuIFdISVRFU1BBQ0UudGVzdChzdHJpbmcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVOb2Rlc0JlZm9yZShzb3VyY2UsIHRhcmdldCwgbmV4dFNpYmxpbmcpIHtcbiAgICBsZXQgZmlyc3QgPSBzb3VyY2UuZmlyc3RDaGlsZDtcbiAgICBsZXQgbGFzdCA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnQgPSBmaXJzdDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBsYXN0ID0gY3VycmVudDtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dFNpYmxpbmc7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUobGFzdCwgbmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gW2ZpcnN0LCBsYXN0XTtcbn1cbmV4cG9ydCBjbGFzcyBET01PcGVyYXRpb25zIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuc2V0dXBVc2VsZXNzRWxlbWVudCgpO1xuICAgIH1cbiAgICAvLyBzcGxpdCBpbnRvIHNlcGVyYXRlIG1ldGhvZCBzbyB0aGF0IE5vZGVET01UcmVlQ29uc3RydWN0aW9uXG4gICAgLy8gY2FuIG92ZXJyaWRlIGl0LlxuICAgIHNldHVwVXNlbGVzc0VsZW1lbnQoKSB7XG4gICAgICAgIHRoaXMudXNlbGVzc0VsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICBjcmVhdGVFbGVtZW50KHRhZywgY29udGV4dCkge1xuICAgICAgICBsZXQgaXNFbGVtZW50SW5TVkdOYW1lc3BhY2UsIGlzSFRNTEludGVncmF0aW9uUG9pbnQ7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBpc0VsZW1lbnRJblNWR05hbWVzcGFjZSA9IGNvbnRleHQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFIHx8IHRhZyA9PT0gJ3N2Zyc7XG4gICAgICAgICAgICBpc0hUTUxJbnRlZ3JhdGlvblBvaW50ID0gU1ZHX0lOVEVHUkFUSU9OX1BPSU5UU1tjb250ZXh0LnRhZ05hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNFbGVtZW50SW5TVkdOYW1lc3BhY2UgPSB0YWcgPT09ICdzdmcnO1xuICAgICAgICAgICAgaXNIVE1MSW50ZWdyYXRpb25Qb2ludCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0VsZW1lbnRJblNWR05hbWVzcGFjZSAmJiAhaXNIVE1MSW50ZWdyYXRpb25Qb2ludCkge1xuICAgICAgICAgICAgLy8gRklYTUU6IFRoaXMgZG9lcyBub3QgcHJvcGVybHkgaGFuZGxlIDxmb250PiB3aXRoIGNvbG9yLCBmYWNlLCBvclxuICAgICAgICAgICAgLy8gc2l6ZSBhdHRyaWJ1dGVzLCB3aGljaCBpcyBhbHNvIGRpc2FsbG93ZWQgYnkgdGhlIHNwZWMuIFdlIHNob3VsZCBmaXhcbiAgICAgICAgICAgIC8vIHRoaXMuXG4gICAgICAgICAgICBpZiAoQkxBQ0tMSVNUX1RBQkxFW3RhZ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgYSAke3RhZ30gaW5zaWRlIGFuIFNWRyBjb250ZXh0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05BTUVTUEFDRSwgdGFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLCByZWZlcmVuY2UpIHtcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCByZWZlcmVuY2UpO1xuICAgIH1cbiAgICBpbnNlcnRIVE1MQmVmb3JlKF9wYXJlbnQsIG5leHRTaWJsaW5nLCBodG1sKSB7XG4gICAgICAgIHJldHVybiBpbnNlcnRIVE1MQmVmb3JlKHRoaXMudXNlbGVzc0VsZW1lbnQsIF9wYXJlbnQsIG5leHRTaWJsaW5nLCBodG1sKTtcbiAgICB9XG4gICAgY3JlYXRlVGV4dE5vZGUodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICB9XG4gICAgY3JlYXRlQ29tbWVudChkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0IHZhciBET007XG4oZnVuY3Rpb24gKERPTSkge1xuICAgIGNsYXNzIFRyZWVDb25zdHJ1Y3Rpb24gZXh0ZW5kcyBET01PcGVyYXRpb25zIHtcbiAgICAgICAgY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCB0YWcpO1xuICAgICAgICB9XG4gICAgICAgIHNldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlKSB7XG4gICAgICAgICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIERPTS5UcmVlQ29uc3RydWN0aW9uID0gVHJlZUNvbnN0cnVjdGlvbjtcbiAgICBsZXQgYXBwbGllZFRyZWVDb250cnVjdGlvbiA9IFRyZWVDb25zdHJ1Y3Rpb247XG4gICAgYXBwbGllZFRyZWVDb250cnVjdGlvbiA9IHRyZWVDb25zdHJ1Y3Rpb25Ob2RlTWVyZ2luZ0ZpeChkb2MsIGFwcGxpZWRUcmVlQ29udHJ1Y3Rpb24pO1xuICAgIGFwcGxpZWRUcmVlQ29udHJ1Y3Rpb24gPSB0cmVlQ29uc3RydWN0aW9uVGFibGVFbGVtZW50Rml4KGRvYywgYXBwbGllZFRyZWVDb250cnVjdGlvbik7XG4gICAgYXBwbGllZFRyZWVDb250cnVjdGlvbiA9IHRyZWVDb25zdHJ1Y3Rpb25TdmdFbGVtZW50Rml4KGRvYywgYXBwbGllZFRyZWVDb250cnVjdGlvbiwgU1ZHX05BTUVTUEFDRSk7XG4gICAgRE9NLkRPTVRyZWVDb25zdHJ1Y3Rpb24gPSBhcHBsaWVkVHJlZUNvbnRydWN0aW9uO1xufSkoRE9NIHx8IChET00gPSB7fSkpO1xuZXhwb3J0IGNsYXNzIERPTUNoYW5nZXMgZXh0ZW5kcyBET01PcGVyYXRpb25zIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCkge1xuICAgICAgICBzdXBlcihkb2N1bWVudCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBudWxsO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGVOUyhlbGVtZW50LCBuYW1lc3BhY2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICByZW1vdmVBdHRyaWJ1dGVOUyhlbGVtZW50LCBuYW1lc3BhY2UsIG5hbWUpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpO1xuICAgIH1cbiAgICBpbnNlcnROb2RlQmVmb3JlKHBhcmVudCwgbm9kZSwgcmVmZXJlbmNlKSB7XG4gICAgICAgIGlmIChpc0RvY3VtZW50RnJhZ21lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIGxldCB7IGZpcnN0Q2hpbGQsIGxhc3RDaGlsZCB9ID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZSwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uY3JldGVCb3VuZHMocGFyZW50LCBmaXJzdENoaWxkLCBsYXN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLCByZWZlcmVuY2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVOb2RlQm91bmRzKHBhcmVudCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zZXJ0VGV4dEJlZm9yZShwYXJlbnQsIG5leHRTaWJsaW5nLCB0ZXh0KSB7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IHRoaXMuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgdGV4dE5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgIH1cbiAgICBpbnNlcnRCZWZvcmUoZWxlbWVudCwgbm9kZSwgcmVmZXJlbmNlKSB7XG4gICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZmVyZW5jZSk7XG4gICAgfVxuICAgIGluc2VydEFmdGVyKGVsZW1lbnQsIG5vZGUsIHJlZmVyZW5jZSkge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShlbGVtZW50LCBub2RlLCByZWZlcmVuY2UubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRIVE1MQmVmb3JlKF91c2VsZXNzLCBfcGFyZW50LCBfbmV4dFNpYmxpbmcsIGh0bWwpIHtcbiAgICAvLyBUeXBlU2NyaXB0IHZlbmRvcmVkIGFuIG9sZCB2ZXJzaW9uIG9mIHRoZSBET00gc3BlYyB3aGVyZSBgaW5zZXJ0QWRqYWNlbnRIVE1MYFxuICAgIC8vIG9ubHkgZXhpc3RzIG9uIGBIVE1MRWxlbWVudGAgYnV0IG5vdCBvbiBgRWxlbWVudGAuIFdlIGFjdHVhbGx5IHdvcmsgd2l0aCB0aGVcbiAgICAvLyBuZXdlciB2ZXJzaW9uIG9mIHRoZSBET00gQVBJIGhlcmUgKGFuZCBtb25rZXktcGF0Y2ggdGhpcyBtZXRob2QgaW4gYC4vY29tcGF0YFxuICAgIC8vIHdoZW4gd2UgZGV0ZWN0IG9sZGVyIGJyb3dzZXJzKS4gVGhpcyBpcyBhIGhhY2sgdG8gd29yayBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLlxuICAgIGxldCBwYXJlbnQgPSBfcGFyZW50O1xuICAgIGxldCB1c2VsZXNzID0gX3VzZWxlc3M7XG4gICAgbGV0IG5leHRTaWJsaW5nID0gX25leHRTaWJsaW5nO1xuICAgIGxldCBwcmV2ID0gbmV4dFNpYmxpbmcgPyBuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGxldCBsYXN0O1xuICAgIGlmIChodG1sID09PSBudWxsIHx8IGh0bWwgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uY3JldGVCb3VuZHMocGFyZW50LCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIGh0bWwpO1xuICAgICAgICBsYXN0ID0gcGFyZW50Lmxhc3RDaGlsZDtcbiAgICB9IGVsc2UgaWYgKG5leHRTaWJsaW5nIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIGh0bWwpO1xuICAgICAgICBsYXN0ID0gbmV4dFNpYmxpbmcucHJldmlvdXNTaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vbi1lbGVtZW50IG5vZGVzIGRvIG5vdCBzdXBwb3J0IGluc2VydEFkamFjZW50SFRNTCwgc28gYWRkIGFuXG4gICAgICAgIC8vIGVsZW1lbnQgYW5kIGNhbGwgaXQgb24gdGhhdCBlbGVtZW50LiBUaGVuIHJlbW92ZSB0aGUgZWxlbWVudC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBhbHNvIHByb3RlY3RzIEVkZ2UsIElFIGFuZCBGaXJlZm94IHcvbyB0aGUgaW5zcGVjdG9yIG9wZW5cbiAgICAgICAgLy8gZnJvbSBtZXJnaW5nIGFkamFjZW50IHRleHQgbm9kZXMuIFNlZSAuL2NvbXBhdC90ZXh0LW5vZGUtbWVyZ2luZy1maXgudHNcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh1c2VsZXNzLCBuZXh0U2libGluZyk7XG4gICAgICAgIHVzZWxlc3MuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIGh0bWwpO1xuICAgICAgICBsYXN0ID0gdXNlbGVzcy5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh1c2VsZXNzKTtcbiAgICB9XG4gICAgbGV0IGZpcnN0ID0gcHJldiA/IHByZXYubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcbiAgICByZXR1cm4gbmV3IENvbmNyZXRlQm91bmRzKHBhcmVudCwgZmlyc3QsIGxhc3QpO1xufVxuZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xufVxubGV0IGhlbHBlciA9IERPTUNoYW5nZXM7XG5oZWxwZXIgPSBkb21DaGFuZ2VzTm9kZU1lcmdpbmdGaXgoZG9jLCBoZWxwZXIpO1xuaGVscGVyID0gZG9tQ2hhbmdlc1RhYmxlRWxlbWVudEZpeChkb2MsIGhlbHBlcik7XG5oZWxwZXIgPSBkb21DaGFuZ2VzU3ZnRWxlbWVudEZpeChkb2MsIGhlbHBlciwgU1ZHX05BTUVTUEFDRSk7XG5leHBvcnQgZGVmYXVsdCBoZWxwZXI7XG5leHBvcnQgY29uc3QgRE9NVHJlZUNvbnN0cnVjdGlvbiA9IERPTS5ET01UcmVlQ29uc3RydWN0aW9uOyJdfQ==