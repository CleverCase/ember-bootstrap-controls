function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

import { CONSTANT_TAG, isConst, isModified, ReferenceCache, ConstReference } from '@glimmer/reference';
import { initializeGuid } from '@glimmer/util';
import { APPEND_OPCODES, UpdatingOpcode } from '../../opcodes';
import { FALSE_REFERENCE, NULL_REFERENCE, PrimitiveReference, TRUE_REFERENCE, UNDEFINED_REFERENCE } from '../../references';
APPEND_OPCODES.add(20 /* ChildScope */, function (vm) {
    return vm.pushChildScope();
});
APPEND_OPCODES.add(21 /* PopScope */, function (vm) {
    return vm.popScope();
});
APPEND_OPCODES.add(39 /* PushDynamicScope */, function (vm) {
    return vm.pushDynamicScope();
});
APPEND_OPCODES.add(40 /* PopDynamicScope */, function (vm) {
    return vm.popDynamicScope();
});
APPEND_OPCODES.add(12 /* Immediate */, function (vm, _ref) {
    var number = _ref.op1;

    vm.stack.push(number);
});
APPEND_OPCODES.add(13 /* Constant */, function (vm, _ref2) {
    var other = _ref2.op1;

    vm.stack.push(vm.constants.getOther(other));
});
APPEND_OPCODES.add(14 /* PrimitiveReference */, function (vm, _ref3) {
    var primitive = _ref3.op1;

    var stack = vm.stack;
    var flag = (primitive & 3 << 30) >>> 30;
    var value = primitive & ~(3 << 30);
    switch (flag) {
        case 0:
            stack.push(PrimitiveReference.create(value));
            break;
        case 1:
            stack.push(PrimitiveReference.create(vm.constants.getFloat(value)));
            break;
        case 2:
            stack.push(PrimitiveReference.create(vm.constants.getString(value)));
            break;
        case 3:
            switch (value) {
                case 0:
                    stack.push(FALSE_REFERENCE);
                    break;
                case 1:
                    stack.push(TRUE_REFERENCE);
                    break;
                case 2:
                    stack.push(NULL_REFERENCE);
                    break;
                case 3:
                    stack.push(UNDEFINED_REFERENCE);
                    break;
            }
            break;
    }
});
APPEND_OPCODES.add(15 /* Dup */, function (vm, _ref4) {
    var register = _ref4.op1,
        offset = _ref4.op2;

    var position = vm.fetchValue(register) - offset;
    vm.stack.dup(position);
});
APPEND_OPCODES.add(16 /* Pop */, function (vm, _ref5) {
    var count = _ref5.op1;
    return vm.stack.pop(count);
});
APPEND_OPCODES.add(17 /* Load */, function (vm, _ref6) {
    var register = _ref6.op1;
    return vm.load(register);
});
APPEND_OPCODES.add(18 /* Fetch */, function (vm, _ref7) {
    var register = _ref7.op1;
    return vm.fetch(register);
});
APPEND_OPCODES.add(38 /* BindDynamicScope */, function (vm, _ref8) {
    var _names = _ref8.op1;

    var names = vm.constants.getArray(_names);
    vm.bindDynamicScope(names);
});
APPEND_OPCODES.add(47 /* PushFrame */, function (vm) {
    return vm.pushFrame();
});
APPEND_OPCODES.add(48 /* PopFrame */, function (vm) {
    return vm.popFrame();
});
APPEND_OPCODES.add(49 /* Enter */, function (vm, _ref9) {
    var args = _ref9.op1;
    return vm.enter(args);
});
APPEND_OPCODES.add(50 /* Exit */, function (vm) {
    return vm.exit();
});
APPEND_OPCODES.add(41 /* CompileDynamicBlock */, function (vm) {
    var stack = vm.stack;
    var block = stack.pop();
    stack.push(block ? block.compileDynamic(vm.env) : null);
});
APPEND_OPCODES.add(42 /* InvokeStatic */, function (vm, _ref10) {
    var _block = _ref10.op1;

    var block = vm.constants.getBlock(_block);
    var compiled = block.compileStatic(vm.env);
    vm.call(compiled.handle);
});
APPEND_OPCODES.add(43 /* InvokeDynamic */, function (vm, _ref11) {
    var _invoker = _ref11.op1;

    var invoker = vm.constants.getOther(_invoker);
    var block = vm.stack.pop();
    invoker.invoke(vm, block);
});
APPEND_OPCODES.add(44 /* Jump */, function (vm, _ref12) {
    var target = _ref12.op1;
    return vm.goto(target);
});
APPEND_OPCODES.add(45 /* JumpIf */, function (vm, _ref13) {
    var target = _ref13.op1;

    var reference = vm.stack.pop();
    if (isConst(reference)) {
        if (reference.value()) {
            vm.goto(target);
        }
    } else {
        var cache = new ReferenceCache(reference);
        if (cache.peek()) {
            vm.goto(target);
        }
        vm.updateWith(new Assert(cache));
    }
});
APPEND_OPCODES.add(46 /* JumpUnless */, function (vm, _ref14) {
    var target = _ref14.op1;

    var reference = vm.stack.pop();
    if (isConst(reference)) {
        if (!reference.value()) {
            vm.goto(target);
        }
    } else {
        var cache = new ReferenceCache(reference);
        if (!cache.peek()) {
            vm.goto(target);
        }
        vm.updateWith(new Assert(cache));
    }
});
APPEND_OPCODES.add(22 /* Return */, function (vm) {
    return vm.return();
});
APPEND_OPCODES.add(23 /* ReturnTo */, function (vm, _ref15) {
    var relative = _ref15.op1;

    vm.returnTo(relative);
});
export var ConstTest = function (ref, _env) {
    return new ConstReference(!!ref.value());
};
export var SimpleTest = function (ref, _env) {
    return ref;
};
export var EnvironmentTest = function (ref, env) {
    return env.toConditionalReference(ref);
};
APPEND_OPCODES.add(51 /* Test */, function (vm, _ref16) {
    var _func = _ref16.op1;

    var stack = vm.stack;
    var operand = stack.pop();
    var func = vm.constants.getFunction(_func);
    stack.push(func(operand, vm.env));
});
export var Assert = function (_UpdatingOpcode) {
    _inherits(Assert, _UpdatingOpcode);

    function Assert(cache) {
        _classCallCheck(this, Assert);

        var _this = _possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.type = 'assert';
        _this.tag = cache.tag;
        _this.cache = cache;
        return _this;
    }

    Assert.prototype.evaluate = function evaluate(vm) {
        var cache = this.cache;

        if (isModified(cache.revalidate())) {
            vm.throw();
        }
    };

    Assert.prototype.toJSON = function toJSON() {
        var type = this.type,
            _guid = this._guid,
            cache = this.cache;

        var expected = void 0;
        try {
            expected = JSON.stringify(cache.peek());
        } catch (e) {
            expected = String(cache.peek());
        }
        return {
            args: [],
            details: { expected: expected },
            guid: _guid,
            type: type
        };
    };

    return Assert;
}(UpdatingOpcode);
export var JumpIfNotModifiedOpcode = function (_UpdatingOpcode2) {
    _inherits(JumpIfNotModifiedOpcode, _UpdatingOpcode2);

    function JumpIfNotModifiedOpcode(tag, target) {
        _classCallCheck(this, JumpIfNotModifiedOpcode);

        var _this2 = _possibleConstructorReturn(this, _UpdatingOpcode2.call(this));

        _this2.target = target;
        _this2.type = 'jump-if-not-modified';
        _this2.tag = tag;
        _this2.lastRevision = tag.value();
        return _this2;
    }

    JumpIfNotModifiedOpcode.prototype.evaluate = function evaluate(vm) {
        var tag = this.tag,
            target = this.target,
            lastRevision = this.lastRevision;

        if (!vm.alwaysRevalidate && tag.validate(lastRevision)) {
            vm.goto(target);
        }
    };

    JumpIfNotModifiedOpcode.prototype.didModify = function didModify() {
        this.lastRevision = this.tag.value();
    };

    JumpIfNotModifiedOpcode.prototype.toJSON = function toJSON() {
        return {
            args: [JSON.stringify(this.target.inspect())],
            guid: this._guid,
            type: this.type
        };
    };

    return JumpIfNotModifiedOpcode;
}(UpdatingOpcode);
export var DidModifyOpcode = function (_UpdatingOpcode3) {
    _inherits(DidModifyOpcode, _UpdatingOpcode3);

    function DidModifyOpcode(target) {
        _classCallCheck(this, DidModifyOpcode);

        var _this3 = _possibleConstructorReturn(this, _UpdatingOpcode3.call(this));

        _this3.target = target;
        _this3.type = 'did-modify';
        _this3.tag = CONSTANT_TAG;
        return _this3;
    }

    DidModifyOpcode.prototype.evaluate = function evaluate() {
        this.target.didModify();
    };

    return DidModifyOpcode;
}(UpdatingOpcode);
export var LabelOpcode = function () {
    function LabelOpcode(label) {
        _classCallCheck(this, LabelOpcode);

        this.tag = CONSTANT_TAG;
        this.type = 'label';
        this.label = null;
        this.prev = null;
        this.next = null;
        initializeGuid(this);
        this.label = label;
    }

    LabelOpcode.prototype.evaluate = function evaluate() {};

    LabelOpcode.prototype.inspect = function inspect() {
        return this.label + ' [' + this._guid + ']';
    };

    LabelOpcode.prototype.toJSON = function toJSON() {
        return {
            args: [JSON.stringify(this.inspect())],
            guid: this._guid,
            type: this.type
        };
    };

    return LabelOpcode;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21waWxlZC9vcGNvZGVzL3ZtLmpzIl0sIm5hbWVzIjpbIkNPTlNUQU5UX1RBRyIsImlzQ29uc3QiLCJpc01vZGlmaWVkIiwiUmVmZXJlbmNlQ2FjaGUiLCJDb25zdFJlZmVyZW5jZSIsImluaXRpYWxpemVHdWlkIiwiQVBQRU5EX09QQ09ERVMiLCJVcGRhdGluZ09wY29kZSIsIkZBTFNFX1JFRkVSRU5DRSIsIk5VTExfUkVGRVJFTkNFIiwiUHJpbWl0aXZlUmVmZXJlbmNlIiwiVFJVRV9SRUZFUkVOQ0UiLCJVTkRFRklORURfUkVGRVJFTkNFIiwiYWRkIiwidm0iLCJwdXNoQ2hpbGRTY29wZSIsInBvcFNjb3BlIiwicHVzaER5bmFtaWNTY29wZSIsInBvcER5bmFtaWNTY29wZSIsIm51bWJlciIsIm9wMSIsInN0YWNrIiwicHVzaCIsIm90aGVyIiwiY29uc3RhbnRzIiwiZ2V0T3RoZXIiLCJwcmltaXRpdmUiLCJmbGFnIiwidmFsdWUiLCJjcmVhdGUiLCJnZXRGbG9hdCIsImdldFN0cmluZyIsInJlZ2lzdGVyIiwib2Zmc2V0Iiwib3AyIiwicG9zaXRpb24iLCJmZXRjaFZhbHVlIiwiZHVwIiwiY291bnQiLCJwb3AiLCJsb2FkIiwiZmV0Y2giLCJfbmFtZXMiLCJuYW1lcyIsImdldEFycmF5IiwiYmluZER5bmFtaWNTY29wZSIsInB1c2hGcmFtZSIsInBvcEZyYW1lIiwiYXJncyIsImVudGVyIiwiZXhpdCIsImJsb2NrIiwiY29tcGlsZUR5bmFtaWMiLCJlbnYiLCJfYmxvY2siLCJnZXRCbG9jayIsImNvbXBpbGVkIiwiY29tcGlsZVN0YXRpYyIsImNhbGwiLCJoYW5kbGUiLCJfaW52b2tlciIsImludm9rZXIiLCJpbnZva2UiLCJ0YXJnZXQiLCJnb3RvIiwicmVmZXJlbmNlIiwiY2FjaGUiLCJwZWVrIiwidXBkYXRlV2l0aCIsIkFzc2VydCIsInJldHVybiIsInJlbGF0aXZlIiwicmV0dXJuVG8iLCJDb25zdFRlc3QiLCJyZWYiLCJfZW52IiwiU2ltcGxlVGVzdCIsIkVudmlyb25tZW50VGVzdCIsInRvQ29uZGl0aW9uYWxSZWZlcmVuY2UiLCJfZnVuYyIsIm9wZXJhbmQiLCJmdW5jIiwiZ2V0RnVuY3Rpb24iLCJ0eXBlIiwidGFnIiwiZXZhbHVhdGUiLCJyZXZhbGlkYXRlIiwidGhyb3ciLCJ0b0pTT04iLCJfZ3VpZCIsImV4cGVjdGVkIiwiSlNPTiIsInN0cmluZ2lmeSIsImUiLCJTdHJpbmciLCJkZXRhaWxzIiwiZ3VpZCIsIkp1bXBJZk5vdE1vZGlmaWVkT3Bjb2RlIiwibGFzdFJldmlzaW9uIiwiYWx3YXlzUmV2YWxpZGF0ZSIsInZhbGlkYXRlIiwiZGlkTW9kaWZ5IiwiaW5zcGVjdCIsIkRpZE1vZGlmeU9wY29kZSIsIkxhYmVsT3Bjb2RlIiwibGFiZWwiLCJwcmV2IiwibmV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxTQUFTQSxZQUFULEVBQXVCQyxPQUF2QixFQUFnQ0MsVUFBaEMsRUFBNENDLGNBQTVDLEVBQTREQyxjQUE1RCxRQUFrRixvQkFBbEY7QUFDQSxTQUFTQyxjQUFULFFBQStCLGVBQS9CO0FBQ0EsU0FBU0MsY0FBVCxFQUF5QkMsY0FBekIsUUFBK0MsZUFBL0M7QUFDQSxTQUFTQyxlQUFULEVBQTBCQyxjQUExQixFQUEwQ0Msa0JBQTFDLEVBQThEQyxjQUE5RCxFQUE4RUMsbUJBQTlFLFFBQXlHLGtCQUF6RztBQUNBTixlQUFlTyxHQUFmLENBQW1CLEVBQW5CLENBQXNCLGdCQUF0QixFQUF3QztBQUFBLFdBQU1DLEdBQUdDLGNBQUgsRUFBTjtBQUFBLENBQXhDO0FBQ0FULGVBQWVPLEdBQWYsQ0FBbUIsRUFBbkIsQ0FBc0IsY0FBdEIsRUFBc0M7QUFBQSxXQUFNQyxHQUFHRSxRQUFILEVBQU47QUFBQSxDQUF0QztBQUNBVixlQUFlTyxHQUFmLENBQW1CLEVBQW5CLENBQXNCLHNCQUF0QixFQUE4QztBQUFBLFdBQU1DLEdBQUdHLGdCQUFILEVBQU47QUFBQSxDQUE5QztBQUNBWCxlQUFlTyxHQUFmLENBQW1CLEVB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QWNJRCxNQWRKLHFCQWNhO0FBQ0wsZUFBTztBQUNIeEMsa0JBQU0sQ0FBQzJDLEtBQUtDLFNBQUwsQ0FBZSxLQUFLVSxPQUFMLEVBQWYsQ0FBRCxDQURIO0FBRUhOLGtCQUFNLEtBQUtQLEtBRlI7QUFHSE4sa0JBQU0sS0FBS0E7QUFIUixTQUFQO0FBS0gsS0FwQkw7O0FBQUE7QUFBQSIsImZpbGUiOiJsaWIvY29tcGlsZWQvb3Bjb2Rlcy92bS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENPTlNUQU5UX1RBRywgaXNDb25zdCwgaXNNb2RpZmllZCwgUmVmZXJlbmNlQ2FjaGUsIENvbnN0UmVmZXJlbmNlIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGluaXRpYWxpemVHdWlkIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUywgVXBkYXRpbmdPcGNvZGUgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IEZBTFNFX1JFRkVSRU5DRSwgTlVMTF9SRUZFUkVOQ0UsIFByaW1pdGl2ZVJlZmVyZW5jZSwgVFJVRV9SRUZFUkVOQ0UsIFVOREVGSU5FRF9SRUZFUkVOQ0UgfSBmcm9tICcuLi8uLi9yZWZlcmVuY2VzJztcbkFQUEVORF9PUENPREVTLmFkZCgyMCAvKiBDaGlsZFNjb3BlICovLCB2bSA9PiB2bS5wdXNoQ2hpbGRTY29wZSgpKTtcbkFQUEVORF9PUENPREVTLmFkZCgyMSAvKiBQb3BTY29wZSAqLywgdm0gPT4gdm0ucG9wU2NvcGUoKSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoMzkgLyogUHVzaER5bmFtaWNTY29wZSAqLywgdm0gPT4gdm0ucHVzaER5bmFtaWNTY29wZSgpKTtcbkFQUEVORF9PUENPREVTLmFkZCg0MCAvKiBQb3BEeW5hbWljU2NvcGUgKi8sIHZtID0+IHZtLnBvcER5bmFtaWNTY29wZSgpKTtcbkFQUEVORF9PUENPREVTLmFkZCgxMiAvKiBJbW1lZGlhdGUgKi8sICh2bSwgeyBvcDE6IG51bWJlciB9KSA9PiB7XG4gICAgdm0uc3RhY2sucHVzaChudW1iZXIpO1xufSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoMTMgLyogQ29uc3RhbnQgKi8sICh2bSwgeyBvcDE6IG90aGVyIH0pID0+IHtcbiAgICB2bS5zdGFjay5wdXNoKHZtLmNvbnN0YW50cy5nZXRPdGhlcihvdGhlcikpO1xufSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoMTQgLyogUHJpbWl0aXZlUmVmZXJlbmNlICovLCAodm0sIHsgb3AxOiBwcmltaXRpdmUgfSkgPT4ge1xuICAgIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICAgIGxldCBmbGFnID0gKHByaW1pdGl2ZSAmIDMgPDwgMzApID4+PiAzMDtcbiAgICBsZXQgdmFsdWUgPSBwcmltaXRpdmUgJiB+KDMgPDwgMzApO1xuICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBzdGFjay5wdXNoKFByaW1pdGl2ZVJlZmVyZW5jZS5jcmVhdGUodmFsdWUpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzdGFjay5wdXNoKFByaW1pdGl2ZVJlZmVyZW5jZS5jcmVhdGUodm0uY29uc3RhbnRzLmdldEZsb2F0KHZhbHVlKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHN0YWNrLnB1c2goUHJpbWl0aXZlUmVmZXJlbmNlLmNyZWF0ZSh2bS5jb25zdGFudHMuZ2V0U3RyaW5nKHZhbHVlKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goRkFMU0VfUkVGRVJFTkNFKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFRSVUVfUkVGRVJFTkNFKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKE5VTExfUkVGRVJFTkNFKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKFVOREVGSU5FRF9SRUZFUkVOQ0UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn0pO1xuQVBQRU5EX09QQ09ERVMuYWRkKDE1IC8qIER1cCAqLywgKHZtLCB7IG9wMTogcmVnaXN0ZXIsIG9wMjogb2Zmc2V0IH0pID0+IHtcbiAgICBsZXQgcG9zaXRpb24gPSB2bS5mZXRjaFZhbHVlKHJlZ2lzdGVyKSAtIG9mZnNldDtcbiAgICB2bS5zdGFjay5kdXAocG9zaXRpb24pO1xufSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoMTYgLyogUG9wICovLCAodm0sIHsgb3AxOiBjb3VudCB9KSA9PiB2bS5zdGFjay5wb3AoY291bnQpKTtcbkFQUEVORF9PUENPREVTLmFkZCgxNyAvKiBMb2FkICovLCAodm0sIHsgb3AxOiByZWdpc3RlciB9KSA9PiB2bS5sb2FkKHJlZ2lzdGVyKSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoMTggLyogRmV0Y2ggKi8sICh2bSwgeyBvcDE6IHJlZ2lzdGVyIH0pID0+IHZtLmZldGNoKHJlZ2lzdGVyKSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoMzggLyogQmluZER5bmFtaWNTY29wZSAqLywgKHZtLCB7IG9wMTogX25hbWVzIH0pID0+IHtcbiAgICBsZXQgbmFtZXMgPSB2bS5jb25zdGFudHMuZ2V0QXJyYXkoX25hbWVzKTtcbiAgICB2bS5iaW5kRHluYW1pY1Njb3BlKG5hbWVzKTtcbn0pO1xuQVBQRU5EX09QQ09ERVMuYWRkKDQ3IC8qIFB1c2hGcmFtZSAqLywgdm0gPT4gdm0ucHVzaEZyYW1lKCkpO1xuQVBQRU5EX09QQ09ERVMuYWRkKDQ4IC8qIFBvcEZyYW1lICovLCB2bSA9PiB2bS5wb3BGcmFtZSgpKTtcbkFQUEVORF9PUENPREVTLmFkZCg0OSAvKiBFbnRlciAqLywgKHZtLCB7IG9wMTogYXJncyB9KSA9PiB2bS5lbnRlcihhcmdzKSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoNTAgLyogRXhpdCAqLywgdm0gPT4gdm0uZXhpdCgpKTtcbkFQUEVORF9PUENPREVTLmFkZCg0MSAvKiBDb21waWxlRHluYW1pY0Jsb2NrICovLCB2bSA9PiB7XG4gICAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gICAgbGV0IGJsb2NrID0gc3RhY2sucG9wKCk7XG4gICAgc3RhY2sucHVzaChibG9jayA/IGJsb2NrLmNvbXBpbGVEeW5hbWljKHZtLmVudikgOiBudWxsKTtcbn0pO1xuQVBQRU5EX09QQ09ERVMuYWRkKDQyIC8qIEludm9rZVN0YXRpYyAqLywgKHZtLCB7IG9wMTogX2Jsb2NrIH0pID0+IHtcbiAgICBsZXQgYmxvY2sgPSB2bS5jb25zdGFudHMuZ2V0QmxvY2soX2Jsb2NrKTtcbiAgICBsZXQgY29tcGlsZWQgPSBibG9jay5jb21waWxlU3RhdGljKHZtLmVudik7XG4gICAgdm0uY2FsbChjb21waWxlZC5oYW5kbGUpO1xufSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoNDMgLyogSW52b2tlRHluYW1pYyAqLywgKHZtLCB7IG9wMTogX2ludm9rZXIgfSkgPT4ge1xuICAgIGxldCBpbnZva2VyID0gdm0uY29uc3RhbnRzLmdldE90aGVyKF9pbnZva2VyKTtcbiAgICBsZXQgYmxvY2sgPSB2bS5zdGFjay5wb3AoKTtcbiAgICBpbnZva2VyLmludm9rZSh2bSwgYmxvY2spO1xufSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoNDQgLyogSnVtcCAqLywgKHZtLCB7IG9wMTogdGFyZ2V0IH0pID0+IHZtLmdvdG8odGFyZ2V0KSk7XG5BUFBFTkRfT1BDT0RFUy5hZGQoNDUgLyogSnVtcElmICovLCAodm0sIHsgb3AxOiB0YXJnZXQgfSkgPT4ge1xuICAgIGxldCByZWZlcmVuY2UgPSB2bS5zdGFjay5wb3AoKTtcbiAgICBpZiAoaXNDb25zdChyZWZlcmVuY2UpKSB7XG4gICAgICAgIGlmIChyZWZlcmVuY2UudmFsdWUoKSkge1xuICAgICAgICAgICAgdm0uZ290byh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNhY2hlID0gbmV3IFJlZmVyZW5jZUNhY2hlKHJlZmVyZW5jZSk7XG4gICAgICAgIGlmIChjYWNoZS5wZWVrKCkpIHtcbiAgICAgICAgICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2bS51cGRhdGVXaXRoKG5ldyBBc3NlcnQoY2FjaGUpKTtcbiAgICB9XG59KTtcbkFQUEVORF9PUENPREVTLmFkZCg0NiAvKiBKdW1wVW5sZXNzICovLCAodm0sIHsgb3AxOiB0YXJnZXQgfSkgPT4ge1xuICAgIGxldCByZWZlcmVuY2UgPSB2bS5zdGFjay5wb3AoKTtcbiAgICBpZiAoaXNDb25zdChyZWZlcmVuY2UpKSB7XG4gICAgICAgIGlmICghcmVmZXJlbmNlLnZhbHVlKCkpIHtcbiAgICAgICAgICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBjYWNoZSA9IG5ldyBSZWZlcmVuY2VDYWNoZShyZWZlcmVuY2UpO1xuICAgICAgICBpZiAoIWNhY2hlLnBlZWsoKSkge1xuICAgICAgICAgICAgdm0uZ290byh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHZtLnVwZGF0ZVdpdGgobmV3IEFzc2VydChjYWNoZSkpO1xuICAgIH1cbn0pO1xuQVBQRU5EX09QQ09ERVMuYWRkKDIyIC8qIFJldHVybiAqLywgdm0gPT4gdm0ucmV0dXJuKCkpO1xuQVBQRU5EX09QQ09ERVMuYWRkKDIzIC8qIFJldHVyblRvICovLCAodm0sIHsgb3AxOiByZWxhdGl2ZSB9KSA9PiB7XG4gICAgdm0ucmV0dXJuVG8ocmVsYXRpdmUpO1xufSk7XG5leHBvcnQgY29uc3QgQ29uc3RUZXN0ID0gZnVuY3Rpb24gKHJlZiwgX2Vudikge1xuICAgIHJldHVybiBuZXcgQ29uc3RSZWZlcmVuY2UoISFyZWYudmFsdWUoKSk7XG59O1xuZXhwb3J0IGNvbnN0IFNpbXBsZVRlc3QgPSBmdW5jdGlvbiAocmVmLCBfZW52KSB7XG4gICAgcmV0dXJuIHJlZjtcbn07XG5leHBvcnQgY29uc3QgRW52aXJvbm1lbnRUZXN0ID0gZnVuY3Rpb24gKHJlZiwgZW52KSB7XG4gICAgcmV0dXJuIGVudi50b0NvbmRpdGlvbmFsUmVmZXJlbmNlKHJlZik7XG59O1xuQVBQRU5EX09QQ09ERVMuYWRkKDUxIC8qIFRlc3QgKi8sICh2bSwgeyBvcDE6IF9mdW5jIH0pID0+IHtcbiAgICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgICBsZXQgb3BlcmFuZCA9IHN0YWNrLnBvcCgpO1xuICAgIGxldCBmdW5jID0gdm0uY29uc3RhbnRzLmdldEZ1bmN0aW9uKF9mdW5jKTtcbiAgICBzdGFjay5wdXNoKGZ1bmMob3BlcmFuZCwgdm0uZW52KSk7XG59KTtcbmV4cG9ydCBjbGFzcyBBc3NlcnQgZXh0ZW5kcyBVcGRhdGluZ09wY29kZSB7XG4gICAgY29uc3RydWN0b3IoY2FjaGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2Fzc2VydCc7XG4gICAgICAgIHRoaXMudGFnID0gY2FjaGUudGFnO1xuICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgfVxuICAgIGV2YWx1YXRlKHZtKSB7XG4gICAgICAgIGxldCB7IGNhY2hlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaXNNb2RpZmllZChjYWNoZS5yZXZhbGlkYXRlKCkpKSB7XG4gICAgICAgICAgICB2bS50aHJvdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IHsgdHlwZSwgX2d1aWQsIGNhY2hlIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZXhwZWN0ZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBleHBlY3RlZCA9IEpTT04uc3RyaW5naWZ5KGNhY2hlLnBlZWsoKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkID0gU3RyaW5nKGNhY2hlLnBlZWsoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyZ3M6IFtdLFxuICAgICAgICAgICAgZGV0YWlsczogeyBleHBlY3RlZCB9LFxuICAgICAgICAgICAgZ3VpZDogX2d1aWQsXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEp1bXBJZk5vdE1vZGlmaWVkT3Bjb2RlIGV4dGVuZHMgVXBkYXRpbmdPcGNvZGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZywgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnR5cGUgPSAnanVtcC1pZi1ub3QtbW9kaWZpZWQnO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5sYXN0UmV2aXNpb24gPSB0YWcudmFsdWUoKTtcbiAgICB9XG4gICAgZXZhbHVhdGUodm0pIHtcbiAgICAgICAgbGV0IHsgdGFnLCB0YXJnZXQsIGxhc3RSZXZpc2lvbiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF2bS5hbHdheXNSZXZhbGlkYXRlICYmIHRhZy52YWxpZGF0ZShsYXN0UmV2aXNpb24pKSB7XG4gICAgICAgICAgICB2bS5nb3RvKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlkTW9kaWZ5KCkge1xuICAgICAgICB0aGlzLmxhc3RSZXZpc2lvbiA9IHRoaXMudGFnLnZhbHVlKCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyZ3M6IFtKU09OLnN0cmluZ2lmeSh0aGlzLnRhcmdldC5pbnNwZWN0KCkpXSxcbiAgICAgICAgICAgIGd1aWQ6IHRoaXMuX2d1aWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGVcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGlkTW9kaWZ5T3Bjb2RlIGV4dGVuZHMgVXBkYXRpbmdPcGNvZGUge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy50eXBlID0gJ2RpZC1tb2RpZnknO1xuICAgICAgICB0aGlzLnRhZyA9IENPTlNUQU5UX1RBRztcbiAgICB9XG4gICAgZXZhbHVhdGUoKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0LmRpZE1vZGlmeSgpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMYWJlbE9wY29kZSB7XG4gICAgY29uc3RydWN0b3IobGFiZWwpIHtcbiAgICAgICAgdGhpcy50YWcgPSBDT05TVEFOVF9UQUc7XG4gICAgICAgIHRoaXMudHlwZSA9ICdsYWJlbCc7XG4gICAgICAgIHRoaXMubGFiZWwgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICBpbml0aWFsaXplR3VpZCh0aGlzKTtcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIH1cbiAgICBldmFsdWF0ZSgpIHt9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGFiZWx9IFske3RoaXMuX2d1aWR9XWA7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFyZ3M6IFtKU09OLnN0cmluZ2lmeSh0aGlzLmluc3BlY3QoKSldLFxuICAgICAgICAgICAgZ3VpZDogdGhpcy5fZ3VpZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgICAgICB9O1xuICAgIH1cbn0iXX0=