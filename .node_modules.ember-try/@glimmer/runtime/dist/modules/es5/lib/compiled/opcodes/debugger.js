function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { dict } from '@glimmer/util';
import { APPEND_OPCODES } from '../../opcodes';
/* tslint:disable */
function debugCallback(context, get) {
    console.info('Use `context`, and `get(<path>)` to debug this template.');
    // for example...
    context === get('this');
    debugger;
}
/* tslint:enable */
var callback = debugCallback;
// For testing purposes
export function setDebuggerCallback(cb) {
    callback = cb;
}
export function resetDebuggerCallback() {
    callback = debugCallback;
}

var ScopeInspector = function () {
    function ScopeInspector(scope, symbols, evalInfo) {
        _classCallCheck(this, ScopeInspector);

        this.scope = scope;
        this.locals = dict();
        for (var i = 0; i < evalInfo.length; i++) {
            var slot = evalInfo[i];
            var name = symbols[slot - 1];
            var ref = scope.getSymbol(slot);
            this.locals[name] = ref;
        }
    }

    ScopeInspector.prototype.get = function get(path) {
        var scope = this.scope,
            locals = this.locals;

        var parts = path.split('.');

        var _path$split = path.split('.'),
            head = _path$split[0],
            tail = _path$split.slice(1);

        var evalScope = scope.getEvalScope();
        var ref = void 0;
        if (head === 'this') {
            ref = scope.getSelf();
        } else if (locals[head]) {
            ref = locals[head];
        } else if (head.indexOf('@') === 0 && evalScope[head]) {
            ref = evalScope[head];
        } else {
            ref = this.scope.getSelf();
            tail = parts;
        }
        return tail.reduce(function (r, part) {
            return r.get(part);
        }, ref);
    };

    return ScopeInspector;
}();

APPEND_OPCODES.add(71 /* Debugger */, function (vm, _ref) {
    var _symbols = _ref.op1,
        _evalInfo = _ref.op2;

    var symbols = vm.constants.getOther(_symbols);
    var evalInfo = vm.constants.getArray(_evalInfo);
    var inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
    callback(vm.getSelf().value(), function (path) {
        return inspector.get(path).value();
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21waWxlZC9vcGNvZGVzL2RlYnVnZ2VyLmpzIl0sIm5hbWVzIjpbImRpY3QiLCJBUFBFTkRfT1BDT0RFUyIsImRlYnVnQ2FsbGJhY2siLCJjb250ZXh0IiwiZ2V0IiwiY29uc29sZSIsImluZm8iLCJjYWxsYmFjayIsInNldERlYnVnZ2VyQ2FsbGJhY2siLCJjYiIsInJlc2V0RGVidWdnZXJDYWxsYmFjayIsIlNjb3BlSW5zcGVjdG9yIiwic2NvcGUiLCJzeW1ib2xzIiwiZXZhbEluZm8iLCJsb2NhbHMiLCJpIiwibGVuZ3RoIiwic2xvdCIsIm5hbWUiLCJyZWYiLCJnZXRTeW1ib2wiLCJwYXRoIiwicGFydHMiLCJzcGxpdCIsImhlYWQiLCJ0YWlsIiwiZXZhbFNjb3BlIiwiZ2V0RXZhbFNjb3BlIiwiZ2V0U2VsZiIsImluZGV4T2YiLCJyZWR1Y2UiLCJyIiwicGFydCIsImFkZCIsInZtIiwiX3N5bWJvbHMiLCJvcDEiLCJfZXZhbEluZm8iLCJvcDIiLCJjb25zdGFudHMiLCJnZXRPdGhlciIsImdldEFycmF5IiwiaW5zcGVjdG9yIiwidmFsdWUiXSwibWFwcGluZ3MiOiI7O0FBQUEsU0FBU0EsSUFBVCxRQUFxQixlQUFyQjtBQUNBLFNBQVNDLGNBQVQsUUFBK0IsZUFBL0I7QUFDQTtBQUNBLFNBQVNDLGFBQVQsQ0FBdUJDLE9BQXZCLEVBQWdDQyxHQUFoQyxFQUFxQztBQUNqQ0MsWUFBUUMsSUFBUixDQUFhLDBEQUFiO0FBQ0E7QUFDQUgsZ0JBQVlDLElBQUksTUFBSixDQUFaO0FBQ0E7QUFDSDtBQUNEO0FBQ0EsSUFBSUcsV0FBV0wsYUFBZjtBQUNBO0FBQ0EsT0FBTyxTQUFTTSxtQkFBVCxDQUE2QkMsRUFBN0IsRUFBaUM7QUFDcENGLGVBQVdFLEVBQVg7QUFDSDtBQUNELE9BQU8sU0FBU0MscUJBQVQsR0FBaUM7QUFDcENILGVBQVdMLGFBQVg7QUFDSDs7SUFDS1MsYztBQUNGLDRCQUFZQyxLQUFaLEVBQW1CQyxPQUFuQixFQUE0QkMsUUFBNUIsRUFBc0M7QUFBQTs7QUFDbEMsYUFBS0YsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsYUFBS0csTUFBTCxHQUFjZixNQUFkO0FBQ0EsYUFBSyxJQUFJZ0IsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRixTQUFTRyxNQUE3QixFQUFxQ0QsR0FBckMsRUFBMEM7QUFDdEMsZ0JBQUlFLE9BQU9KLFNBQVNFLENBQVQsQ0FBWDtBQUNBLGdCQUFJRyxPQUFPTixRQUFRSyxPQUFPLENBQWYsQ0FBWDtBQUNBLGdCQUFJRSxNQUFNUixNQUFNUyxTQUFOLENBQWdCSCxJQUFoQixDQUFWO0FBQ0EsaUJBQUtILE1BQUwsQ0FBWUksSUFBWixJQUFvQkMsR0FBcEI7QUFDSDtBQUNKOzs2QkFDRGhCLEcsZ0JBQUlrQixJLEVBQU07QUFBQSxZQUNBVixLQURBLEdBQ2tCLElBRGxCLENBQ0FBLEtBREE7QUFBQSxZQUNPRyxNQURQLEdBQ2tCLElBRGxCLENBQ09BLE1BRFA7O0FBRU4sWUFBSVEsUUFBUUQsS0FBS0UsS0FBTCxDQUFXLEdBQVgsQ0FBWjs7QUFGTSwwQkFHZ0JGLEtBQUtFLEtBQUwsQ0FBVyxHQUFYLENBSGhCO0FBQUEsWUFHREMsSUFIQztBQUFBLFlBR1FDLElBSFI7O0FBSU4sWUFBSUMsWUFBWWYsTUFBTWdCLFlBQU4sRUFBaEI7QUFDQSxZQUFJUixZQUFKO0FBQ0EsWUFBSUssU0FBUyxNQUFiLEVBQXFCO0FBQ2pCTCxrQkFBTVIsTUFBTWlCLE9BQU4sRUFBTjtBQUNILFNBRkQsTUFFTyxJQUFJZCxPQUFPVSxJQUFQLENBQUosRUFBa0I7QUFDckJMLGtCQUFNTCxPQUFPVSxJQUFQLENBQU47QUFDSCxTQUZNLE1BRUEsSUFBSUEsS0FBS0ssT0FBTCxDQUFhLEdBQWIsTUFBc0IsQ0FBdEIsSUFBMkJILFVBQVVGLElBQVYsQ0FBL0IsRUFBZ0Q7QUFDbkRMLGtCQUFNTyxVQUFVRixJQUFWLENBQU47QUFDSCxTQUZNLE1BRUE7QUFDSEwsa0JBQU0sS0FBS1IsS0FBTCxDQUFXaUIsT0FBWCxFQUFOO0FBQ0FILG1CQUFPSCxLQUFQO0FBQ0g7QUFDRCxlQUFPRyxLQUFLSyxNQUFMLENBQVksVUFBQ0MsQ0FBRCxFQUFJQyxJQUFKO0FBQUEsbUJBQWFELEVBQUU1QixHQUFGLENBQU02QixJQUFOLENBQWI7QUFBQSxTQUFaLEVBQXNDYixHQUF0QyxDQUFQO0FBQ0gsSzs7Ozs7QUFFTG5CLGVBQWVpQyxHQUFmLENBQW1CLEVBQW5CLENBQXNCLGNBQXRCLEVBQXNDLFVBQUNDLEVBQUQsUUFBMkM7QUFBQSxRQUEvQkMsUUFBK0IsUUFBcENDLEdBQW9DO0FBQUEsUUFBaEJDLFNBQWdCLFFBQXJCQyxHQUFxQjs7QUFDN0UsUUFBSTFCLFVBQVVzQixHQUFHSyxTQUFILENBQWFDLFFBQWIsQ0FBc0JMLFFBQXRCLENBQWQ7QUFDQSxRQUFJdEIsV0FBV3FCLEdBQUdLLFNBQUgsQ0FBYUUsUUFBYixDQUFzQkosU0FBdEIsQ0FBZjtBQUNBLFFBQUlLLFlBQVksSUFBSWhDLGNBQUosQ0FBbUJ3QixHQUFHdkIsS0FBSCxFQUFuQixFQUErQkMsT0FBL0IsRUFBd0NDLFFBQXhDLENBQWhCO0FBQ0FQLGFBQVM0QixHQUFHTixPQUFILEdBQWFlLEtBQWIsRUFBVCxFQUErQjtBQUFBLGVBQVFELFVBQVV2QyxHQUFWLENBQWNrQixJQUFkLEVBQW9Cc0IsS0FBcEIsRUFBUjtBQUFBLEtBQS9CO0FBQ0gsQ0FMRCIsImZpbGUiOiJsaWIvY29tcGlsZWQvb3Bjb2Rlcy9kZWJ1Z2dlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRpY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTIH0gZnJvbSAnLi4vLi4vb3Bjb2Rlcyc7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuZnVuY3Rpb24gZGVidWdDYWxsYmFjayhjb250ZXh0LCBnZXQpIHtcbiAgICBjb25zb2xlLmluZm8oJ1VzZSBgY29udGV4dGAsIGFuZCBgZ2V0KDxwYXRoPilgIHRvIGRlYnVnIHRoaXMgdGVtcGxhdGUuJyk7XG4gICAgLy8gZm9yIGV4YW1wbGUuLi5cbiAgICBjb250ZXh0ID09PSBnZXQoJ3RoaXMnKTtcbiAgICBkZWJ1Z2dlcjtcbn1cbi8qIHRzbGludDplbmFibGUgKi9cbmxldCBjYWxsYmFjayA9IGRlYnVnQ2FsbGJhY2s7XG4vLyBGb3IgdGVzdGluZyBwdXJwb3Nlc1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlYnVnZ2VyQ2FsbGJhY2soY2IpIHtcbiAgICBjYWxsYmFjayA9IGNiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0RGVidWdnZXJDYWxsYmFjaygpIHtcbiAgICBjYWxsYmFjayA9IGRlYnVnQ2FsbGJhY2s7XG59XG5jbGFzcyBTY29wZUluc3BlY3RvciB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUsIHN5bWJvbHMsIGV2YWxJbmZvKSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5sb2NhbHMgPSBkaWN0KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZhbEluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzbG90ID0gZXZhbEluZm9baV07XG4gICAgICAgICAgICBsZXQgbmFtZSA9IHN5bWJvbHNbc2xvdCAtIDFdO1xuICAgICAgICAgICAgbGV0IHJlZiA9IHNjb3BlLmdldFN5bWJvbChzbG90KTtcbiAgICAgICAgICAgIHRoaXMubG9jYWxzW25hbWVdID0gcmVmO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChwYXRoKSB7XG4gICAgICAgIGxldCB7IHNjb3BlLCBsb2NhbHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IFtoZWFkLCAuLi50YWlsXSA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IGV2YWxTY29wZSA9IHNjb3BlLmdldEV2YWxTY29wZSgpO1xuICAgICAgICBsZXQgcmVmO1xuICAgICAgICBpZiAoaGVhZCA9PT0gJ3RoaXMnKSB7XG4gICAgICAgICAgICByZWYgPSBzY29wZS5nZXRTZWxmKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxzW2hlYWRdKSB7XG4gICAgICAgICAgICByZWYgPSBsb2NhbHNbaGVhZF07XG4gICAgICAgIH0gZWxzZSBpZiAoaGVhZC5pbmRleE9mKCdAJykgPT09IDAgJiYgZXZhbFNjb3BlW2hlYWRdKSB7XG4gICAgICAgICAgICByZWYgPSBldmFsU2NvcGVbaGVhZF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWYgPSB0aGlzLnNjb3BlLmdldFNlbGYoKTtcbiAgICAgICAgICAgIHRhaWwgPSBwYXJ0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFpbC5yZWR1Y2UoKHIsIHBhcnQpID0+IHIuZ2V0KHBhcnQpLCByZWYpO1xuICAgIH1cbn1cbkFQUEVORF9PUENPREVTLmFkZCg3MSAvKiBEZWJ1Z2dlciAqLywgKHZtLCB7IG9wMTogX3N5bWJvbHMsIG9wMjogX2V2YWxJbmZvIH0pID0+IHtcbiAgICBsZXQgc3ltYm9scyA9IHZtLmNvbnN0YW50cy5nZXRPdGhlcihfc3ltYm9scyk7XG4gICAgbGV0IGV2YWxJbmZvID0gdm0uY29uc3RhbnRzLmdldEFycmF5KF9ldmFsSW5mbyk7XG4gICAgbGV0IGluc3BlY3RvciA9IG5ldyBTY29wZUluc3BlY3Rvcih2bS5zY29wZSgpLCBzeW1ib2xzLCBldmFsSW5mbyk7XG4gICAgY2FsbGJhY2sodm0uZ2V0U2VsZigpLnZhbHVlKCksIHBhdGggPT4gaW5zcGVjdG9yLmdldChwYXRoKS52YWx1ZSgpKTtcbn0pOyJdfQ==