function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { unreachable } from '@glimmer/util';
import { clear, single, SingleNodeBounds } from './bounds';
export function isSafeString(value) {
    return typeof value === 'object' && value !== null && typeof value.toHTML === 'function';
}
export function isNode(value) {
    return typeof value === 'object' && value !== null && typeof value.nodeType === 'number';
}
export function isString(value) {
    return typeof value === 'string';
}

var Upsert = function Upsert(bounds) {
    _classCallCheck(this, Upsert);

    this.bounds = bounds;
};

export default Upsert;
export function cautiousInsert(dom, cursor, value) {
    if (isString(value)) {
        return TextUpsert.insert(dom, cursor, value);
    }
    if (isSafeString(value)) {
        return SafeStringUpsert.insert(dom, cursor, value);
    }
    if (isNode(value)) {
        return NodeUpsert.insert(dom, cursor, value);
    }
    throw unreachable();
}
export function trustingInsert(dom, cursor, value) {
    if (isString(value)) {
        return HTMLUpsert.insert(dom, cursor, value);
    }
    if (isNode(value)) {
        return NodeUpsert.insert(dom, cursor, value);
    }
    throw unreachable();
}

var TextUpsert = function (_Upsert) {
    _inherits(TextUpsert, _Upsert);

    TextUpsert.insert = function insert(dom, cursor, value) {
        var textNode = dom.createTextNode(value);
        dom.insertBefore(cursor.element, textNode, cursor.nextSibling);
        var bounds = new SingleNodeBounds(cursor.element, textNode);
        return new TextUpsert(bounds, textNode);
    };

    function TextUpsert(bounds, textNode) {
        _classCallCheck(this, TextUpsert);

        var _this = _possibleConstructorReturn(this, _Upsert.call(this, bounds));

        _this.textNode = textNode;
        return _this;
    }

    TextUpsert.prototype.update = function update(_dom, value) {
        if (isString(value)) {
            var textNode = this.textNode;

            textNode.nodeValue = value;
            return true;
        } else {
            return false;
        }
    };

    return TextUpsert;
}(Upsert);

var HTMLUpsert = function (_Upsert2) {
    _inherits(HTMLUpsert, _Upsert2);

    function HTMLUpsert() {
        _classCallCheck(this, HTMLUpsert);

        return _possibleConstructorReturn(this, _Upsert2.apply(this, arguments));
    }

    HTMLUpsert.insert = function insert(dom, cursor, value) {
        var bounds = dom.insertHTMLBefore(cursor.element, cursor.nextSibling, value);
        return new HTMLUpsert(bounds);
    };

    HTMLUpsert.prototype.update = function update(dom, value) {
        if (isString(value)) {
            var bounds = this.bounds;

            var parentElement = bounds.parentElement();
            var nextSibling = clear(bounds);
            this.bounds = dom.insertHTMLBefore(parentElement, nextSibling, value);
            return true;
        } else {
            return false;
        }
    };

    return HTMLUpsert;
}(Upsert);

var SafeStringUpsert = function (_Upsert3) {
    _inherits(SafeStringUpsert, _Upsert3);

    function SafeStringUpsert(bounds, lastStringValue) {
        _classCallCheck(this, SafeStringUpsert);

        var _this3 = _possibleConstructorReturn(this, _Upsert3.call(this, bounds));

        _this3.lastStringValue = lastStringValue;
        return _this3;
    }

    SafeStringUpsert.insert = function insert(dom, cursor, value) {
        var stringValue = value.toHTML();
        var bounds = dom.insertHTMLBefore(cursor.element, cursor.nextSibling, stringValue);
        return new SafeStringUpsert(bounds, stringValue);
    };

    SafeStringUpsert.prototype.update = function update(dom, value) {
        if (isSafeString(value)) {
            var stringValue = value.toHTML();
            if (stringValue !== this.lastStringValue) {
                var bounds = this.bounds;

                var parentElement = bounds.parentElement();
                var nextSibling = clear(bounds);
                this.bounds = dom.insertHTMLBefore(parentElement, nextSibling, stringValue);
                this.lastStringValue = stringValue;
            }
            return true;
        } else {
            return false;
        }
    };

    return SafeStringUpsert;
}(Upsert);

var NodeUpsert = function (_Upsert4) {
    _inherits(NodeUpsert, _Upsert4);

    function NodeUpsert() {
        _classCallCheck(this, NodeUpsert);

        return _possibleConstructorReturn(this, _Upsert4.apply(this, arguments));
    }

    NodeUpsert.insert = function insert(dom, cursor, node) {
        dom.insertBefore(cursor.element, node, cursor.nextSibling);
        return new NodeUpsert(single(cursor.element, node));
    };

    NodeUpsert.prototype.update = function update(dom, value) {
        if (isNode(value)) {
            var bounds = this.bounds;

            var parentElement = bounds.parentElement();
            var nextSibling = clear(bounds);
            this.bounds = dom.insertNodeBefore(parentElement, value, nextSibling);
            return true;
        } else {
            return false;
        }
    };

    return NodeUpsert;
}(Upsert);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi91cHNlcnQuanMiXSwibmFtZXMiOlsidW5yZWFjaGFibGUiLCJjbGVhciIsInNpbmdsZSIsIlNpbmdsZU5vZGVCb3VuZHMiLCJpc1NhZmVTdHJpbmciLCJ2YWx1ZSIsInRvSFRNTCIsImlzTm9kZSIsIm5vZGVUeXBlIiwiaXNTdHJpbmciLCJVcHNlcnQiLCJib3VuZHMiLCJjYXV0aW91c0luc2VydCIsImRvbSIsImN1cnNvciIsIlRleHRVcHNlcnQiLCJpbnNlcnQiLCJTYWZlU3RyaW5nVXBzZXJ0IiwiTm9kZVVwc2VydCIsInRydXN0aW5nSW5zZXJ0IiwiSFRNTFVwc2VydCIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJlbGVtZW50IiwibmV4dFNpYmxpbmciLCJ1cGRhdGUiLCJfZG9tIiwibm9kZVZhbHVlIiwiaW5zZXJ0SFRNTEJlZm9yZSIsInBhcmVudEVsZW1lbnQiLCJsYXN0U3RyaW5nVmFsdWUiLCJzdHJpbmdWYWx1ZSIsIm5vZGUiLCJpbnNlcnROb2RlQmVmb3JlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLFNBQVNBLFdBQVQsUUFBNEIsZUFBNUI7QUFDQSxTQUFTQyxLQUFULEVBQWdCQyxNQUFoQixFQUF3QkMsZ0JBQXhCLFFBQWdELFVBQWhEO0FBQ0EsT0FBTyxTQUFTQyxZQUFULENBQXNCQyxLQUF0QixFQUE2QjtBQUNoQyxXQUFPLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLFVBQVUsSUFBdkMsSUFBK0MsT0FBT0EsTUFBTUMsTUFBYixLQUF3QixVQUE5RTtBQUNIO0FBQ0QsT0FBTyxTQUFTQyxNQUFULENBQWdCRixLQUFoQixFQUF1QjtBQUMxQixXQUFPLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLFVBQVUsSUFBdkMsSUFBK0MsT0FBT0EsTUFBTUcsUUFBYixLQUEwQixRQUFoRjtBQUNIO0FBQ0QsT0FBTyxTQUFTQyxRQUFULENBQWtCSixLQUFsQixFQUF5QjtBQUM1QixX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LG1CQUFPLElBQVA7QUFDSCxTQVZELE1BVU87QUFDSCxtQkFBTyxLQUFQO0FBQ0g7QUFDSixLOzs7RUF4QjBCdEIsTTs7SUEwQnpCUSxVOzs7Ozs7Ozs7ZUFDS0YsTSxtQkFBT0gsRyxFQUFLQyxNLEVBQVFtQixJLEVBQU07QUFDN0JwQixZQUFJVSxZQUFKLENBQWlCVCxPQUFPVSxPQUF4QixFQUFpQ1MsSUFBakMsRUFBdUNuQixPQUFPVyxXQUE5QztBQUNBLGVBQU8sSUFBSVAsVUFBSixDQUFlaEIsT0FBT1ksT0FBT1UsT0FBZCxFQUF1QlMsSUFBdkIsQ0FBZixDQUFQO0FBQ0gsSzs7eUJBQ0RQLE0sbUJBQU9iLEcsRUFBS1IsSyxFQUFPO0FBQ2YsWUFBSUUsT0FBT0YsS0FBUCxDQUFKLEVBQW1CO0FBQUEsZ0JBQ1RNLE1BRFMsR0FDRSxJQURGLENBQ1RBLE1BRFM7O0FBRWYsZ0JBQUltQixnQkFBZ0JuQixPQUFPbUIsYUFBUCxFQUFwQjtBQUNBLGdCQUFJTCxjQUFjeEIsTUFBTVUsTUFBTixDQUFsQjtBQUNBLGlCQUFLQSxNQUFMLEdBQWNFLElBQUlxQixnQkFBSixDQUFxQkosYUFBckIsRUFBb0N6QixLQUFwQyxFQUEyQ29CLFdBQTNDLENBQWQ7QUFDQSxtQkFBTyxJQUFQO0FBQ0gsU0FORCxNQU1PO0FBQ0gsbUJBQU8sS0FBUDtBQUNIO0FBQ0osSzs7O0VBZm9CZixNIiwiZmlsZSI6ImxpYi91cHNlcnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bnJlYWNoYWJsZSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgY2xlYXIsIHNpbmdsZSwgU2luZ2xlTm9kZUJvdW5kcyB9IGZyb20gJy4vYm91bmRzJztcbmV4cG9ydCBmdW5jdGlvbiBpc1NhZmVTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9IVE1MID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5ub2RlVHlwZSA9PT0gJ251bWJlcic7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cbmNsYXNzIFVwc2VydCB7XG4gICAgY29uc3RydWN0b3IoYm91bmRzKSB7XG4gICAgICAgIHRoaXMuYm91bmRzID0gYm91bmRzO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFVwc2VydDtcbmV4cG9ydCBmdW5jdGlvbiBjYXV0aW91c0luc2VydChkb20sIGN1cnNvciwgdmFsdWUpIHtcbiAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBUZXh0VXBzZXJ0Lmluc2VydChkb20sIGN1cnNvciwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNTYWZlU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gU2FmZVN0cmluZ1Vwc2VydC5pbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5vZGVVcHNlcnQuaW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IHVucmVhY2hhYmxlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdHJ1c3RpbmdJbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKSB7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gSFRNTFVwc2VydC5pbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE5vZGVVcHNlcnQuaW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSk7XG4gICAgfVxuICAgIHRocm93IHVucmVhY2hhYmxlKCk7XG59XG5jbGFzcyBUZXh0VXBzZXJ0IGV4dGVuZHMgVXBzZXJ0IHtcbiAgICBzdGF0aWMgaW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICBsZXQgdGV4dE5vZGUgPSBkb20uY3JlYXRlVGV4dE5vZGUodmFsdWUpO1xuICAgICAgICBkb20uaW5zZXJ0QmVmb3JlKGN1cnNvci5lbGVtZW50LCB0ZXh0Tm9kZSwgY3Vyc29yLm5leHRTaWJsaW5nKTtcbiAgICAgICAgbGV0IGJvdW5kcyA9IG5ldyBTaW5nbGVOb2RlQm91bmRzKGN1cnNvci5lbGVtZW50LCB0ZXh0Tm9kZSk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFVwc2VydChib3VuZHMsIHRleHROb2RlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYm91bmRzLCB0ZXh0Tm9kZSkge1xuICAgICAgICBzdXBlcihib3VuZHMpO1xuICAgICAgICB0aGlzLnRleHROb2RlID0gdGV4dE5vZGU7XG4gICAgfVxuICAgIHVwZGF0ZShfZG9tLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgeyB0ZXh0Tm9kZSB9ID0gdGhpcztcbiAgICAgICAgICAgIHRleHROb2RlLm5vZGVWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBIVE1MVXBzZXJ0IGV4dGVuZHMgVXBzZXJ0IHtcbiAgICBzdGF0aWMgaW5zZXJ0KGRvbSwgY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICBsZXQgYm91bmRzID0gZG9tLmluc2VydEhUTUxCZWZvcmUoY3Vyc29yLmVsZW1lbnQsIGN1cnNvci5uZXh0U2libGluZywgdmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IEhUTUxVcHNlcnQoYm91bmRzKTtcbiAgICB9XG4gICAgdXBkYXRlKGRvbSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHsgYm91bmRzIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHBhcmVudEVsZW1lbnQgPSBib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gY2xlYXIoYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0gZG9tLmluc2VydEhUTUxCZWZvcmUocGFyZW50RWxlbWVudCwgbmV4dFNpYmxpbmcsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2FmZVN0cmluZ1Vwc2VydCBleHRlbmRzIFVwc2VydCB7XG4gICAgY29uc3RydWN0b3IoYm91bmRzLCBsYXN0U3RyaW5nVmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYm91bmRzKTtcbiAgICAgICAgdGhpcy5sYXN0U3RyaW5nVmFsdWUgPSBsYXN0U3RyaW5nVmFsdWU7XG4gICAgfVxuICAgIHN0YXRpYyBpbnNlcnQoZG9tLCBjdXJzb3IsIHZhbHVlKSB7XG4gICAgICAgIGxldCBzdHJpbmdWYWx1ZSA9IHZhbHVlLnRvSFRNTCgpO1xuICAgICAgICBsZXQgYm91bmRzID0gZG9tLmluc2VydEhUTUxCZWZvcmUoY3Vyc29yLmVsZW1lbnQsIGN1cnNvci5uZXh0U2libGluZywgc3RyaW5nVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVTdHJpbmdVcHNlcnQoYm91bmRzLCBzdHJpbmdWYWx1ZSk7XG4gICAgfVxuICAgIHVwZGF0ZShkb20sIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc1NhZmVTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nVmFsdWUgPSB2YWx1ZS50b0hUTUwoKTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdWYWx1ZSAhPT0gdGhpcy5sYXN0U3RyaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBib3VuZHMgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudEVsZW1lbnQgPSBib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2libGluZyA9IGNsZWFyKGJvdW5kcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZHMgPSBkb20uaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnRFbGVtZW50LCBuZXh0U2libGluZywgc3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFN0cmluZ1ZhbHVlID0gc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIE5vZGVVcHNlcnQgZXh0ZW5kcyBVcHNlcnQge1xuICAgIHN0YXRpYyBpbnNlcnQoZG9tLCBjdXJzb3IsIG5vZGUpIHtcbiAgICAgICAgZG9tLmluc2VydEJlZm9yZShjdXJzb3IuZWxlbWVudCwgbm9kZSwgY3Vyc29yLm5leHRTaWJsaW5nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlVXBzZXJ0KHNpbmdsZShjdXJzb3IuZWxlbWVudCwgbm9kZSkpO1xuICAgIH1cbiAgICB1cGRhdGUoZG9tLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IHsgYm91bmRzIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHBhcmVudEVsZW1lbnQgPSBib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICAgICAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gY2xlYXIoYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0gZG9tLmluc2VydE5vZGVCZWZvcmUocGFyZW50RWxlbWVudCwgdmFsdWUsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufSJdfQ==